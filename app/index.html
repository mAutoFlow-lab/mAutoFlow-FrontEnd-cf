<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <title>mAutoFlow</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        :root {
            /* 기본 테마 (classic) */
            --bg-main: #f3f4f6;
            --bg-header: #1f2933;
            --header-text: #f9fafb;

            --bg-code: #111827;
            --code-text: #e5e7eb;
            --code-border: #d1d5db;

            --bg-chart: #ffffff;
            --chart-border: #d1d5db;

            --accent-primary: #2563eb;
            --accent-primary-hover: #1d4ed8;

            --toolbar-text: #374151;
        }

        /* 라이트 테마 */
        body[data-theme="light"] {
            --bg-main: #f9fafb;
            --bg-header: #2563eb;
            --header-text: #ffffff;

            --bg-code: #ffffff;
            --code-text: #111827;
            --code-border: #d1d5db;

            --bg-chart: #ffffff;
            --chart-border: #d1d5db;

            --accent-primary: #2563eb;
            --accent-primary-hover: #1d4ed8;

            --toolbar-text: #111827;
        }

        /* 다크 테마 */
        body[data-theme="dark"] {
            --bg-main: #020617;
            --bg-header: #020617;
            --header-text: #e5e7eb;

            --bg-code: #020617;
            --code-text: #e5e7eb;
            --code-border: #1f2937;

            --bg-chart: #020617;
            --chart-border: #1f2937;

            --accent-primary: #22c55e;
            --accent-primary-hover: #16a34a;

            --toolbar-text: #e5e7eb;
        }

        /* Mermaid SVG Override (dark) */
        body[data-theme="dark"] #chartInner svg path {
            stroke: #f8fafc !important;
        }
        body[data-theme="dark"] #chartInner svg line {
            stroke: #f8fafc !important;
        }
        body[data-theme="dark"] #chartInner svg polygon {
            stroke: #f8fafc !important;
            fill: #f8fafc !important;
        }
        body[data-theme="dark"] #chartInner svg marker path {
            stroke: #f8fafc !important;
            fill: #f8fafc !important;
        }
    
        * { box-sizing: border-box; }
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
        }
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            font-size: 14px; /* UI 기본 폰트 */
            background: var(--bg-main);
            padding-bottom: 32px; /* footer 높이만큼 (겹침 방지) */
        }
        header {
            padding: 10px 16px;
            background: var(--bg-header); /* ← 변경 */
            color: var(--header-text);    /* ← 변경 */
            display: flex;
            align-items: center;
            justify-content: flex-start;   /* ✅ 왼쪽부터 쌓기 */
            gap: 10px;                     /* (선택) 로고-버튼 간격 */

            position: relative; /* ✅ #legalNav absolute 기준점 */
        }
        header h1 {
            margin: 0;
            font-size: 20px;
        }
        header .subtitle {
            font-size: 12px;
            opacity: 0.85;
        }

        /* ===== Animated Logo ===== */
        .logo{
          display: inline-flex;
          gap: 0px;
          font-size: 20px;       /* 기존 header h1 크기(20px)와 맞춤 */
          font-weight: bold;
          line-height: 1.1;
          user-select: none;
          cursor: default;
        }

        .logo .logo-letter{
          display: inline-block;
          position: relative;           /* ✅ left 애니메이션 필요 */
          left: 0px;                    /* ✅ 기본값 */
          will-change: transform, left; /* ✅ */
          animation-name: logoFloat;
          animation-duration: 2.6s;
          animation-iteration-count: infinite;
          animation-timing-function: ease-in-out;

          /* ✅ 글자 색상 */
          color: #D78FEE;   /* 핑크 */
        }

        /* 둥실둥실 + 살짝 좌우 흔들림 */
        @keyframes logoFloat{
          0%   { transform: translate(0px, 0px) rotate(0deg); }
          25%  { transform: translate(1px, -2px) rotate(1deg); }
          50%  { transform: translate(0px, 0px) rotate(0deg); }
          75%  { transform: translate(-1px, 2px) rotate(-1deg); }
          100% { transform: translate(0px, 0px) rotate(0deg); }
        }

        /* 특정 글자(예: m, A)에만 가끔 뒤집힘 */
        .logo .flip {
          animation-name: logoFloat, logoFlip;
          animation-duration: 2.6s, 4.8s;
          animation-iteration-count: infinite, infinite;
          animation-timing-function: ease-in-out, ease-in-out;
        }

        @keyframes logoFlip{
          0%   { transform: translate(0px, 0px) rotate(0deg); }
          70%  { transform: translate(0px, 0px) rotate(0deg); }
          85%  { transform: translate(0px, -2px) rotate(180deg); }
          100% { transform: translate(0px, 0px) rotate(360deg); }
        }

        /* ===== Scenario: w move -> snap -> mA spin (1회) ===== */

        /* w는 계속 오른쪽으로 가다가, 뒤집힘 타이밍에 빠르게 복귀 */
        .logo .w-loop{
          animation-name: logoFloat, wDriftLoop;
          animation-duration: 2.6s, 4.8s;                 /* ✅ 4.8s: mA 뒤집힘 주기와 맞춤 */
          animation-iteration-count: infinite, infinite;  /* ✅ 반복 */
          animation-timing-function: ease-in-out, ease-in-out;
        }

        /* 변경 (✅ 84.9%에 먼저 붙고, 이후는 0 유지) */
        @keyframes wDriftLoop{
          0%    { left: 0px; }
          82%   { left: var(--wDriftX, 28px); }  /* 계속 멀어짐 */
          84.9% { left: 0px; }                   /* ✅ 여기서 '붙음' 완료 */
          100%  { left: 0px; }                   /* 붙은 채 유지 */
        }

        /* mA는 뒤집힘 구간에서만 1회 회전(주기 반복) */
        .logo .ma-loop{
          animation-name: logoFloat, maSpinLoop;
          animation-duration: 2.6s, 4.8s;
          animation-iteration-count: infinite, infinite;
          animation-timing-function: ease-in-out, ease-in-out;
        }

        /* 변경 (✅ 87%부터 뒤집힘 시작 → w가 84.9%에 먼저 붙고 0.1초 후 뒤집힘) */
        @keyframes maSpinLoop{
          0%   { transform: translate(0px, 0px) rotate(0deg); }
          87%  { transform: translate(0px, 0px) rotate(0deg); }     /* 뒤집힘 시작 전 대기 */
          94%  { transform: translate(0px, -2px) rotate(180deg); }  /* 중간 */
          100% { transform: translate(0px, 0px) rotate(360deg); }   /* 완료 */
        }


        /* mA가 "그 순간"에만 1회 회전 */
        .logo .ma-spin {
          animation-name: logoFloat, maSpinOnce;
          animation-duration: 2.6s, 0.9s;
          animation-iteration-count: infinite, 1;
          animation-timing-function: ease-in-out, ease-in-out;
        }

        @keyframes maSpinOnce {
          0%   { transform: translate(0px, 0px) rotate(0deg) scale(1); }
          40%  { transform: translate(0px, -2px) rotate(140deg) scale(1.06); }
          100% { transform: translate(0px, 0px) rotate(360deg) scale(1); }
        }

        /* w가 오른쪽으로 "멀어지는" 단계 */
        .logo .w-drift {
          animation-name: logoFloat, wDriftOut;
          animation-duration: 2.6s, 1.2s;
          animation-iteration-count: infinite, 1;
          animation-timing-function: ease-in-out, ease-in-out;
          animation-fill-mode: none, forwards;
        }

        /* 변경 (✅ transform 건드리지 않음: logoFloat 유지) */
        @keyframes wDriftOut {
          0%   { left: 0px; }
          100% { left: var(--wDriftX, 70px); }
        }

        /* w가 o 옆으로 "탁" 붙는 단계 (snap) */
        .logo .w-snap {
          animation-name: logoFloat, wSnapToO;
          animation-duration: 2.6s, 120ms;
          animation-iteration-count: infinite, 1;
          animation-timing-function: ease-in-out, ease-out;
          animation-fill-mode: none, forwards;
        }

        /* snap 목표 위치(픽셀)는 JS가 --wSnapX 로 주입 */
        @keyframes wSnapToO {
          0%   { left: var(--wDriftX, 70px); }
          100% { left: 0px; }   /* ✅ “o 옆”은 원래 자리라서 0으로 복귀 */
        }
        
        .main {
            flex: 1;
            display: flex;
            min-height: 0;
            background: var(--bg-main);
        }

        #helpContent .help-link {
            color: var(--accent-primary);
            text-decoration: underline;
            font-weight: 600;
        }

        /* 좌측/우측 패널 + 드래그 분할바 */
        #leftPane {
            flex: 0 0 33%; /* 초기 약 1/3 */
            min-width: 200px;
            display: flex;
            flex-direction: column;
            padding: 8px;
            min-height: 0;
        }
        #divider {
            flex: 0 0 6px;
            cursor: col-resize;
            background: #d1d5db;
        }
        #divider:hover {
            background: #9ca3af;
        }
        #rightPane {
            flex: 0 0 67%; /* 초기 약 2/3 */
            min-width: 260px;
            display: flex;
            flex-direction: column;
            padding: 8px;
        }

        .pane-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 6px;
        }
        .pane-title {
            font-weight: 600;
            font-size: 14px;
            color: var(--toolbar-text);
        }

        /* 좌측 코드 영역 */
        #codeContainer {
            flex: 1;
            border-radius: 4px;
            border: 1px solid var(--code-border);  /* ← 변경 */
            background: var(--bg-code);            /* ← 변경 */
            display: flex;
            flex-direction: column;
            min-height: 0;
        }
        #codeHeader {
            padding: 4px 8px;
            border-bottom: 1px solid #4b5563;
            color: var(--code-text);      /* ← 변경 */
            font-size: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #codeArea {
            flex: 1;
            padding: 6px;
            display: flex;    /* ← 라인번호 + textarea 가 가로로 배치되도록 */
            min-height: 0;
        }

        /* HELP / SETTINGS 에서 왼쪽 패널 안에서만 세로 스크롤 되도록 */
        #leftPane,
        #codeContainer,
        #codeArea {
            min-height: 0;   /* flex column 안에서 자식이 내용보다 작아질 수 있게 허용 */
        }


        #lineNumbers {
            width: 40px;  /* 라인 번호 영역 너비 */
            padding: 6px 4px;
            text-align: right;
            color: var(--code-text);
            background: var(--bg-code);
            border-right: 1px solid var(--code-border);
            font-family: "Consolas", "Roboto Mono", monospace;
            font-size: 13px;
            line-height: 1.4;
            user-select: none;        /* 라인 번호 드래그 방지 */
            overflow: hidden;
        }
        
        #src {
            width: 100%;
            height: 100%;
            border: none;
            outline: none;
            resize: none;
            background: transparent;
            color: var(--code-text);      /* ← 변경 */
            font-family: "Consolas", "Roboto Mono", monospace;
            font-size: 13px;  /* 코드 글자 크기 (너무 크지 않게) */
            line-height: 1.4;
            flex: 1;                  /* ← 남은 영역 꽉 채우기 */
        }

        /* 우측 플로우차트 영역 */
        #toolbar {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
            font-size: 12px;
        }
        .btn {
            padding: 4px 10px;
            border-radius: 4px;
            border: none;
            cursor: pointer;
            font-size: 12px;
        }
        .btn-primary {
            background: var(--accent-primary);           /* ← 변경 */
            color: white;
        }
        .btn-primary:hover {
            background: var(--accent-primary-hover);     /* ← 변경 */
        }
        .btn-ghost {
            background: #e5e7eb;
            color: #111827;
        }
        .btn-ghost:hover {
            background: #d1d5db;
        }

        #status {
            font-size: 12px;
            color: var(--toolbar-text);                  /* ← 변경 */
        }
        #status.error {
            color: #b91c1c;
        }
        #status.success {
            color: #15803d;
        }
        #currentFunc {
            font-weight: 600;
            font-size: 12px;
            color: var(--toolbar-text);
        }

        #chartContainer {
            flex: 1;
            border-radius: 4px;
            border: 1px solid var(--chart-border); /* ← 변경 */
            background: var(--bg-chart);           /* ← 변경 */
            overflow: auto;

            /* flex 제거하고, 일반 블록 + 텍스트 정렬로 가운데 맞추기 */
            text-align: center;
        }
        #chartInner {
            display: inline-block;   /* 가운데 정렬 대상 */
            margin: 8px;
            transform-origin: top center;  /* 확대 기준은 그대로 중앙 */
        }
        #chartInner .mermaid {
            margin: 0 auto;
        }

        .placeholder {
            color: #9ca3af;
            font-size: 14px;
            text-align: center;
            margin-top: 40px;
        }

        /* Mermaid가 그리는 SVG를 우측 패널 너비에 맞게 조정 */
        #chartInner svg {
            max-width: none;
            height: auto;
            display: block;
            margin: 0 auto;
        }
        

        .zoom-label {
            font-size: 12px;
            min-width: 42px;
            color: var(--toolbar-text);
        }

        /* 코드 ↔ 노드 연동: 선택된 노드 하이라이트 (더 진하게) */
        .node.autoflow-selected rect,
        .node.autoflow-selected polygon,
        .node.autoflow-selected path {
            stroke: #ff0000;              /* 더 강한 빨간색 */
            stroke-width: 4px;            /* 테두리 두께 업 */
            stroke-dasharray: 0;          /* 실선 */
            filter: drop-shadow(0 0 6px rgba(255, 0, 0, 0.9));
        }

        /* 선택된 노드 텍스트도 강조 */
        .node.autoflow-selected text {
            font-weight: 700;
            fill: #000000;
        }

        .topbar-right {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            opacity: 0.9;
            flex-wrap: nowrap;    /* 버튼 줄바꿈 방지 */
            white-space: nowrap;  /* 텍스트 줄바꿈 방지 */
            margin-left: auto;   /* ✅ 오른쪽으로 밀어붙임(로고 안 밀림) */
        }


        .btn-settings {
            padding: 4px 10px;
            border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.4);
            background: transparent;
            color: inherit;
            cursor: pointer;
            font-size: 12px;
        }
        .btn-settings:hover {
            background: rgba(255,255,255,0.12);
        }

        /* HELP 모드에서 CODE 버튼 매우 부드러운 강조용 */
        .btn-code-blink {
            background: #f59e0b;             /* 기존보다 더 연한 주황색 */
            color: #ffffff;
            border-color: #fcd34d;           /* 연한 테두리 */
            animation: codeSoftBlink 2.4s ease-in-out infinite; /* 더 느리고 부드럽게 */
        }

        /* Upgrade 버튼 블링크 애니메이션 */
        @keyframes upgradeBlink {
            0%   { background-color: #a7f3d0; }  /* pastel green */
            50%  { background-color: #6ee7b7; }
            100% { background-color: #a7f3d0; }
        }

        .upgrade-blink {
            animation: upgradeBlink 1s infinite;
        }

        @keyframes codeSoftBlink {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.6;                /* 기존 0.35 → 훨씬 덜 흐려짐 */
            }
        }
                

        /* SETTINGS 모달 */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(15,23,42,0.55);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 50;
        }
        .modal-hidden {
            display: none;
        }
        .modal-panel {
            background: #ffffff;
            border-radius: 8px;
            padding: 16px 20px;
            min-width: 260px;
            max-width: 320px;
            box-shadow: 0 10px 40px rgba(15,23,42,0.45);
            font-size: 13px;
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }
        .modal-header h2 {
            margin: 0;
            font-size: 14px;
        }
        .modal-close {
            border: none;
            background: transparent;
            cursor: pointer;
            font-size: 16px;
        }

        /* SETTINGS - Macro Input width alignment */
        #macroInput{
          display: block;
          width: 100%;
          margin: 0;
          box-sizing: border-box;
        }     
                   
        /* SETTINGS 카드 섹션 */
        .modal-section {
            /* 위/아래 간격 + 좌우 살짝 여백 */
            margin: 18px 4px 22px;
            padding: 0 0 6px;
            background-color: transparent;      /* 카드 안/밖 색 동일 */
        }

        /* SETTINGS 그룹 타이틀 (Display Options / Macro Options) */
        .modal-group-title{
            font-weight: 700;
            font-size: 13px;

            /* ✅ 1단 들여쓰기 느낌 */
            margin: 14px 16px 8px;
            padding: 6px 10px 6px 12px;   /* ✅ 왼쪽만 깊게 */

            border-top: 1px solid rgba(148, 163, 184, 0.45);
            border-bottom: 1px solid rgba(148, 163, 184, 0.45);
        }

                           

        /* 섹션 위쪽에만 가로선 하나 (좌우 여백 있음) */
        .modal-section::before {
            content: "";
            display: block;

            border-top: 1px solid rgba(148, 163, 184, 0.35);

            /* ✅ 그룹 타이틀(1단) 시작점과 맞춤 */
            margin: 0 16px 10px 12px;
        }

                   
        /* 첫 섹션은 맨 위 선 제거 */
        .modal-section:first-of-type::before {
            border-top: none;
            margin-bottom: 0;
        }

        /* 섹션 제목 */
        .modal-section-title {
            font-weight: 600;
            margin: 0;

            /* ✅ 2단 들여쓰기 */
            padding: 0 10px 6px 44px;   /* left = 44px */

            background-color: transparent;
        }


        /* 라디오 영역 */
        .modal-radio-row {
            /* ✅ 3단 들여쓰기 */
            padding: 0 12px 0 62px;   /* left = 62px */

            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        /* ✅ Macro 섹션도 옵션 레벨(3단) 들여쓰기 유지 */
        .macro-section .modal-radio-row {
            padding: 0 12px 0 62px;
        }
            
        .modal-footer {
            margin-top: 16px;
            display: flex;
            justify-content: flex-end;  /* 오른쪽 정렬 */
        }

        .modal-footer-inner {
            background-color: transparent;   /* 카드 안/밖 동일 색 */
            border-radius: 4px;
            border: 1px solid rgba(15, 23, 42, 0.95);
            padding: 8px 12px 10px;
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .modal-footer-contact {
            font-size: 11px;
            opacity: 0.85;
        }

        .settings-contact-link {
            color: #facc15;              /* 어두운 배경에서 잘 보이는 노란색 */
            text-decoration: underline;
            font-weight: 600;
        }

        body[data-theme="dark"] input[type="radio"] {
            accent-color: #34d399;   /* 연두(emerald) */
        }
        body:not([data-theme="dark"]) input[type="radio"] {
            accent-color: #22c55e;   /* 연두(green) */
        }

        .help-subsection {
          margin-left: 1.5em;   /* 탭 느낌 */
        }           

        /* SHARE 모달은 조금 더 넓게 */
        .share-panel{
          max-width: 520px;
          width: 520px;
        }                   

        /* ===============================
           SETTINGS - Macro textarea style
           =============================== */
        .macro-input {
            resize: vertical;
            font-size: 12px;
            font-family: Consolas, "Roboto Mono", monospace;
            padding: 4px 6px;
            border-radius: 4px;
            border: 1px solid rgba(148,163,184,0.6);
            background-color: var(--bg-code);
            color: var(--code-text);
        }

        /* ===============================
           SETTINGS - Select (dropdown) style
           =============================== */
        #settingsContent select,
        .modal-panel select {
          border: 1px solid rgba(148,163,184,0.6);
          border-radius: 4px;
          background-color: var(--bg-code);
          color: var(--code-text);
          padding: 2px 6px;
        }

        /* 드롭다운 펼쳤을 때 option도 다크로 */
        #settingsContent option,
        .modal-panel option {
          background-color: var(--bg-code);
          color: var(--code-text);
        }

        /* hover/selected 하이라이트를 다크 톤으로 */
        #settingsContent option:hover,
        #settingsContent option:checked,
        .modal-panel option:hover,
        .modal-panel option:checked {
          background-color: rgba(148,163,184,0.18);
        }

        /* 포커스(클릭했을 때) 흰 테두리/링 줄이기 */
        #settingsContent select:focus,
        .modal-panel select:focus {
          outline: none;
          box-shadow: 0 0 0 2px rgba(34,197,94,0.35); /* 기존 그린 톤에 맞춤 */
        }

        .topnav a{
          color: rgba(226,232,240,0.95);
          text-decoration:none;
          font-weight:600;
          font-size:13px;
          opacity:0.9;
        }
        .topnav a:hover{
          opacity:1;
          text-decoration: underline;
        }

        /* ===== Footer Bar (Bottom) ===== */
        #footerBar{
          position: fixed;
          left: 0;
          right: 0;
          bottom: 0;
          height: 32px;
          background: var(--bg-header);
          color: var(--header-text);
          display: flex;
          align-items: center;
          justify-content: space-between;
          padding: 0 12px;
          z-index: 60; /* 모달보다 아래로 두고 싶으면 더 낮춰도 됨 */
          border-top: 1px solid rgba(255,255,255,0.10);
        }

        #footerBar .footer-left{
          font-size: 12px;
          opacity: 0.9;
          white-space: nowrap;
        }

        #footerBar .footer-right{
          display: inline-flex;
          gap: 8px;
          white-space: nowrap;
        }

        #footerBar .footer-link{
          font-size: 12px;
          color: inherit;
          opacity: 0.9;
          text-decoration: none;
          padding: 2px 6px;
          border-radius: 4px;
        }

        #footerBar .footer-link:hover{
          background: rgba(255,255,255,0.10);
          opacity: 1;
        }
                   
    </style>


    <script>
        const API_BASE = "https://mautoflow-backend.onrender.com";
        // ✅ "live" / "test" 중 하나로 고정 (혼선 방지)
        const LEMON_MODE = "live"; // ← 테스트할 땐 "test"

        const LEMON_VARIANT = {
          live: { pro: 1202932, expert: 1202933 },
          test: { pro: 1134483, expert: 1135830 },
        };

        const PRO_CHECKOUT_URL =
          `https://mautoflow-lab.lemonsqueezy.com/checkout/buy/124eae2f-3ed0-4873-9223-135025e83e8e?enabled=${LEMON_VARIANT[LEMON_MODE].pro}`;
        const EXPERT_CHECKOUT_URL =
          `https://mautoflow-lab.lemonsqueezy.com/checkout/buy/c4ea3b6b-6c15-42a9-b857-86cae9f480eb?enabled=${LEMON_VARIANT[LEMON_MODE].expert}`;

        const PAYMENT_ENABLED = true;  // ← Live 전환 시 true

        function openProCheckout() {
          if (!PAYMENT_ENABLED) {
            alert("Upgrade (Coming Soon)\nPayments are currently being enabled.\nUpgrade to Pro or Expert will be available soon.");
            return;
          }

          const user = window.currentUser;
          if (!user) {
            alert("먼저 Google 로그인 후 다시 시도해 주세요.");
            return;
          }

          // ✅ 서버 응답 기반 플랜 우선 사용 (convert_text 응답에서 window.__planTier를 갱신 중)
          const planTier =
            (window.__planTier || window.currentUserPlan || "free").toLowerCase(); // "free" | "pro" | "expert"

          // ✅ free -> pro 결제, pro -> expert 결제, expert면 안내
          if (planTier === "pro") {
            openCheckoutByTier("expert");
            return;
          }

          if (planTier === "expert") {
            alert("You are already on the Expert plan.");
            return;
          }

          // default: free(또는 unknown) -> pro
          openCheckoutByTier("pro");
        }

        function openCheckoutByTier(tier) {
          // tier: "pro" | "expert"
          if (!PAYMENT_ENABLED) {
            alert("Upgrade (Coming Soon)\nPayments are currently being enabled.\nUpgrade to Pro or Expert will be available soon.");
            return;
          }

          const user = window.currentUser;
          if (!user) {
            alert("먼저 Google 로그인 후 다시 시도해 주세요.");
            return;
          }
          console.log("[CHECKOUT USER]", { id: user.id, email: user.email, tier });

          const baseUrl = (tier === "expert") ? EXPERT_CHECKOUT_URL : PRO_CHECKOUT_URL;
          const sep = baseUrl.includes("?") ? "&" : "?";
          const url = `${baseUrl}${sep}checkout[custom][user_id]=${encodeURIComponent(user.id)}`;
          window.location.href = url;
        }

        function getMaxEdgesByPlan() {
          // TODO: 나중에 실제 플랜 변수로 교체
          const plan = window.currentUserPlan || "free"; 
          // 예상 값: "free" | "pro" | "expert"

          switch (plan) {
            case "expert":
              return 20000;   // 노드 1000 대응
            case "pro":
              return 8000;
            case "free":
            default:
              return 2000;
          }
        }


	// mermaid.initialize({ startOnLoad: false });
        mermaid.initialize({
          startOnLoad: false,
          maxTextSize: 2000000,
          maxEdges: getMaxEdgesByPlan(),   // ✅ 플랜 기반
          securityLevel: "loose",
          flowchart: {
            htmlLabels: false,
            useMaxWidth: true
          }
        });


	// 전역 선언 (어디서든 접근 가능)
        let funcNameStyle = "short";
        let macroDefines  = "";      // -D 매크로 문자열 (프론트에서 입력받는 값)
        let macroMode = "all";   // "all" | "defined"
        let downloadFormat = "svg";   // svg | png | pdf (기본 svg)

	// 서버에서 내려준 사용량 / 한도 (없으면 null)
        window.__serverUsageCount = null;
        window.__dailyFreeLimit  = null;

        // 구독/계정 상태
        window.__isProUser      = false;
        window.__planName       = null;
        window.__isTestAccount  = false;
        // "free" | "pro" | "expert" | null(아직 서버 조회 전)
        window.__planTier       = null;
        // 로그인 직후 플랜 정보 가져오는 동안 true
        window.__planLoading    = false;

	let lastCountedSource = "";   // 마지막으로 사용량을 올렸던 소스 코드

        // ✅ 테스트 전용 계정 (무제한) - module에서도 쓰기 위해 전역(window)에 등록
        window.TEST_EMAIL = "exitgiveme@gmail.com";

        // ===== 하루 무료 사용량 설정 =====
        const DAILY_FREE_LIMIT = 5;       // 하루 무료 5회
        const FREE_NODE_LIMIT  = 20;      // Free: 노드 20개까지
        const PRO_NODE_LIMIT   = 200;     // Pro: 노드 200개까지
        const EXPERT_NODE_LIMIT  = 1000;  // Expert: 노드 1000개까지
        const USAGE_KEY        = "autoflow_daily_usage";

        function getTodayKey() {
            // YYYY-MM-DD 형식
            return new Date().toISOString().slice(0, 10);
        }

        function getTodayUsage() {
            const today = getTodayKey();
            let raw = null;
            try {
                raw = localStorage.getItem(USAGE_KEY);
            } catch (e) {
                return { date: today, count: 0 };
            }

            if (!raw) {
                return { date: today, count: 0 };
            }

            try {
                const data = JSON.parse(raw);
                if (!data.date || data.date !== today) {
                    // 날짜가 다르면 새로 시작
                    return { date: today, count: 0 };
                }
                if (typeof data.count !== "number") {
                    return { date: today, count: 0 };
                }
                return { date: today, count: data.count };
            } catch (e) {
                return { date: today, count: 0 };
            }
        }

        function saveTodayUsage(obj) {
            try {
                localStorage.setItem(USAGE_KEY, JSON.stringify(obj));
            } catch (e) {
                // 저장 실패는 그냥 무시
            }
        }
	

const HELP_TEXT_HTML = `
          <h2 style="margin-top:0;">mAutoFlow – Help</h2>

          <p>
            mAutoFlow converts C / pseudo-C functions into a structured flowchart.
            The left side is the source editor and the right side is the diagram viewer.
            Code and nodes are synchronized in both directions.
          </p>

          <h3>1. Basic Concept</h3>
          <ul>
            <li>mAutoFlow focuses on <strong>a single function</strong> at a time.</li>
            <li>When you type or paste C code on the left, mAutoFlow finds a function.</li>
            <li>The body of the selected function is analyzed and rendered as a flowchart on the right.</li>
            <li>
              Use the <strong>HELP</strong> button in the top-right toolbar to switch between
              <strong>Code view</strong> and <strong>Help view</strong>.
              When Help is open, the button label becomes <strong>CODE</strong>; click it again to return to the editor.
            </li>
          </ul>

          <h3>2. Writing / Pasting Code</h3>
          <ul>
            <li>Paste normal C code or pseudo-C code into the editor.</li>
            <li>Function prototypes and global variables are allowed; mAutoFlow focuses on the chosen function body.</li>
            <li>Supported constructs:
              <ul>
                <li><code>if / else if / else</code></li>
                <li><code>for</code>, <code>while</code>, <code>do…while</code></li>
                <li><code>switch / case / default</code></li>
                <li><code>return</code>, <code>break</code>, <code>continue</code></li>
                <li>Simple assignments and expressions (e.g. <code>x++;</code>, <code>flag = true;</code>)</li>
              </ul>
            </li>
            <li>
              Very complex or unusual syntax may not be visualized perfectly,
              but the main control flow should still appear.
            </li>
          </ul>

          <h3>3. Automatic Refresh</h3>
          <ul>
            <li>mAutoFlow watches your typing in the left editor.</li>
            <li>After a short idle delay, the flowchart is automatically regenerated.</li>
            <li>If you do not want to wait, press <strong>“Regenerate Now”</strong> to force an immediate update.</li>
          </ul>

          <h3>4. Code ⇄ Flowchart Synchronization</h3>
          <ul>
            <li><strong>From code to flowchart</strong>:
              <ul>
                <li>Click a line in the editor (or move the caret).</li>
                <li>The best-matching node in the chart is highlighted in red.</li>
                <li>The diagram view automatically scrolls to keep the node visible.</li>
              </ul>
            </li>
            <li><strong>From flowchart to code</strong>:
              <ul>
                <li>Click a node on the diagram.</li>
                <li>The corresponding line in the editor is selected.</li>
                <li>The editor scrolls so the line is centered vertically.</li>
                <li>“start / end / merge” nodes are ignored to avoid meaningless jumps.</li>
              </ul>
            </li>
            <li>A fuzzy matching algorithm is used, so minor formatting differences are tolerated.</li>
          </ul>

          <h3>5. Zooming & Panning the Diagram</h3>
          <ul>
            <li>Use the buttons in the Flowchart header:
              <ul>
                <li><strong>−</strong>: zoom out</li>
                <li><strong>100%</strong>: reset zoom</li>
                <li><strong>+</strong>: zoom in</li>
              </ul>
            </li>
            <li><strong>Ctrl + mouse wheel</strong> over the diagram zooms as well.</li>
            <li><strong>Left-drag</strong> to pan when the chart is larger than the viewport.</li>
            <li>The current zoom level is shown on the right side of the toolbar.</li>
          </ul>

          <h3>6. Typical Workflow</h3>
          <ol>
            <li>Paste a function from your C project into the editor.</li>
            <li>Wait for automatic refresh or click “Regenerate Now”.</li>
            <li>Inspect the resulting flowchart.</li>
            <li>Click nodes to jump directly to code.</li>
            <li>Modify code to simplify logic or conditions.</li>
            <li>Download SVG for documentation or design reviews.</li>
          </ol>

          <h3>7. Example Code Snippet</h3>
          <pre style="background:#111827; color:#e5e7eb; padding:8px; border-radius:4px; font-size:12px; overflow:auto;">
        void main(void)
        {
            int x = 0;

            if (x == 0)
            {
                x++;
            }
            else
            {
                x--;
            }
        }
          </pre>
          <p>
            Paste this sample into the editor and observe how mAutoFlow renders the branches.
            Try modifying conditions or adding loops to see dynamic updates.
          </p>

          <h3>8. Notes &amp; Limitations</h3>
          <ul>
            <li>mAutoFlow focuses on <strong>control flow</strong>, not a full C compiler.</li>
            <li>Complicated macros or vendor-specific extensions may not be shown perfectly.</li>
            <li>If a function body cannot be detected, mAutoFlow displays an error message.</li>
            <li>Extremely long single-line statements may reduce matching accuracy.</li>
          </ul>


		  <h3>9. Upgrade</h3>

		  <p>
		    Some advanced features in mAutoFlow are available only on paid plans.
		    When you attempt to use such a feature, an <strong>UPGRADE</strong> button
		    may appear in the UI.
		  </p>

		  <ul>
		    <li>
		      Upgrading requires login so that your plan can be linked to your account.
		    </li>
		    <li>
		      Typical features that may trigger an upgrade prompt include:
		      <ul>
		        <li>Macro analysis using <strong>Defined</strong> mode</li>
		        <li>Generate <strong>shareable links</strong> for flowcharts</li>
		        <li>Higher node limits for large functions</li>
		      </ul>
		    </li>
		    <li>
		      After upgrading, your plan status is automatically refreshed.
		      In some cases, a page reload or re-login may be required.
		    </li>
		  </ul>


          <h3>10. Sharing (Public Link)</h3>
          <ul>
            <li><strong>Create a share link (login required)</strong>:
              <ul>
                <li>Generate a flowchart first.</li>
                <li>Click <strong>SHARE</strong> → a public URL is generated.</li>
                <li>Copy the link and send it to others.</li>
              </ul>
            </li>
            <li><strong>Open a shared link (no login required)</strong>:
              <ul>
                <li>Anyone with the link can open <code>/share/&lt;share_id&gt;</code>.</li>
                <li>The shared page is <strong>view-only</strong> (diagram only).</li>
                <li>
				  Downloading is disabled on shared pages.
				  Only the original owner can download diagrams.
				</li>
              </ul>
            </li>
            <li><strong>Expiration</strong>:
              <ul>
                <li>There is no limit on the total number of shares, but each link expires automatically after 7 days.</li>
                <li>Can create up to 20 share links per day(based on server time: UTC, resets around 09:00 AM KST).</li>
                <li>If a share is expired or removed, the page will show: <strong>“Expired or removed”</strong>.</li>
                <li>A share link may be removed before expiration by its creator (owner) only.</li>
              </ul>
            </li>
          </ul>

          <h3>11. Downloading the Diagram</h3>
          <ul>
            <li>Click the <strong>DOWNLOAD</strong> button in the top-right toolbar.</li>
            <li>The current flowchart is exported as an <strong>SVG</strong> or <strong>PNG</strong> file.</li>
            <li>File name is based on the current function name (e.g. <code>MyFunction.svg or png</code>).</li>
            <li>For more information, see 12.3 Download Options.</li>
          </ul>

		  <h3>12. Settings</h3>

		  <p>
		    The <strong>SETTINGS</strong> panel allows you to customize how the flowchart is generated
		    and displayed. When SETTINGS is open, the main editor is temporarily hidden.
		  </p>

		  <p>
		    To return to the code editor at any time, click the <strong>CODE</strong> button
		    in the top-right toolbar.
		    (The same CODE button is used to exit both <strong>HELP</strong> and <strong>SETTINGS</strong>.)
		  </p>

		<ul>
		  <h4>12.1 Display Options</h4>
		  <ul>
		    <li>
		      <strong>Theme</strong><br/>
		      Controls the overall visual appearance of the diagram and UI.
		      Available themes include Classic, Light, and Dark.
		      Your selection is saved locally and restored automatically.
		    </li>
		    <li>
		      <strong>Branch Shape</strong><br/>
		      Controls how conditional branches (<code>if</code>, <code>else</code>, <code>switch</code>, <code>while</code>)
		      are drawn in the flowchart.
		      You can choose between rounded rectangles, diamond, hexagon, and parallelogram decision nodes.
		      The diagram is regenerated when this option changes.
		    </li>
		    <li>
		      <strong>Function Name Display</strong><br/>
		      Controls how function names are shown in the diagram.
		      <ul>
		        <li><strong>Short</strong>: compact function names for readability</li>
		        <li><strong>Full</strong>: full function signature for detailed documentation</li>
		      </ul>
		      Changing this option regenerates the diagram.
		    </li>
		  </ul>

		  <h4>12.2 Macro Options</h4>
		  <ul>
		    <li>
		      <strong>Preprocessor Macros (-D)</strong><br/>
		      Allows you to control how conditional compilation paths are analyzed.
		    </li>
		    <li>
		      Macros should be entered using the following format:
		      <br/>
		      <code>DEBUG;TEST=2;FEATURE_X</code>
		    </li>
		    <li>
		      Use semicolons (<code>;</code>) to separate macros.
		      Use equals (<code>=</code>) to assign values.
		    </li>
		    <li>
		      <strong>All</strong>: analyze the code without applying custom macro definitions.
		    </li>
		    <li>
		      <strong>Defined</strong>: analyze the code using the specified macro definitions.
		      This option affects which branches appear in the flowchart.
		    </li>
                    <li>
		      <strong>Note 1:</strong> If Defined is selected and no macros are provided,
                      undefined macros may be evaluated as 0 during preprocessing.
                      This can cause some #if comparison conditions to be interpreted as true.
		    </li>
		    <li>
		      <strong>Note 2:</strong> The <em>Defined</em> macro mode is available only for
		      <strong>Pro</strong> and <strong>Expert</strong> plans.
		      Free users will see an upgrade prompt when attempting to use it.
		    </li>
		  </ul>

		  <h4>12.3 Download Options</h4>
		  <ul>
		    <li>
		      <strong>Format</strong><br/>
		      Currently, diagrams can be downloaded as <strong>SVG</strong> or <strong>PNG</strong>.
		    </li>
		    <li>
		      SVG, or PNG files are vector-based and suitable for documentation, presentations,
		      and high-resolution printing.
		    </li>
		    <li>
		      To create a PDF, first download the diagram as SVG or PNG, then use your browser’s print-to-PDF feature.
		    </li>
		  </ul>
                  <div class="help-subsection">
                    <h4>12.3.1 PNG Options</h4>
                    <ul>
                      <li>
                        <strong>Scale</strong><br>
                        Controls the output resolution of the PNG image. Higher scale values produce clearer images but increase file size.
                      </li>
                      <li>
                        <strong>Background</strong><br>
                        Sets the background color of the exported PNG. Choose White for documents or printing, and Transparent for overlay use.
                      </li>
                    </ul>
                  </div>
                </ul>

          <h3>13. Login, Plans &amp; Usage Limits</h3>
          <ul>
            <li>mAutoFlow uses Google login (Supabase) for authentication.</li>
            <li>Some features require login (for example: Share link creation, server-side limits).</li>
            <li>
              Limits may apply depending on your plan:
              <ul>
                <li><strong>Free</strong>: limited number of diagrams per day + node limit per diagram</li>
                <li><strong>Pro / Expert</strong>: higher node limits or unlimited diagrams</li>
              </ul>
            </li>
            <li>The UI shows your current plan and today’s usage in the top area after login.</li>
          </ul>

          <h3>14. Troubleshooting</h3>
          <ul>
            <li><strong>“Unexpected error” even when Network shows 200</strong>:
              <ul>
                <li>This is usually a <em>response parsing</em> issue or a <em>rendering</em> exception.</li>
                <li>Try regenerating once, or simplify the function temporarily.</li>
              </ul>
            </li>
            <li><strong>Share link loads but shows an error</strong>:
              <ul>
                <li>If HTTP 404: the share is expired or removed.</li>
                <li>If HTTP 500: contact support with the share_id and timestamp.</li>
              </ul>
            </li>
          </ul>

          <h3>15. Upgrade and Cancellation Processing</h3>
          <ul>
            <li>Upgrades are prorated automatically.</li>
            <li>If you upgrade mid-cycle, unused time from your current plan is credited.</li>
            <li>Cancelling a subscription stops future billing but allows access until the end of the current period.</li>
          </ul>

          <h3>16. Pricing Information</h3>
          <ul>
            <li>
              <a href="/app/pricing" class="help-link" onclick="return navigateTo('/app/pricing', event)">
                Open Pricing page
              </a>
            </li>
          </ul>

          <h3>17. Terms of Service</h3>
          <ul>
            <li>
              <a href="/app/terms-of-service" class="help-link" onclick="return navigateTo('/app/terms-of-service', event)">
                Open Terms of Service page
              </a>
            </li>
          </ul>

          <h3>18. Privacy Policy</h3>
          <ul>
            <li>
              <a href="/app/privacy-policy" class="help-link" onclick="return navigateTo('/app/privacy-policy', event)">
                Open Privacy Policy page
              </a>
            </li>
          </ul>
          <h3>Contact &amp; Feedback</h3>
          <p>
            If you find a bug, have a feature request, or need help using mAutoFlow,
            feel free to contact us:
            <br />
            <strong>Email:</strong>
            <a href="mailto:mautoflow.lab@gmail.com" class="help-link">
              mautoflow.lab@gmail.com
            </a>
          </p>
        `;
	
   
        let isHelpMode = false;
        let isSettingsMode = false;   // SETTINGS가 좌측에 뜨는 상태           

        // 현재 로그인 유저 기준 localStorage 키
        function getUsageStorageKey() {
            if (!window.currentUser || !window.currentUser.id) return null;
            return `autoflow-usage-${window.currentUser.id}`;
        }

        function getUsageCount() {
            const key = getUsageStorageKey();
            if (!key) return 0;
            try {
                const raw = localStorage.getItem(key);
                const n = parseInt(raw, 10);
                return Number.isNaN(n) ? 0 : n;
            } catch (e) {
                return 0;
            }
        }

        function setUsageCount(n) {
            const key = getUsageStorageKey();
            if (!key) return;
            try {
                localStorage.setItem(key, String(n));
            } catch (e) {
                // 저장 실패하면 그냥 무시
            }
        }

        function incrementUsageCount() {
            const used = getUsageCount();
            setUsageCount(used + 1);
            updateQuotaInfo();
        }

        function updateQuotaInfo() {
            const span = document.getElementById("quotaInfo");
            if (!span) return;

            // 로그인 안 했으면 표시 X
            if (!window.currentUser) {
                span.textContent = "";
                span.title = "";
                return;
            }

            const email = window.currentUser.email;

            // Test 계정 (exitgiveme)
            if (email === TEST_EMAIL) {
                span.textContent = "Test account: unlimited usage.";
                span.title = "Test account is not subject to any limits.";
                return;
            }

            const tier = window.__planTier;
            const isLoading = !!window.__planLoading && !tier;

            // 플랜 로딩 중: Free 문구 대신 로딩 표시
            if (isLoading) {
                span.textContent = "Loading plan information...";
                span.title       = "Fetching your subscription from Supabase...";
                return;
            }

            // Expert 계정
            if (tier === "expert") {
                span.textContent =
                    `Expert (${window.__planName || "expert"}): unlimited diagrams (≤ ${EXPERT_NODE_LIMIT} nodes).`;
                span.title =
                    `Expert plan active. Up to ${EXPERT_NODE_LIMIT} nodes per diagram.`;
                return;
            }

            // Pro 계정
            if (tier === "pro") {
                span.textContent =
                    `Pro (${window.__planName || "pro"}): unlimited diagrams (≤ ${PRO_NODE_LIMIT} nodes).`;
                span.title =
                    `Pro plan active. Up to ${PRO_NODE_LIMIT} nodes per diagram.`;
                return;
            }

            // Free 계정 (유일하게 일일 제한 존재)
            if (tier === "free") {
                // 아직 서버 usage 정보가 없는 초기 상태라면 기본 문구
                if (window.__serverUsageCount == null || window.__dailyFreeLimit == null) {
                    span.textContent = `Lite plan: 5 diagrams per day, up to ${FREE_NODE_LIMIT} nodes.`;
                    span.title = "Daily limit is enforced on the server.";
                    return;
                }

                // 서버 usage 반영된 상태
                span.textContent = `Today: ${window.__serverUsageCount} / ${window.__dailyFreeLimit} (≤ ${FREE_NODE_LIMIT} nodes).`;
                span.title = "Daily free usage returned from server.";
                return;
            }

            // 혹시 모를 fallback
            span.textContent = "";
            span.title = "";
        }

        // [ADD] UPGRADE 버튼 표시/블링크 단일화
        function applyUpgradeButtonUI(nodeCount, opts = {}) {
          const upgradeBtn = document.getElementById("upgradeButton");
          if (!upgradeBtn) return;

          // ✅ [ADD] 로그인 전이면 UPGRADE 버튼은 절대 노출하지 않음
          const isLoggedIn = !!window.currentUser;
          if (!isLoggedIn) {
            upgradeBtn.style.display = "none";
            upgradeBtn.classList.remove("upgrade-blink");
            return;
          }

          const forceBlink = !!opts.forceBlink;

          // tier 결정은 항상 동일 규칙으로
          const tier = window.__planTier || (window.__isProUser ? "pro" : "free");
          const isTest = !!window.__isTestAccount;

          // ✅ Free/Pro에서는 표시, Expert/Test만 숨김
          const shouldShow = (tier !== "expert") && !isTest;
          upgradeBtn.style.display = shouldShow ? "inline-flex" : "none";

          // blink 초기화
          upgradeBtn.classList.remove("upgrade-blink");

          if (!shouldShow) return;

          if (forceBlink) {
            upgradeBtn.classList.add("upgrade-blink");
            return;
          }

          if (tier === "pro" && typeof nodeCount === "number" && nodeCount >= 200) {
            upgradeBtn.classList.add("upgrade-blink");
          }
        }
                   

        async function refreshPlanFromSupabase() {
            // 아직 로그인 전이면 아무 것도 안 함
            if (!window.supabase || !window.currentUser) return;

            const user  = window.currentUser;
            const email = user.email || "";

            // 테스트 계정은 여기서 별도 처리
            if (email === TEST_EMAIL) {
                window.__planLoading = false;
                window.__planTier    = "free";
                window.__planName    = null;
                window.__isProUser   = false;
                window.__nodeLimit   = Infinity;  // 사실상 무제한
                updateQuotaInfo();
                return;
            }

            // Supabase 조회 시작: Free로 잠깐 보이지 않도록 상태 리셋
            window.__planLoading        = true;
            window.__planTier           = null;
            window.__planName           = null;
            window.__isProUser          = false;
            window.__nodeLimitFromServer = null;
            window.__nodeLimit          = FREE_NODE_LIMIT;
            window.__serverUsageCount   = null;
            window.__dailyFreeLimit     = null;
            updateQuotaInfo();   // → "Loading plan info..." 표시

            try {
                const { data, error } = await supabase
                    .from("subscriptions")
                    .select("plan_tier, plan_name, status")
                    .eq("user_id", user.id)
                    .eq("status", "active")
                    .order("created_at", { ascending: false })
                    .limit(1)
                    .maybeSingle();

                if (error) {
                    console.warn("[UI] failed to load subscription from Supabase:", error);
                    window.__planLoading = false;
                    // 실패 시에는 일단 Free 로 간주
                    if (!window.__planTier) {
                        window.__planTier = "free";
                    }
                    updateQuotaInfo();

                    // ✅ [ADD] “free로 간주” 시점에도 UPGRADE 버튼 표시 복구
                    applyUpgradeButtonUI(window.__nodeCount);
                    
                    return;
                }

                const tier      = (data && data.plan_tier) || "free";
                const planName  = data?.plan_name || null;

                window.__planTier  = tier;                         // "free" | "pro" | "expert" | ...
                window.__planName  = planName;
                window.__isProUser = (tier === "pro" || tier === "expert");

                // 프론트에서 참고용 노드 한도도 같이 넣어 둠
                if (tier === "expert") {
                    window.__nodeLimit = EXPERT_NODE_LIMIT;
                } else if (tier === "pro") {
                    window.__nodeLimit = PRO_NODE_LIMIT;
                } else {
                    window.__nodeLimit = FREE_NODE_LIMIT;
                }

                window.__planLoading = false;

                // 새 플랜 정보 반영해서 상단 문구/대시보드 다시 그리기
                updateQuotaInfo();
                try { updateDashboardUI(); } catch (_) {}

                // ✅ [ADD] 플랜 확정 후 UPGRADE 버튼 표시/블링크 상태도 갱신
                applyUpgradeButtonUI(window.__nodeCount);

            } catch (e) {
                console.error("[UI] refreshPlanFromSupabase error:", e);
                window.__planLoading = false;
                if (!window.__planTier) {
                    window.__planTier = "free";
                }
                updateQuotaInfo();
            }
        }
        
        let currentBranchShape = "rounded";   // 분기 모양: 기본은 둥근 사각형
        let savedSourceCode = "";             // HELP 진입 전 코드 저장용

        function restoreCodeEditor() {
            const codeArea   = document.getElementById("codeArea");
            const codeHeader = document.getElementById("codeHeader");
            const btn        = document.getElementById("helpToggleBtn");

            if (!codeArea || !codeHeader || !btn) return;

            isHelpMode = false;
            isSettingsMode = false;

            btn.textContent = "HELP";
            btn.classList.remove("btn-code-blink");

            let rightText = "Automatic Analysis";
            if (typeof window.__nodeCount === "number" && window.__nodeCount > 0) {
                rightText = `Nodes: ${window.__nodeCount}`;
            }

            codeHeader.innerHTML = `
                <span>mAutoFlow</span>
                <span style="opacity:0.7;">${rightText}</span>
            `;

            // ✅ 초기 상태와 동일하게: lineNumbers + textarea 둘 다 복원
            codeArea.innerHTML = `
                <div id="lineNumbers"></div>
                <textarea id="src" spellcheck="false" placeholder="Paste your C or pseudo-C code here."></textarea>
            `;

            const src = document.getElementById("src");
            const lineNumbers = document.getElementById("lineNumbers");

            if (src) {
                src.value = savedSourceCode || "";

                // 코드 ↔ 노드 연동 이벤트
                ["click", "keyup", "mouseup"].forEach(ev => {
                    src.addEventListener(ev, updateNodeHighlightFromCaret);
                });

                // 자동 플로우차트 갱신
                src.addEventListener("input", function() {
                    if (typingTimer) clearTimeout(typingTimer);
                    typingTimer = setTimeout(function() {
                        generateFlowchart(true);
                    }, TYPING_DELAY_MS);

                    // 라인 번호도 같이 갱신
                    if (lineNumbers) updateLineNumbersLocal();
                });
            }

            // 🔹 라인 번호 갱신용 작은 함수 (restore 전용)
            function updateLineNumbersLocal() {
                if (!src || !lineNumbers) return;
                const lines = src.value.split("\n").length || 1;
                let html = "";
                for (let i = 1; i <= lines; i++) {
                    html += i + "<br>";
                }
                lineNumbers.innerHTML = html;
            }

            // 스크롤 동기화
            if (src && lineNumbers) {
                src.addEventListener("scroll", () => {
                    lineNumbers.scrollTop = src.scrollTop;
                });

                // 초기 한 번 출력
                updateLineNumbersLocal();
            }
        }


        function toggleHelp() {
            const codeArea   = document.getElementById("codeArea");
            const codeHeader = document.getElementById("codeHeader");
            const btn        = document.getElementById("helpToggleBtn");

            if (!codeArea || !codeHeader || !btn) return;

            // 🔹 현재 CODE 상태 → HELP 진입 (SETTINGS 모드도 아님)
            if (!isHelpMode && !isSettingsMode) {
                // 현재 코드 저장
                const srcNow = document.getElementById("src");
                if (srcNow) {
                    savedSourceCode = srcNow.value;
                } else {
                    savedSourceCode = "";
                }

                isHelpMode = true;
                isSettingsMode = false;

                btn.textContent = "CODE";
                btn.classList.add("btn-code-blink");   // CODE 깜빡임 ON

                codeHeader.innerHTML = "<span>HELP</span>";
                codeArea.innerHTML = `
                    <div id="helpContent"
                         style="
                            flex: 1;
                            padding: 10px;
                            color: var(--code-text);
                            font-size: 13px;
                            overflow-y: auto;
                        ">
                        ${HELP_TEXT_HTML}
                    </div>
                `;
            }
            // HELP 모드이거나 SETTINGS 모드일 때 → CODE로 복귀
            else {
                restoreCodeEditor();
            }
        }

        // ============================
        //  Theme 관리
        // ============================
        let currentTheme = "classic"; // 기본
        
        function applyTheme(theme) {
            currentTheme = theme;

            // classic 은 data-theme 제거 (기본 색 사용)
            if (theme === "classic") {
                document.body.removeAttribute("data-theme");
            } else {
                document.body.setAttribute("data-theme", theme);
            }

            // 로컬 스토리지에 저장
            try {
                localStorage.setItem("autoflow-theme", theme);
            } catch (e) {
                // storage 못쓸 때는 그냥 무시
            }
        }

        // SETTINGS를 HELP처럼 좌측 코드 영역에 띄우는 버전
        function openSettings() {
            const codeArea   = document.getElementById("codeArea");
            const codeHeader = document.getElementById("codeHeader");
            const btn        = document.getElementById("helpToggleBtn");

            if (!codeArea || !codeHeader || !btn) return;

            // 이미 SETTINGS 모드면 다시 눌러도 그냥 무시
            if (isSettingsMode) return;

            // 현재 코드 저장 (HELP와 동일 로직)
            const srcNow = document.getElementById("src");
            if (srcNow) {
                savedSourceCode = srcNow.value;
            } else if (!savedSourceCode) {
                savedSourceCode = "";
            }

            isHelpMode = false;
            isSettingsMode = true;

            // HELP 버튼을 CODE 모드로 전환 + 깜빡임
            btn.textContent = "CODE";
            btn.classList.add("btn-code-blink");

            // 헤더 타이틀을 SETTINGS로 변경
            codeHeader.innerHTML = "<span>SETTINGS</span>";

            // 기존 SETTINGS 모달 안의 패널 내용을 템플릿으로 활용
            const overlay = document.getElementById("settingsOverlay");
            if (overlay) overlay.classList.add("modal-hidden");
            
            const panel   = overlay ? overlay.querySelector(".modal-panel") : null;
            if (!panel) {
                // 혹시 못 찾으면 에러 문구만 표시
                codeArea.innerHTML = `
                    <div style="padding:10px; color:var(--code-text); font-size:13px;">
                        SETTINGS panel not found.
                    </div>
                `;
                return;
            }

            // panel.innerHTML을 그대로 쓰지 말고, 복제 후 “불필요한 상단 타이틀/헤더(또는 중복 요소)”를 제거한다.
            const panelClone = panel.cloneNode(true);

            // (1) 혹시 예전 코드가 남아 modal-header가 존재하면 제거 (중복 SETTINGS 원인 1순위)
            const header = panelClone.querySelector(".modal-header");
            if (header) header.remove();

            // (2) panelClone 자체는 .modal-panel이므로 내부만 꺼내서 사용
            const panelHTML = panelClone.innerHTML;

            // 좌측 코드 영역에 SETTINGS UI 렌더링
            codeArea.innerHTML = `
              <div id="settingsContent"
                   style="
                     flex: 1;              /* ✅ 이게 핵심: 좌측 창 전체 폭/높이 사용 */
                     min-width: 0;         /* ✅ flex 자식 overflow 방지(가로 스크롤바 원인 제거) */
                     width: 100%;
                     padding: 10px;        /* HELP처럼 적당히 여백 (원하면 0으로) */
                     color: var(--code-text);
                     font-size: 13px;
                     overflow-y: auto;
                     overflow-x: hidden;   /* ✅ 가로 스크롤 제거(필요시) */
                   ">
                ${panelHTML}
              </div>
            `;


            // 새로 생긴 SETTINGS DOM 기준으로 라디오 초기화/이벤트 연결
            const settingsRoot = document.getElementById("settingsContent");
            initSettingsRadios(settingsRoot);
        }

        async function openShare() {
          if (getShareIdFromPath()) {
            setStatus("info", "This is a read-only shared page.");
            return;
          }  
            
          // 로그인한 사용자만
          if (!window.currentUser) {
            alert("Please log in to use SHARE.\n(SHARE is available on Pro/Expert.)");
            return;
          }

          // ✅ Free(Lite) 차단: SHARE는 Pro/Expert만
          {
            const tier = window.__planTier || (window.__isProUser ? "pro" : "free");
            const isFree = (tier === "free") && !window.__isTestAccount;
            if (isFree) {
              showShareUpgradePrompt();
              return;
            }
          }
          

          const overlay = document.getElementById("shareOverlay");
          const input = document.getElementById("shareLinkInput");
          const hint  = document.getElementById("shareHint");

          if (!overlay || !input) return;

          overlay.classList.remove("modal-hidden");
          input.value = "";
          if (hint) hint.textContent = "Generating a share link...";

          // ✅ 1) 마지막 생성된 mermaid code 확보
          const mermaid_code = (window.__lastMermaidCode || "").trim();
          if (!mermaid_code) {
            if (hint) hint.textContent = "There is no flowchart to share yet. Please generate one first.";
            return;
          }

          // ✅ 2) access_token 확보
          let accessToken = null;
          try {
            const session = supabase.auth.getSession
              ? (await supabase.auth.getSession()).data.session
              : null;
            if (session?.access_token) accessToken = session.access_token;
          } catch (e) {}

          if (!accessToken) {
            if (hint) hint.textContent = "Your login session has expired. Please log in again.";
            return;
          }

          // ✅ 3) 백엔드에 share 생성 요청 (FormData로!)
          try {
            const formData = new FormData();
            formData.append("mermaid_code", mermaid_code);
            formData.append("access_token", accessToken);

            const res = await fetch(`${API_BASE}/api/share/create`, {
              method: "POST",
              body: formData,
            });

            if (!res.ok) {
              let detail = "";
              try { detail = JSON.stringify(await res.json()); } catch(_) {}
              if (hint) hint.textContent = `Failed to create share link (HTTP ${res.status}). ${detail}`;
              return;
            }

            const data = await res.json();
            const share_id = data.share_id;

            if (!share_id) {
              if (hint) hint.textContent = "Failed to create share link due to an unexpected error.";
              return;
            }

            // ✅ 4) 최종 링크 구성 (네가 원하는 형식)
            const url = `${window.location.origin}/share/${share_id}`;
            window.__lastShareId = share_id;

            input.value = url;
            if (hint) hint.textContent = "";
          } catch (e) {
            if (hint) hint.textContent = `Unexpected error: ${e?.message || e}`;
          }
        }

        function closeShare() {
          const overlay = document.getElementById("shareOverlay");
          if (overlay) overlay.classList.add("modal-hidden");
        }

        function copyShareLink() {
          const input = document.getElementById("shareLinkInput");
          const hint  = document.getElementById("shareHint");
          if (!input || !input.value) return;

          navigator.clipboard.writeText(input.value)
            .then(() => { if (hint) hint.textContent = "Link copied."; })
            .catch(() => { if (hint) hint.textContent = "Failed to copy the link. Please copy it manually."; });
        }
                   

        // ============================
        //  SHARE 페이지 로딩(/share/<id>)
        // ============================

        function getShareIdFromPath() {
          // 예: /share/4e9203e9-0602-42d4-9016-b1b9a8a04ecc
          const m = window.location.pathname.match(/^\/share\/([0-9a-fA-F-]{36})\/?$/);
          return m ? m[1] : null;
        }

        async function renderSharedMermaid(mermaidCode) {
          const chartInner = document.getElementById("chartInner");
          if (!chartInner) return;

          chartInner.innerHTML = `<div class="mermaid">${mermaidCode}</div>`;

          try {
            // ✅ 먼저 문법/구조 검증 (여기서 걸리면 init 하지 않음)
            await mermaid.parse(mermaidCode);

            // ✅ 검증 통과 시에만 렌더
            await mermaid.init(undefined, chartInner.querySelector(".mermaid"));
          } catch (e) {
            console.error("Mermaid render failed:", e);
            chartInner.innerHTML = `
              <p class="placeholder" style="color:#b91c1c;">
                Mermaid render failed: ${e?.message || e}
              </p>`;
            return;
          }


          // 기존 코드에 있는 확대/클릭핸들러도 그대로 재사용
          try { applyDiagramZoom(); } catch(e) {}
          try { setTimeout(attachNodeClickHandlers, 50); } catch(e) {}

          // ✅ 공유 페이지는 무조건 100%로 시작(자동맞춤 X)
          setTimeout(() => {
            try { zoomReset(); } catch(_) {}
          }, 80);
        }

        function applyShareViewMode() {
          const hide = (sel) => {
            const el = document.querySelector(sel);
            if (el) el.style.display = "none";
          };

          hide("#loggedOutButtons");
          hide("#loggedInButtons");
          hide('button[onclick="openShare()"]');
          hide('button[onclick="downloadDiagram()"]');
          hide('button[onclick="openSettings()"]');
          hide("#helpToggleBtn");
          hide('button[onclick="openProCheckout()"]');
          hide("#footerBar");

          const regenBtn = document.querySelector('#toolbar button[onclick^="generateFlowchart"]');
          if (regenBtn) regenBtn.style.display = "none";

          const subtitle = document.querySelector("header .subtitle");
          if (subtitle) subtitle.style.display = "none";

          const header = document.querySelector("header");
          if (header) header.style.padding = "6px 12px";

          const h1 = document.querySelector("header h1");
          if (h1) h1.style.fontSize = "18px";

          // ✅ 여기서만 한 번씩 선언
          const src = document.getElementById("src");
          if (src) src.disabled = true;

          const leftPane = document.getElementById("leftPane");
          if (leftPane) leftPane.style.display = "none";

          const divider = document.getElementById("divider");
          if (divider) divider.style.display = "none";

          const rightPane = document.getElementById("rightPane");
          if (rightPane) {
            rightPane.style.flex = "1 1 100%";
            rightPane.style.minWidth = "0";
            rightPane.style.width = "100%";
            rightPane.style.padding = "6px";
          }

          const chartInner = document.getElementById("chartInner");
          if (chartInner) chartInner.style.margin = "0";
        }


        // (navigateTo 위쪽 아무데나 - 전역)
        let __returnToEditorPath = "/app/";

        function normalizePath(p) {
          // trailing slash 제거
          p = (p || "/").replace(/\/+$/, "") || "/";
          // /app prefix가 있으면 제거해서 내부 라우팅 키만 남김
          if (p.startsWith("/app/")) return p.slice(4); // "/pricing" 같은 형태로
          return p;
        }

        function isLegalPath(pathname) {
          const p = normalizePath(pathname);
          return (
            p === "/pricing" ||
            p === "/terms-of-service" ||
            p === "/privacy-policy" ||
            p === "/terms" ||
            p === "/privacy"
          );
        }

        function getLegalPath() {
          const p = normalizePath(window.location.pathname);
          if (p === "/pricing") return "pricing";
          if (p === "/terms-of-service") return "terms";
          if (p === "/privacy-policy") return "privacy";
          return null;
        }
                // 
        function navigateTo(path, e) {
          if (e) e.preventDefault();

          // ✅ "편집 화면(legal 아닌 상태)"에서 "legal로 들어갈 때만" 복귀 URL 저장
          const curPath = window.location.pathname;
          if (!isLegalPath(curPath) && isLegalPath(path)) {
            __returnToEditorPath = window.location.pathname + window.location.search + window.location.hash;
          }

          history.pushState({}, "", path);
          handleRoute();
        }


        window.addEventListener("popstate", handleRoute);

        function applyLegalViewMode() {
          // ✅ 공유페이지에서 쓰던 hide 패턴 그대로 재사용 (applyShareViewMode 참고) :contentReference[oaicite:7]{index=7}
          const hide = (sel) => {
            const el = document.querySelector(sel);
            if (el) el.style.display = "none";
          };

          // 앱 기능 버튼 숨김(요구사항 3)
          hide('button[onclick="openShare()"]');
          hide('button[onclick="downloadDiagram()"]');
          hide('button[onclick="openSettings()"]');
          hide('button[onclick="toggleHelp()"]');      // helpToggleBtn
          hide("#helpToggleBtn");
          hide('button[onclick="openProCheckout()"]'); // upgrade
          const editBtn = document.getElementById("editButton");
          if (editBtn) {
            editBtn.style.display = "";              // 혹시 inline style로 막혀있으면 해제
            editBtn.classList.add("btn-code-blink"); // CODE와 동일 효과
          }

          // regenerate/toolbar도 숨기면 “문서 페이지” 느낌이 깔끔함
          const toolbar = document.getElementById("toolbar");
          if (toolbar) toolbar.style.display = "none";

          // ✅ Flowchart 라벨 + 줌 컨트롤 숨기기
          const paneHeader = document.querySelector("#rightPane .pane-header");
          if (paneHeader) paneHeader.style.display = "none";

          // ✅ legal 진입 시: pending debounce 제거 + legal 모드 플래그 ON
          window.__isLegalMode = true;
          if (typeof typingTimer !== "undefined" && typingTimer) {
            clearTimeout(typingTimer);
            typingTimer = null;
          }  

          // 좌측 편집기/디바이더 숨겨서 문서에 집중
          const src = document.getElementById("src");
          if (src) src.disabled = true;

          const leftPane = document.getElementById("leftPane");
          if (leftPane) leftPane.style.display = "none";

          const divider = document.getElementById("divider");
          if (divider) divider.style.display = "none";

          const rightPane = document.getElementById("rightPane");
          if (rightPane) {
            rightPane.style.flex = "1 1 100%";
            rightPane.style.minWidth = "0";
            rightPane.style.width = "100%";
            rightPane.style.padding = "10px";
          }
        }

        function restoreAppViewMode() {
          // 숨겼던 것들 다시 보이기
          const show = (sel) => {
            const el = document.querySelector(sel);
            if (el) el.style.display = "";
          };

          // 앱 기능 버튼들 원복
          show('button[onclick="openShare()"]');
          show('button[onclick="downloadDiagram()"]');
          show('button[onclick="openSettings()"]');
          show('button[onclick="toggleHelp()"]');
          show("#helpToggleBtn");
          show("#footerBar");

          // ✅ UPGRADE 버튼은 여기서 직접 show 하지 않음
          applyUpgradeButtonUI(window.__nodeCount);

          // ✅ legal에서 숨겼던 Flowchart 라벨 + 줌 컨트롤 복구
          const paneHeader = document.querySelector("#rightPane .pane-header");
          if (paneHeader) paneHeader.style.display = "";

          // toolbar/좌측/디바이더 원복
          const toolbar = document.getElementById("toolbar");
          if (toolbar) toolbar.style.display = "";

          const leftPane = document.getElementById("leftPane");
          if (leftPane) leftPane.style.display = "";

          const divider = document.getElementById("divider");
          if (divider) divider.style.display = "";

          const src = document.getElementById("src");
          if (src) src.disabled = false;

          const rightPane = document.getElementById("rightPane");
          if (rightPane) {
            rightPane.style.flex = "";
            rightPane.style.minWidth = "";
            rightPane.style.width = "";
            rightPane.style.padding = "";
          }

          const chartInner = document.getElementById("chartInner");
          if (chartInner) chartInner.style.margin = "";

          // ✅ editor 복귀 시: legal 모드 OFF
          window.__isLegalMode = false;

          // ✅ EDIT 버튼은 편집 화면에선 숨김
          const editBtn = document.getElementById("editButton");
          if (editBtn) {
            editBtn.classList.remove("btn-code-blink");
            editBtn.style.display = "none";
          }
        }

        function goBackToEditor() {
          const target = (__returnToEditorPath && !isLegalPath(__returnToEditorPath))
            ? __returnToEditorPath
            : "/app/";

          navigateTo(target, null);
        }
        

        const PRICING_HTML = `
        <div class="legal-doc pricing-doc">
          <style>
            .legal-doc{ font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
            .legal-doc .container{ max-width: 920px; margin: 0 auto; padding: 24px 20px 30px; text-align: left; }
            .legal-doc h1{ font-size: 36px; margin: 6px 0 6px; text-align:left; }
            .legal-doc .sub{ text-align:left; color:#6b7280; margin: 0 0 18px; }
            .legal-doc .grid{ display:flex; flex-direction:column; gap: 16px; margin-top: 18px; }

            .legal-doc .plan{
              border: 1px solid #d1d5db; border-radius: 14px; overflow: hidden; background: #fff;
              cursor: pointer;
            }
            .legal-doc .plan.selected{ border: 2px solid #7c3aed; box-shadow: 0 0 0 3px rgba(124,58,237,0.10); }

            .legal-doc .plan:hover{
              box-shadow: 0 0 0 3px rgba(124,58,237,0.06);
            }
            .legal-doc .plan-header{ display:flex; align-items:center; justify-content:space-between; padding: 14px 16px; border-bottom: 1px solid #e5e7eb; }
            .legal-doc .left{ display:flex; align-items:center; gap: 12px; }
            .legal-doc .radio{ width: 18px; height: 18px; border-radius: 50%; border: 2px solid #9ca3af; position: relative; }
            .legal-doc .plan.selected .radio{ border-color:#7c3aed; }
            .legal-doc .plan.selected .radio::after{
              content:""; width: 8px; height: 8px; border-radius: 50%;
              background:#7c3aed; position:absolute; left:50%; top:50%;
              transform: translate(-50%,-50%);
            }

            .legal-doc .title{ font-size: 20px; font-weight: 700; }
            .legal-doc .price{ font-size: 20px; font-weight: 800; }

            .legal-doc .badge{
              display:inline-block;
              margin-left: 10px;
              padding: 3px 8px;
              border-radius: 999px;
              font-size: 12px;
              font-weight: 700;
              line-height: 1;
              vertical-align: middle;
            }
            .legal-doc .badge-reco{
              background: rgba(124,58,237,0.12);
              color: #7c3aed;
              border: 1px solid rgba(124,58,237,0.35);
            }

            .legal-doc .plan-body{ padding: 14px 16px 18px; }
            .legal-doc .bill{ color:#6b7280; font-size: 14px; margin-bottom: 10px; }
            .legal-doc .desc{ margin-bottom: 12px; line-height: 1.6; }
            .legal-doc ul{ margin-left: 18px; line-height: 1.7; }

            .legal-doc .footbox{
              margin-top: 18px; border: 1px solid #e5e7eb;
              border-radius: 12px; padding: 14px 16px;
              background: #fafafa; font-size: 13px; color:#374151;
            }
          </style>

          <div class="container">
            <h1>Pricing</h1>
            <p class="sub">Choose the plan that fits your needs. Monthly subscription only.</p>

            <div class="grid">
              <section class="plan selected" data-plan="lite">
                <div class="plan-header">
                  <div class="left">
                    <div class="radio"></div>
                    <div class="title">Lite</div>
                  </div>
                  <div class="price">US$0.00</div>
                </div>
                <div class="plan-body">
                  <p class="bill">Billed monthly: US$0.00</p>
                  <p class="desc"><b>mAutoFlow Lite</b> provides basic flowchart generation features.</p>
                  <ul>
                    <li>Up to <b>5</b> flowcharts per day</li>
                    <li>Up to <b>20</b> nodes per flowchart</li>
                    <li>Basic support</li>
                  </ul>
                </div>
              </section>

              <section class="plan" data-plan="pro">
                <div class="plan-header">
                  <div class="left">
                    <div class="radio"></div>
                    <div class="title">
                      Pro <span class="badge badge-reco">Recommended</span>
                    </div>          
                  </div>
                  <div class="price">US$9.99</div>
                </div>
                <div class="plan-body">
                  <p class="bill">Billed monthly: US$9.99</p>
                  <p class="desc"><b>mAutoFlow Pro</b> unlocks advanced flowchart creation.</p>
                  <ul>
                    <li>Unlimited flowchart generation</li>
                    <li>Up to <b>200</b> nodes per flowchart</li>
                    <li>Provides download function in PNG and SVG formats</li>
                    <li>Generate shareable links for flowcharts</li>
                    <li>Macro-based process definitions</li>
                    <li>Advanced support</li>
                  </ul>
                </div>
              </section>

              <section class="plan" data-plan="expert">
                <div class="plan-header">
                  <div class="left">
                    <div class="radio"></div>
                    <div class="title">Expert</div>
                  </div>
                  <div class="price">US$15.00</div>
                </div>
                <div class="plan-body">
                  <p class="bill">Billed monthly: US$15.00</p>
                  <p class="desc"><b>mAutoFlow Expert</b> supports large-scale and complex diagrams.</p>
                  <ul>
                    <li>Unlimited flowchart generation</li>
                    <li>Up to <b>1,000</b> nodes per flowchart</li>
                    <li>Provides download function in PNG and SVG formats</li>
                    <li>Generate shareable links for flowcharts</li>
                    <li>Macro-based process definitions</li>
                    <li>Advanced support</li>
                  </ul>
                </div>
              </section>
            </div>

            <div class="footbox">
              • All paid plans are billed monthly via <b>Lemon Squeezy</b>.<br/>
              • Subscriptions renew automatically until canceled.<br/>
              • Refunds may be limited due to the nature of digital services.<br/>
              • Lite plan may be used for personal or non-commercial purposes.                
            </div>
          </div>
        </div>
        `;

        const TERMS_HTML = `
        <div class="legal-doc terms-doc">
          <style>
            .legal-doc{ font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
            .legal-doc .container{
              max-width: 920px;
              margin: 0 auto;
              padding: 24px 20px 30px;
              text-align: left;   /* ✅ 추가: 상위 text-align:center 상속 차단 */
            }
            .legal-doc h1{ font-size: 34px; margin: 6px 0 10px; text-align:left; }
            .legal-doc .meta{ text-align:left; color: var(--toolbar-muted); font-size: 13px; margin-bottom: 18px; }
            .legal-doc h2{ font-size: 18px; margin: 22px 0 10px; text-align:left; }
            .legal-doc { color: var(--toolbar-text); }
            .legal-doc p, .legal-doc li{ line-height: 1.75; color: var(--toolbar-text); text-align:left; }
            .legal-doc ul{ margin: 8px 0 0 20px; }
            .legal-doc .box{
              margin-top: 14px;
              border: 1px solid rgba(255,255,255,0.12);
              border-radius: 12px;
              padding: 12px 14px;
              background: rgba(255,255,255,0.06);
              color: var(--toolbar-text);
              font-size: 13px;
              line-height: 1.65;
              text-align:left;
            }
            .legal-doc .muted{ color: var(--toolbar-muted); }
          </style>

          <div class="container">
            <h1>Terms of Service</h1>
            <div class="meta">
              mAutoFlow · Monthly Subscription · Payments processed via Lemon Squeezy<br/>
              <span class="date">Last updated: January 08, 2026</span>
            </div>

            <div class="box">
              <b>Summary</b><br/>
              • mAutoFlow analyzes user-submitted code or text and provides automatically generated visual flowcharts.<br/>
              • Paid plans are billed monthly. Payment processing is handled by Lemon Squeezy.<br/>
              • Submitted code is processed only to provide the service (analysis/flowchart generation) and is not used for training.
            </div>

            <h2>1. Service Description</h2>
            <p>mAutoFlow provides an automated tool that analyzes user-submitted code or text and generates visual flowcharts for reference purposes. Outputs are provided “as is” for visualization purposes, and you are responsible for reviewing and validating results.</p>
            <p>
            The service does not provide professional, legal, or technical advice.
            All outputs are generated automatically and are provided for informational
            and visualization purposes only.
            </p>

            <h2>2. Accounts and Acceptable Use</h2>
            <ul>
              <li>You are responsible for maintaining the security of your account and access credentials.</li>
              <li>You must not misuse the service or attempt to bypass limitations (e.g., automation abuse, scraping, denial-of-service behavior, or circumvention).</li>
              <li>We may restrict or suspend access if we detect abnormal usage or policy violations.</li>
            </ul>

            <h2>3. Subscriptions, Billing, and Auto-Renewal</h2>
            <ul>
              <li>Paid plans are billed on a <b>monthly subscription</b> basis.</li>
              <li>Payments and subscription management are processed by <b>Lemon Squeezy</b>. Payment method details are handled by the payment provider.</li>
              <li>Subscriptions <b>renew automatically</b> unless canceled prior to the renewal date.</li>
              <li>Taxes (such as VAT) may be displayed during checkout depending on your location and applicable rules.</li>
            </ul>
            <p>
            Payments and subscription management are handled by Lemon Squeezy.
            Refunds, cancellations, and billing issues are subject to Lemon Squeezy’s
            terms and policies.
            </p>                   

            <h2>4. Cancellation and Refunds</h2>
            <ul>
              <li>You may cancel your subscription at any time. After cancellation, you may continue using the service until the end of the current billing period.</li>
              <li>Subscriptions can be canceled at any time through the Lemon Squeezy customer portal.</li>
              <li>Refunds are generally not provided due to the digital nature of the service.</li>
              <li>However, refunds may be granted at our sole discretion in cases of billing errors or service malfunction.</li>                 
            </ul>

            <h2>5. User Content (Submitted Code/Text)</h2>
            <ul>
              <li>You retain ownership of the code/text you submit.</li>
              <li>Your input is processed only for generating flowcharts and providing the service.</li>
              <li>Your code is <b>not used for training</b> machine learning models.</li>
            </ul>

            <h2>6. Disclaimer</h2>
            <p>The service is provided “as is” without warranties of any kind. mAutoFlow does not guarantee the accuracy, completeness, or suitability of generated outputs. To the maximum extent permitted by law, liability is limited.</p>
            <p>
            Users are solely responsible for how they use the generated outputs.
            mAutoFlow is not responsible for decisions or actions taken based on the outputs.
            </p>
            
            <h2>7. Limitation of Liability</h2>
            <p>
            To the maximum extent permitted by applicable law, mAutoFlow shall not be liable
            for any indirect, incidental, special, consequential, or punitive damages,
            including but not limited to loss of data, loss of profits, or business interruption,
            arising out of or related to the use of the service.
            </p>

            <h2>8. Service Availability and Changes</h2>
            <p>
            We reserve the right to modify, suspend, or discontinue any part of the service
            at any time, with or without prior notice.
            </p>

            <h2>9. Governing Law</h2>
            <p>
            These terms shall be governed by and construed in accordance with applicable laws,
            without regard to conflict of law principles.
            </p>

            <h2>10. Contact Information</h2>
            <p>mAutoFlow is operated by an independent developer based in South Korea.</p>
            <p>
            If you have any questions about these Terms or billing issues, please contact us at: <b>mautoflow.lab@gmail.com</b>
            </p>
                               
            <p class="muted" style="margin-top:22px;">※ These terms may be updated as the service or legal requirements change.</p>
          </div>
        </div>
        `;

        const PRIVACY_HTML = `
        <div class="legal-doc privacy-doc">
          <style>
            .legal-doc{ font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
            .legal-doc .container{
              max-width: 980px;
              margin: 0 auto;
              padding: 24px 20px 30px;
              text-align: left;   /* ✅ 추가 */
            }
            .legal-doc h1{ font-size: 34px; margin: 6px 0 10px; text-align:left; }
            .legal-doc .meta{ text-align:left; color:#6b7280; font-size: 13px; margin-bottom: 18px; }
            .legal-doc h2{ font-size: 18px; margin: 22px 0 10px; text-align:left; }
            .legal-doc p, .legal-doc li{ line-height: 1.75; color:#111827; text-align:left; }
            .legal-doc ul{ margin: 8px 0 0 20px; }
            .legal-doc .box{ margin-top: 14px; border: 1px solid #e5e7eb; border-radius: 12px; padding: 12px 14px; background: #fafafa; color:#374151; font-size: 13px; line-height: 1.65; text-align:left; }
            .legal-doc table{ width:100%; border-collapse: collapse; margin-top: 10px; font-size: 13px; }
            .legal-doc th, .legal-doc td{ border: 1px solid rgba(255,255,255,0.12); padding: 10px; vertical-align: top; line-height: 1.55; }
            .legal-doc th{
              background: rgba(255,255,255,0.06);
              text-align:left;
              font-weight:700;
              width: 20%;
            }
            .legal-doc .muted{ color:#6b7280; }
          </style>

          <div class="container">
            <h1>Privacy Policy</h1>
            <div class="meta">
              mAutoFlow · Supabase · Lemon Squeezy<br/>
              This Privacy Policy is designed in accordance with the Personal Information Protection Act (PIPA) of the Republic of Korea.<br/>                 
              <span class="date">Effective date: January 08, 2026</span>
            </div>

            <div class="box">
              <b>Key Summary</b><br/>
              • Payments are processed by Lemon Squeezy. We do <b>not</b> store full payment method details (e.g., card numbers).<br/>
              • Submitted code is processed solely to generate flowcharts and provide the service, and is <b>not</b> used for training.
            </div>

            <h2>1. Information We Collect</h2>
            <ul>
              <li>Email address (account identification)</li>
              <li>Subscription status and billing identifiers (we do not store full payment method details)</li>
              <li>Usage data and access logs (for security, reliability, and enforcing limits)</li>
            </ul>

            <h2>2. How We Use Information</h2>
            <ul>
              <li>Provide authentication and account services</li>
              <li>Manage subscriptions and service limits</li>
              <li>Improve service stability, prevent abuse, and enhance security</li>
              <li>Respond to inquiries and provide customer support</li>
            </ul>
            <p>
            We process personal data based on contractual necessity (to provide the service)
            and legitimate interests related to service operation, security, and billing.
            </p>

            <h2>3. Code Processing Policy</h2>
            <p>Submitted code/text is processed only to generate flowcharts and provide the service. We do not use submitted code for training machine learning models.</p>

            <h2>4. Third-Party Services and International Transfers</h2>
            <p>
            Subscription payments, cancellations, and refunds are processed by Lemon Squeezy.
            mAutoFlow does not store payment method details and does not directly handle refunds.
            </p>                   
            <p class="muted">To operate the service, some personal data may be processed by third-party providers. Depending on your location, this may involve international data transfers.</p>
            <p>
            mAutoFlow does not use advertising cookies or third-party tracking technologies
            for marketing or profiling purposes.
            </p>

            <table>
              <tr><th>Service</th><td><b>Supabase</b></td></tr>
              <tr><th>Purpose</th><td>Authentication and database (account/subscription status, minimal usage logs)</td></tr>
              <tr><th>Data</th><td>Email, account metadata, subscription status, minimal access/usage logs</td></tr>
              <tr><th>Location</th><td>Overseas (e.g., United States or other regions depending on infrastructure)</td></tr>
            </table>

            <table>
              <tr><th>Service</th><td><b>Lemon Squeezy</b></td></tr>
              <tr><th>Purpose</th><td>Payment and subscription processing</td></tr>
              <tr><th>Data</th><td>Email, subscription/payment identifiers (payment method details handled by the payment provider)</td></tr>
              <tr><th>Location</th><td>Overseas (e.g., United States or other regions depending on infrastructure)</td></tr>
            </table>

            <p class="muted" style="margin-top:10px;">※ If you do not agree to necessary processing or transfers, subscription/billing features may not be available.</p>

            <h2>5. Data Retention</h2>
            <ul>
              <li>We retain personal data only as long as necessary to provide the service or comply with legal obligations.</li>
              <li>When data is no longer needed, we delete or anonymize it, unless retention is required by law.</li>
              <li>We implement reasonable technical and organizational measures to protect personal data against unauthorized access, loss, or misuse.</li>
            </ul>

            <h2>6. Your Rights</h2>
            <ul>
              <li>You may request access, correction, deletion, or restriction of processing of your personal data.</li>
              <li>For the purposes of applicable data protection laws, mAutoFlow acts as the data controller.</li>
              <li>To exercise your rights, contact: <b>mautoflow.lab@gmail.com</b></li>
            </ul>
            <p>
            If you are located in the European Union, you have the right to request access to,
            rectification of, restriction of processing of, or deletion of your personal data,
            in accordance with applicable data protection laws.
            </p>

            <h2>7. Children's Privacy</h2>
            <p>The service is not intended for children under the age of 13. We do not knowingly collect personal data from children.
            </p>                   

            <h2>8. Contact</h2>
            <p>mAutoFlow is operated by an independent developer based in South Korea.</p>
            <p>For privacy-related inquiries, contact: <b>mautoflow.lab@gmail.com</b></p>

            <p class="muted" style="margin-top:22px;">※ This policy may be updated due to service or legal changes.</p>
          </div>
        </div>
        `;

        function renderLegalDoc(kind) {
          const chartInner = document.getElementById("chartInner");
          if (!chartInner) return;

          let html = "";
          if (kind === "pricing") html = PRICING_HTML;
          else if (kind === "terms") html = TERMS_HTML;
          else if (kind === "privacy") html = PRIVACY_HTML;

          chartInner.innerHTML = html;

          // 🔹 PRICING일 때만 선택 로직 연결
          if (kind === "pricing") initPricingPlanSelection();
        }

        function initPricingPlanSelection() {
          const pricing = document.querySelector(".pricing-doc");
          if (!pricing) return;

          const plans = pricing.querySelectorAll(".plan");

          const selectPlan = (plan) => {
            plans.forEach(p => p.classList.remove("selected"));
            plan.classList.add("selected");
          };

          plans.forEach(plan => {
            // ✅ 1) hover(마우스 진입)만으로 선택되게
            plan.addEventListener("mouseenter", () => {
              selectPlan(plan);
            });

            // ✅ 2) 클릭하면 결제/업그레이드 동작
            plan.addEventListener("click", () => {
              const tier = plan.dataset.plan; // "lite" | "pro" | "expert"

              // ✅ 현재 플랜(서버 응답 우선) 확인
              const currentTier =
                (window.__planTier || window.currentUserPlan || "free").toLowerCase(); // "free" | "pro" | "expert"

              if (tier === "pro") {
                // ✅ Pro -> Pro : 아무 일도 안 일어나야 함(선택만 유지)
                if (currentTier === "pro") {
                  selectPlan(plan);
                  return;
                }
                openCheckoutByTier("pro");
                return;
              }

              if (tier === "expert") {
                // ✅ Expert -> Expert : 아무 일도 안 일어나야 함(선택만 유지)
                if (currentTier === "expert") {
                  selectPlan(plan);
                  return;
                }
                openCheckoutByTier("expert");
                return;
              }

              // lite는 결제 이동 없음 (선택만 유지)
              selectPlan(plan);
            });
          });
        }

        function handleRoute() {
          console.log("[ROUTE]", {
            pathname: window.location.pathname,
            normalized: normalizePath(window.location.pathname),
            legal: getLegalPath(),
          });

          // 1) share 우선
          const shareId = getShareIdFromPath();
          if (shareId) return;

          // 2) legal 라우트
          const legal = getLegalPath();
          if (legal) {
            applyLegalViewMode();
            renderLegalDoc(legal);
            return;
          }

          // 3) 그 외(= 편집 메인 화면) -> 원복
          restoreAppViewMode();

          // ✅ legal 문서로 덮어쓴 chartInner를 "차트 모드"로 복구
          const chartInner = document.getElementById("chartInner");
          const currentFunc = document.getElementById("currentFunc");
                                         
          if (chartInner && chartInner.querySelector(".legal-doc")) {
            // editor 기본 placeholder로 강제 복구 (로그아웃 상태에서도 잔상 제거)
            chartInner.innerHTML = `
              <p class="placeholder">
                When you enter C code on the left, a flowchart is automatically generated on the right.
              </p>
  `          ;
            if (currentFunc) currentFunc.textContent = "";
          }

          // ✅ 현재 src 기준으로 차트 재생성(핵심)
          if (typeof generateFlowchart === "function") {
            generateFlowchart(false);
          }
        }

        // ============================
        //  HTML entity decode helpers
        // ============================
        function decodeHtmlEntitiesOnce(str) {
          if (!str || typeof str !== "string") return str;
          const textarea = document.createElement("textarea");
          textarea.innerHTML = str;
          return textarea.value;
        }

        // &amp;amp; 같은 "중복 escape"를 2~3번 풀어주는 용도
        function decodeHtmlEntitiesDeep(str, maxIter = 3) {
          let out = str;
          for (let i = 0; i < maxIter; i++) {
            const next = decodeHtmlEntitiesOnce(out);
            if (next === out) break;
            out = next;
          }
          return out;
        }


        async function loadSharedDiagram(shareId) {
          try {
            const res = await fetch(`${API_BASE}/api/share/${shareId}`);

            if (!res.ok) {
              // ✅ 만료/삭제/없음은 404로 통일 → 문구도 통일
              if (res.status === 404) {
                setStatus("error", "This shared link has expired or has been removed");
                return;
              }

              const txt = await res.text().catch(() => "");
              setStatus("error", `Share load failed (HTTP ${res.status}) ${txt}`);
              return;
            }

            const data = await res.json();
            let mermaidCode = (data.mermaid_code || "").trim();
            mermaidCode = decodeHtmlEntitiesDeep(mermaidCode, 3);

            // 👇 Mermaid 문법 깨질 경우 대비(선택)
            if (mermaidCode.includes("&amp;")) {
               console.warn("⚠️ Mermaid code still contains &amp; after decode");
            }
            
            if (!mermaidCode) {
              setStatus("error", "The shared diagram is empty.");
              return;
            }

            window.__lastMermaidCode = mermaidCode;

            const src = document.getElementById("src");
            if (src) {
              src.value = "/* Shared diagram (read-only) */";
              src.disabled = true;
            }

            await renderSharedMermaid(mermaidCode);
            setStatus("success", "Shared diagram loaded successfully.");
          } catch (e) {
            console.error(e);
            setStatus("error", "Failed to load the shared diagram.");
          }
        }


        // ============================
        //  Download 헬퍼들
        // ============================

        // 현재 함수 이름 기준으로 파일명 만들기
        function getCurrentFilename(ext) {
            const labelEl = document.getElementById("currentFunc");
            let base = "autoflow_diagram";

            if (labelEl && labelEl.textContent) {
                const txt = labelEl.textContent;

                // "함수: Foo()" 또는 "Function : Foo()" 둘 다 지원
                const m = txt.match(/(?:함수|Function)\s*:\s*([^(]+)/);
                if (m && m[1]) {
                    base = m[1].trim();
                }
            }
            return base + "." + ext;
        }

        function triggerDownload(url, filename) {
            const a = document.createElement("a");
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }

        // SVG 다운로드
        function downloadAsSVG() {
            const svg = document.querySelector("#chartInner svg");
            if (!svg) {
                alert("There is no flowchart to download yet.");
                return;
            }

            const cloned = svg.cloneNode(true);
            cloned.setAttribute("xmlns", "http://www.w3.org/2000/svg");

            const serializer = new XMLSerializer();
            const source = serializer.serializeToString(cloned);
            const blob = new Blob([source], { type: "image/svg+xml;charset=utf-8" });
            const url = URL.createObjectURL(blob);

            triggerDownload(url, getCurrentFilename("svg"));
            setTimeout(() => URL.revokeObjectURL(url), 1000);
        }


        // PNG 다운로드 (프론트에서 SVG -> Canvas 변환) + 옵션(Scale/BG/Padding)
        async function downloadAsPNG() {
          const svg = document.querySelector("#chartInner svg");
          if (!svg) {
            alert("There is no flowchart to download yet.");
            return;
          }

          // ✅ Settings에서 저장한 PNG 옵션 읽기
          let scale = 2;
          let bg = "white";

          try {
            scale = parseFloat(localStorage.getItem("autoflow-png-scale") || "2");
            bg = localStorage.getItem("autoflow-png-bg") || "white";
            bg = String(bg || "white").toLowerCase().trim();
          } catch (e) {}

          // 방어
          if (!Number.isFinite(scale) || scale <= 0) scale = 2;
          if (bg !== "transparent") bg = "white";

          // 1) SVG 복제 + xmlns 보장
          const cloned = svg.cloneNode(true);
          cloned.setAttribute("xmlns", "http://www.w3.org/2000/svg");

          // 2) 크기 계산 (viewBox 우선, 없으면 bbox)
          const vb = cloned.viewBox && cloned.viewBox.baseVal ? cloned.viewBox.baseVal : null;

          let width = 0, height = 0;
          if (vb && vb.width && vb.height) {
            width = vb.width;
            height = vb.height;
          } else {
            const bbox = svg.getBBox();
            width = Math.ceil(bbox.width);
            height = Math.ceil(bbox.height);
          }

          if (!width || !height) {
            alert("Failed to determine SVG size for PNG export.");
            return;
          }

          // 3) SVG 문자열화
          const serializer = new XMLSerializer();
          const source = serializer.serializeToString(cloned);

          // 4) Blob URL -> Image 로드 -> Canvas draw
          const svgBlob = new Blob([source], { type: "image/svg+xml;charset=utf-8" });
          const url = URL.createObjectURL(svgBlob);

          try {
            const img = new Image();
            img.crossOrigin = "anonymous";

            await new Promise((resolve, reject) => {
              img.onload = resolve;
              img.onerror = reject;
              img.src = url;
            });

            const dpr = window.devicePixelRatio || 1;

            // Chrome/브라우저에서 안전한 캔버스 최대치 가드(경험상)
            // (너무 크게 잡으면 여전히 메모리 터질 수 있음)
            const MAX_DIM = 16384; // 한 변 최대
            const MAX_PIXELS = 160_000_000; // 총 픽셀 수 제한(대략 160MP)

            let effScale = scale;

            // 1) 한 변 제한 기반 scale 축소
            effScale = Math.min(
              effScale,
              MAX_DIM / (width * dpr),
              MAX_DIM / (height * dpr)
            );

            // 2) 총 픽셀 제한 기반 scale 축소
            const pixelsAtScale = (width * dpr * effScale) * (height * dpr * effScale);
            if (pixelsAtScale > MAX_PIXELS) {
              const shrink = Math.sqrt(MAX_PIXELS / pixelsAtScale);
              effScale = effScale * shrink;
            }

            // 최소 0.1 미만이면 너무 작으니 중단(또는 1x로 강제)
            if (effScale < 0.1) {
              alert("Diagram is too large to export as PNG in this browser. Try lower scale or export as SVG.");
              return;
            }

            const canvas = document.createElement("canvas");
            canvas.width = Math.max(1, Math.floor(width * dpr * effScale));
            canvas.height = Math.max(1, Math.floor(height * dpr * effScale));

            const ctx = canvas.getContext("2d");
            if (!ctx) {
              alert("Canvas is not supported in this browser.");
              return;
            }

            // ✅ dpr * scale 적용 (고해상도)
            ctx.setTransform(dpr * effScale, 0, 0, dpr * effScale, 0, 0);

            // ✅ 배경 (white / transparent)
            if (bg === "white") {
              ctx.fillStyle = "#ffffff";
              ctx.fillRect(0, 0, width, height);
            }

            // ✅ padding 만큼 offset
            ctx.drawImage(img, 0, 0, width, height);

            // 5) PNG 저장
            let blob = null;

            // ✅ 여러 번 점진적으로 축소 재시도
            let tries = 0;
            while (!blob && effScale >= 0.1 && tries < 6) {
              canvas.width  = Math.max(1, Math.floor(width  * dpr * effScale));
              canvas.height = Math.max(1, Math.floor(height * dpr * effScale));
              ctx.setTransform(dpr * effScale, 0, 0, dpr * effScale, 0, 0);

              if (bg === "white") {
                ctx.fillStyle = "#ffffff";
                ctx.fillRect(0, 0, width, height);
              }
              ctx.drawImage(img, 0, 0, width, height);

              blob = await new Promise((resolve) => canvas.toBlob(resolve, "image/png"));

              if (!blob) {
                // ✅ 다음 라운드에서 더 줄여서 재시도
                effScale *= 0.75;
                tries += 1;
              }
            }

            if (!blob) {
              alert("Failed to create PNG blob. Try lowering PNG Scale in Settings, or export as SVG.");
              return;
            }


            const pngUrl = URL.createObjectURL(blob);
            triggerDownload(pngUrl, getCurrentFilename("png"));
            setTimeout(() => URL.revokeObjectURL(pngUrl), 2000);
          } catch (e) {
            console.error(e);
            alert("PNG export failed. (SVG->Canvas render error)");
          } finally {
            URL.revokeObjectURL(url);
          }
        }

        async function downloadFromServer(format) {
          // format: "png" | "pdf"
          if (!window.currentUser) {
            alert("Please log in to download.");
            return;
          }

          // 1) 현재 코드 확보 (generateFlowchart와 동일하게)
          const srcEl = document.getElementById("src");
          let src = srcEl ? (srcEl.value || "").trim() : "";
          if ((!src || src.length === 0) && typeof savedSourceCode === "string") {
            const saved = savedSourceCode.trim();
            if (saved) src = saved;
          }
          if (!src) {
            alert("There is no code to export yet.");
            return;
          }

          // 2) access_token 확보
          let accessToken = null;
          try {
            const session = supabase.auth.getSession
              ? (await supabase.auth.getSession()).data.session
              : null;
            if (session?.access_token) accessToken = session.access_token;
          } catch (e) {}

          if (!accessToken) {
            alert("Your login session has expired. Please log in again.");
            return;
          }

          // 3) macro / branch_shape 동일 전달
          const formData = new FormData();
          formData.append("source_code", src);
          formData.append("out_format", format);
          formData.append("branch_shape", currentBranchShape);

          if (macroMode === "defined") {
            const v = (macroDefines || "").trim();
            formData.append("macro_defines", v.length > 0 ? v : "__USE_ELSE_ONLY__");
          }

          formData.append("access_token", accessToken);
          formData.append("user_id", window.currentUser.id);
          formData.append("user_email", window.currentUser.email || "");

          // 4) 서버에서 파일(blob) 받아서 다운로드
          const res = await fetch(API_BASE + "/api/export", {
            method: "POST",
            body: formData,
          });

          if (!res.ok) {
            alert(`Export failed (HTTP ${res.status}). Try again.`);
            return;
          }

          const blob = await res.blob();

          // 서버가 주는 파일명 우선 사용
          let filename = getCurrentFilename(format);
          const cd = res.headers.get("content-disposition") || "";
          const m = cd.match(/filename\*=UTF-8''([^;]+)|filename="?([^"]+)"?/i);
          if (m) {
            const raw = m[1] || m[2];
            if (raw) filename = decodeURIComponent(raw);
          }

          const url = URL.createObjectURL(blob);
          triggerDownload(url, filename);
          setTimeout(() => URL.revokeObjectURL(url), 2000);
        }
                    

        // 다운로드 타입에 따라 분기
        async function downloadDiagram() {
          // ✅ 0) 로그인 먼저 체크 (로그아웃 상태면 업그레이드가 아니라 로그인 안내)
          if (!window.currentUser) {
            alert("Please log in to use DOWNLOAD.\n(DOWNLOAD is available on Pro/Expert.)");
            return;
          }
            
          const tier = window.__planTier || (window.__isProUser ? "pro" : "free");
          const isFree = (tier === "free") && !window.__isTestAccount;
          if (isFree) {
            showDownloadUpgradePrompt();
            return;
          }
            
          if (downloadFormat === "png") {
            await downloadAsPNG();   // ✅ 프론트 변환
          } else {
            downloadAsSVG();
          }
        }
        
        let typingTimer = null;
        const TYPING_DELAY_MS = 600;

        // 다이어그램 줌 상태 (내용만 확대, 레이아웃은 그대로)
        let diagramZoom = 1.0;

        function clampZoom(z) {
            if (z < 0.5) return 0.5;   // 50%
            if (z > 7.0) return 7.0;   // 700%
            return z;
        }
        function updateZoomLabel() {
            const label = document.getElementById("zoomLabel");
            label.textContent = Math.round(diagramZoom * 100) + "%";
        }

        // 공통 적용 함수
        function applyDiagramZoom() {
            const svg = document.querySelector("#chartInner svg");
            if (!svg) return;

            // 다이어그램의 기준 크기(100%)를 기준으로 확대/축소
            const percent = diagramZoom * 100;
            svg.style.width = percent + "%";
            svg.style.height = "auto";
        }

        // ✅ 화면 맞춤(Fit to screen): 현재 SVG 전체가 컨테이너 안에 들어오도록 zoom 자동 계산
        function fitDiagramToScreen(padding = 16) {
            const container = document.getElementById("chartContainer");
            const svg = document.querySelector("#chartInner svg");
            if (!container || !svg) return;

            // 컨테이너 가용 영역
            const cw = Math.max(1, container.clientWidth  - padding);
            const ch = Math.max(1, container.clientHeight - padding);

            // SVG의 "기본" 크기 추정 (Mermaid SVG는 보통 width/height 또는 viewBox가 존재)
            let sw = 0, sh = 0;

            try {
                // 1순위: viewBox 기반 (가장 안정적)
                const vb = svg.viewBox && svg.viewBox.baseVal;
                if (vb && vb.width && vb.height) {
                    sw = vb.width;
                    sh = vb.height;
                }
            } catch (_) {}

            try {
                // 2순위: width/height 속성
                if ((!sw || !sh) && svg.width && svg.height) {
                    const w = parseFloat(svg.getAttribute("width"));
                    const h = parseFloat(svg.getAttribute("height"));
                    if (Number.isFinite(w) && Number.isFinite(h)) {
                        sw = w; sh = h;
                    }
                }
            } catch (_) {}

            try {
                // 3순위: bbox
                if (!sw || !sh) {
                    const bb = svg.getBBox();
                    if (bb && bb.width && bb.height) {
                        sw = bb.width;
                        sh = bb.height;
                    }
                }
            } catch (_) {}

            if (!sw || !sh) return;

            // "전체가 들어오도록" 비율 계산 (여유를 조금 주고 싶으면 0.98 같은 값 곱해도 됨)
            let z = Math.min(cw / sw, ch / sh);

            // 너무 작아지지 않게 최소값(공유 페이지에서 작을 수 있어서 0.2 정도 허용)
            if (z < 0.2) z = 0.2;

            diagramZoom = z;           // ✅ 전역 줌 갱신
            applyDiagramZoom();
            updateZoomLabel();

            // ✅ Fit 후에는 좌상단으로 몰려 보일 수 있어서 상단/좌측 0으로 초기화 (선택)
            container.scrollLeft = 0;
            container.scrollTop  = 0;
        }

        

        // ✅ 부드러운 스크롤 애니메이션 (container 전용)
        function smoothScrollTo(container, targetLeft, targetTop, duration = 260) {
            if (!container) return;

            // 이미 브라우저가 지원하면 이게 제일 간단 (대부분 지원)
            // 단, 일부 환경에서 behavior가 container에 잘 안 먹을 때가 있어 fallback도 같이 둠.
            try {
                container.scrollTo({ left: targetLeft, top: targetTop, behavior: "smooth" });
                return;
            } catch (_) {}

            // ---- fallback: requestAnimationFrame 기반 ----
            const startLeft = container.scrollLeft;
            const startTop  = container.scrollTop;
            const deltaLeft = targetLeft - startLeft;
            const deltaTop  = targetTop - startTop;

            const startTime = performance.now();

            // easeOutCubic
            const ease = (t) => 1 - Math.pow(1 - t, 3);

            function tick(now) {
                const elapsed = now - startTime;
                const t = Math.min(1, elapsed / duration);
                const k = ease(t);

                container.scrollLeft = startLeft + deltaLeft * k;
                container.scrollTop  = startTop  + deltaTop  * k;

                if (t < 1) requestAnimationFrame(tick);
            }

            requestAnimationFrame(tick);
        }
        

        // ✅ 플로우차트 컨테이너 안에서 노드를 화면 가운데로 "부드럽게" 스크롤
        function scrollNodeIntoCenter(node, smooth = true) {
            const container = document.getElementById("chartContainer");
            if (!node || !container) return;

            try {
                // 현재 뷰포트 기준 좌표
                const nodeRect = node.getBoundingClientRect();
                const contRect = container.getBoundingClientRect();

                // 컨테이너 내부 스크롤 좌표로 변환
                // (노드의 화면 좌표 - 컨테이너의 화면 좌표) + 현재 scroll 값
                const nodeOffsetLeft = (nodeRect.left - contRect.left) + container.scrollLeft;
                const nodeOffsetTop  = (nodeRect.top  - contRect.top)  + container.scrollTop;

                // 노드 중심이 컨테이너 중심에 오도록 목표 scroll 계산
                const targetLeft = nodeOffsetLeft + nodeRect.width  / 2 - container.clientWidth  / 2;
                const targetTop  = nodeOffsetTop  + nodeRect.height / 2 - container.clientHeight / 2;

                // 스크롤 범위 클램프 (끝으로 튀는 것 방지)
                const maxLeft = container.scrollWidth  - container.clientWidth;
                const maxTop  = container.scrollHeight - container.clientHeight;

                const clampedLeft = Math.max(0, Math.min(maxLeft, targetLeft));
                const clampedTop  = Math.max(0, Math.min(maxTop, targetTop));

                if (smooth) {
                    smoothScrollTo(container, clampedLeft, clampedTop, 260);
                } else {
                    container.scrollLeft = clampedLeft;
                    container.scrollTop  = clampedTop;
                }
            } catch (e) {
                console.warn("scrollNodeIntoCenter error:", e);
            }
        }
        
        function zoomChange(delta) {
            diagramZoom = clampZoom(diagramZoom + delta);
            applyDiagramZoom();       // ← zoom 적용
            updateZoomLabel();
        }
        function zoomReset() {
            diagramZoom = 1.0;
            applyDiagramZoom();       // ← 100%로
            updateZoomLabel();
        }

        let __chartInteractionsInited = false;

        function initChartInteractions() {
            if (__chartInteractionsInited) return;
            __chartInteractionsInited = true;

            const chartContainer = document.getElementById("chartContainer");
            if (!chartContainer) return;

            // ✅ Ctrl+휠: "포인터(마우스 위치) 중심" 줌
            chartContainer.addEventListener("wheel", function (e) {
                if (!e.ctrlKey) return;

                // 브라우저 기본 페이지 줌 방지
                e.preventDefault();

                const rect = chartContainer.getBoundingClientRect();

                // 컨테이너 내부에서 마우스 위치(px)
                const offsetX = e.clientX - rect.left;
                const offsetY = e.clientY - rect.top;

                // 줌 전 스크롤(px)
                const prevScrollLeft = chartContainer.scrollLeft;
                const prevScrollTop  = chartContainer.scrollTop;

                // 줌 전 줌값
                const prevZoom = diagramZoom;

                // ✅ 현재 마우스가 가리키는 "콘텐츠 좌표(줌 제거 좌표)"
                const contentX = (prevScrollLeft + offsetX) / prevZoom;
                const contentY = (prevScrollTop  + offsetY) / prevZoom;

                // 줌 변화량
                const delta = (e.deltaY < 0) ? +0.1 : -0.1;

                // ✅ 줌값 갱신 + 적용
                diagramZoom = clampZoom(diagramZoom + delta);
                applyDiagramZoom();
                updateZoomLabel();

                // ✅ 줌 후에도 같은 콘텐츠가 같은 화면 위치에 유지되도록 스크롤 보정
                requestAnimationFrame(() => {
                    chartContainer.scrollLeft = (contentX * diagramZoom) - offsetX;
                    chartContainer.scrollTop  = (contentY * diagramZoom) - offsetY;
                });
            }, { passive: false });


            // ✅ 좌클릭 드래그로 패닝
            let isPanning = false;
            let startX = 0;
            let startY = 0;
            let startScrollLeft = 0;
            let startScrollTop = 0;

            chartContainer.addEventListener("mousedown", function(e) {
                if (e.button !== 0) return;
                isPanning = true;
                startX = e.clientX;
                startY = e.clientY;
                startScrollLeft = chartContainer.scrollLeft;
                startScrollTop = chartContainer.scrollTop;
                e.preventDefault();
            });

            document.addEventListener("mousemove", function(e) {
                if (!isPanning) return;
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                chartContainer.scrollLeft = startScrollLeft - dx;
                chartContainer.scrollTop  = startScrollTop - dy;
            });

            document.addEventListener("mouseup", function() {
                isPanning = false;
            });
        }

        

        // ============================
        //  Status / Error helpers
        // ============================
        function setStatus(type, message) {
            const status = document.getElementById("status");
            if (!status) return;

            // type: "success" | "error" | "info" | "idle"
            let icon = "";
            if (type === "success") icon = "✅";
            else if (type === "error") icon = "❌";
            else if (type === "info") icon = "ℹ️";

            status.className = "";  // 기존 클래스 제거
            if (type === "success") status.classList.add("success");
            if (type === "error")   status.classList.add("error");

            status.textContent = icon ? `${icon} ${message}` : message;
        }

        function showMacroUpgradePrompt() {
          // 1) 상태 메시지
          setStatus("error", "Macro Defines is available on Pro/Expert. Please upgrade to use this feature.");

          // 2) 플로우차트 영역에도 안내 문구
          const chartInner = document.getElementById("chartInner");
          if (chartInner) {
            chartInner.innerHTML = `
              <p class="placeholder" style="color:#b91c1c;">
                Macro Defines (Defined mode) is a Pro/Expert feature.<br/>
                Please upgrade to enable macro-based preprocessing.
              </p>
            `;
          }

          // 3) UPGRADE 버튼 블링크
          // ✅ 단일 제어 함수로 위임
          applyUpgradeButtonUI(window.__nodeCount, { forceBlink: true });
        }

        function showShareUpgradePrompt() {
          // 1) 상태 메시지
          setStatus("error", "SHARE is available on Pro/Expert. Please upgrade to use this feature.");

          // 2) 플로우차트 영역에도 안내 문구
          const chartInner = document.getElementById("chartInner");
          if (chartInner) {
            chartInner.innerHTML = `
              <p class="placeholder" style="color:#b91c1c;">
                SHARE is a Pro/Expert feature.<br/>
                Please upgrade to create a share link.
              </p>
            `;
          }

          // 3) UPGRADE 버튼 블링크
          // ✅ 단일 제어 함수로 위임
          applyUpgradeButtonUI(window.__nodeCount, { forceBlink: true });
        }

        function showDownloadUpgradePrompt() {
          // 1) 상태 메시지
          setStatus("error", "DOWNLOAD is available on Pro/Expert. Please upgrade to use this feature.");

          // 2) 플로우차트 영역에도 안내 문구
          const chartInner = document.getElementById("chartInner");
          if (chartInner) {
            chartInner.innerHTML = `
              <p class="placeholder" style="color:#b91c1c;">
                DOWNLOAD is a Pro/Expert feature.<br/>
                Please upgrade to download the diagram.
              </p>
            `;
          }

          // 3) UPGRADE 버튼 블링크
          // ✅ 단일 제어 함수로 위임
          applyUpgradeButtonUI(window.__nodeCount, { forceBlink: true });
        }
                

        // 백엔드에서 내려오는 에러 코드를 보기 좋게 매핑
        function mapBackendError(errorCode, rawError) {
            const msg  = (rawError || "").toString();
            const code = (errorCode || "").toString().toUpperCase();

            // 1) 명시적 코드 우선
            if (code === "NO_FUNCTION") {
                return "No function body was found in the code.";
            }
            if (code === "TOO_MANY_NODES") {
                return "The function is too large to analyze (too many flowchart nodes).";
            }
            if (code === "UNSUPPORTED_SYNTAX") {
                return "The code uses syntax that is not supported yet (for example, 'goto' inside 'switch').";
            }

            // 2) 코드가 없으면 메시지 패턴으로 추론
            if (/no function/i.test(msg)) {
                return "No function body was found in the code.";
            }
            if (/too many nodes/i.test(msg)) {
                return "The function is too large to analyze (too many flowchart nodes).";
            }
            if (/unsupported/i.test(msg)) {
                return "The code uses syntax that is not supported yet.";
            }

            // 3) 일단 알 수 없는 에러는 원문을 괄호로 남겨줌
            if (msg) {
                return `Failed to generate the flowchart. (${msg})`;
            }
            return "Failed to generate the flowchart due to an unknown error.";
        }


        // ============================
        //  코드 라인 하이라이트 관련 함수들
        // ============================

        // 매칭용 문자열 정규화 (공백/괄호/세미콜론 등 정리)
        function normalizeForMatch(s) {
            if (!s) return "";
            return String(s)
                .toLowerCase()
                .replace(/["']/g, "")       // 따옴표 제거
                .replace(/[{};]/g, "")      // 중괄호/세미콜론 제거
                .replace(/\s+/g, " ")       // 여러 공백 -> 한 칸
                .trim();
        }

        // ============================
        //  코드 라인 → 노드 하이라이트
        // ============================

        // 선택된 노드 하이라이트 해제
        function clearNodeHighlight() {
            const svg = document.querySelector("#chartInner svg");
            if (!svg) return;
            svg.querySelectorAll(".node.autoflow-selected").forEach(n => {
                n.classList.remove("autoflow-selected");
            });
        }

        // 노드 라벨에서 "핵심 한 줄"만 뽑기 (if 줄 + 대입문 같이 있을 때 대비)
        function getNodeLabelCore(node) {
            const rawText = (node.textContent || "").trim();
            if (!rawText) return "";

            if (rawText.indexOf("\n") !== -1) {
                const parts = rawText.split(/\n/).map(p => p.trim()).filter(Boolean);
                if (parts.length > 0) {
                    // 가장 짧은 한 줄을 대표 라벨로 사용
                    return parts.reduce((a, b) => (a.length <= b.length ? a : b));
                }
            }
            return rawText;
        }

        // 현재 줄과 노드 라벨의 매칭 점수 계산
        function calcMatchScore(normLine, normLabel) {
            if (!normLine || !normLabel) return 0;

            if (normLine === normLabel) return 3.0;  // 완전 일치 최우선

            if (normLine.indexOf(normLabel) !== -1) {
                // 라벨이 줄 안에 포함
                return normLabel.length / Math.max(1, normLine.length);
            }
            if (normLabel.indexOf(normLine) !== -1) {
                // 줄이 라벨 안에 포함
                return normLine.length / Math.max(1, normLabel.length);
            }
            return 0;
        }

        // 특정 라인 번호에 매핑된 "가장 잘 맞는" 노드를 찾아 하이라이트 + 스크롤
        function highlightNodesForLine(lineIdx) {
            const svg = document.querySelector("#chartInner svg");
            if (!svg) return;

            const textarea = document.getElementById("src");
            if (!textarea) return;

            const code = textarea.value || "";
            const lines = code.split("\n");
            if (!lines.length) return;

            // 라인 인덱스 보정
            let idx = lineIdx;
            if (idx < 0) idx = 0;
            if (idx >= lines.length) idx = lines.length - 1;

            const normLine = normalizeForMatch(lines[idx]);
            if (!normLine) {
                clearNodeHighlight();
                return;
            }

            const nodeLines = window.__nodeLines || {};

            clearNodeHighlight();

            const nodes = svg.querySelectorAll(".node");
            const container = document.getElementById("chartContainer");

            let bestNode = null;
            let bestScore = 0;
            let bestDist = Infinity;

            nodes.forEach(node => {
                const rawId = node.getAttribute("id") || "";
                const m = rawId.match(/(?:flowchart-)?(N\d+)/);
                if (!m) return;
                const nodeKey = m[1];   // N1, N2 ...

                const mappedLine = nodeLines[nodeKey];

                const coreLabel = getNodeLabelCore(node);
                const normLabel = normalizeForMatch(coreLabel);
                if (!normLabel) return;

                const score = calcMatchScore(normLine, normLabel);
                if (score <= 0) return;   // 전혀 안 맞으면 후보 제외

                // body_start_line 한 칸 오차 같은 경우를 위해 "라인 거리"도 같이 고려
                const dist = (typeof mappedLine === "number")
                    ? Math.abs(mappedLine - idx)
                    : Infinity;

                if (
                    score > bestScore ||
                    (score === bestScore && dist < bestDist)
                ) {
                    bestScore = score;
                    bestDist = dist;
                    bestNode = node;
                }
            });

            if (!bestNode) return;

            bestNode.classList.add("autoflow-selected");

            // 줌 상태와 상관없이, 항상 화면 중앙으로 가져오기
            scrollNodeIntoCenter(bestNode);
        }

        // 텍스트 커서 위치 기준으로 현재 라인 계산 → 노드 하이라이트
        function updateNodeHighlightFromCaret() {
            const textarea = document.getElementById("src");
            if (!textarea) return;

            const pos = textarea.selectionStart || 0;
            const textBefore = textarea.value.slice(0, pos);
            const lineIdx = textBefore.split("\n").length - 1;

            highlightNodesForLine(lineIdx);
        }

        // lineIdx 에 해당하는 줄을 그대로 하이라이트 (fallback 용)
        function highlightCodeAtLine(lineIdx) {
            const textarea = document.getElementById("src");
            if (!textarea) return -1;

            const code  = textarea.value;
            const lines = code.split("\n");
            if (!lines.length) return -1;

            // 인덱스 보정
            let idx = lineIdx;
            if (idx < 0) idx = 0;
            if (idx >= lines.length) idx = lines.length - 1;

            // 선택 범위 계산
            let start = 0;
            for (let i = 0; i < idx; i++) {
                start += lines[i].length + 1; // '\n'
            }
            const end = start + lines[idx].length;

            textarea.focus();
            textarea.setSelectionRange(start, end);

            // 가운데 쯤으로 스크롤
            const ratio        = idx / Math.max(1, lines.length - 1);
            const targetScroll = textarea.scrollHeight * ratio - textarea.clientHeight / 2;
            textarea.scrollTop = Math.max(0, targetScroll);

            return idx;
        }


        // 노드 라벨 + (선택) 대략 라인 위치 힌트로 코드 라인 하이라이트
        // -> 찾은 라인 인덱스를 반환 (없으면 -1)
        function highlightCodeForLabel(rawLabel, approxLineHint) {
            const textarea = document.getElementById("src");
            if (!textarea) return -1;

            const code = textarea.value;
            if (!code) return -1;

            const lines = code.split("\n");

            // Mermaid가 한 노드에 여러 줄 텍스트를 넣는 경우 대비:
            //    - if 줄 + 대입문이 같이 들어오면, 보통 "대입문"이 더 짧음
            //    - 그래서 줄바꿈 기준으로 나눠서 "가장 짧은 한 줄"만 선택
            let core = rawLabel || "";
            if (core.indexOf("\n") !== -1) {
                const parts = core.split(/\n/).map(p => p.trim()).filter(Boolean);
                if (parts.length > 0) {
                    core = parts.reduce((a, b) => (a.length <= b.length ? a : b));
                }
            }

            let label = normalizeForMatch(core);
            if (!label) return -1;

            // 너무 길면 앞 부분만 사용 (매칭용)
            if (label.length > 120) {
                label = label.slice(0, 120);
            }

            // 1) 정확히 같은 줄(eqCandidates)과
            // 2) 부분 일치(subCandidates)를 따로 모은다.
            const eqCandidates = [];
            const subCandidates = [];

            for (let i = 0; i < lines.length; i++) {
                const normLine = normalizeForMatch(lines[i]);
                if (!normLine) continue;

                if (normLine === label) {
                    // 🔹 완전 일치 라인
                    eqCandidates.push(i);
                } else {
                    // 🔹 부분 일치 (이건 정확 일치가 하나도 없을 때만 사용할 예정)
                    if (
                        normLine.indexOf(label) !== -1 ||      // 라인 안에 라벨 문자열 포함
                        (label.indexOf(normLine) !== -1 && normLine.length > 5)
                    ) {
                        subCandidates.push(i);
                    }
                }
            }

            let bestLine = -1;
            let candidates = [];

            // 1순위: "정확 일치" 후보가 있으면 그것만 사용
            if (eqCandidates.length > 0) {
                candidates = eqCandidates;
            }
            // 2순위: 정확 일치가 하나도 없을 때만 부분 일치 사용
            else if (subCandidates.length > 0) {
                candidates = subCandidates;
            }

            if (candidates.length > 0) {
                // 2) 노드 Y좌표로부터 추정한 라인 가까운 것 우선 선택
                if (typeof approxLineHint === "number" && !Number.isNaN(approxLineHint)) {
                    let minDist = Infinity;
                    candidates.forEach(idx => {
                        const d = Math.abs(idx - approxLineHint);
                        if (d < minDist) {
                            minDist = d;
                            bestLine = idx;
                        }
                    });
                } else {
                    // 힌트 없으면 첫 번째 후보 사용
                    bestLine = candidates[0];
                }
            } else {
                // 3) 그래도 못 찾으면, 라인별 유사도 기반으로 "가장 비슷한" 한 줄을 찾는다.
                let bestScore = 0;
                let bestIdx = -1;

                for (let i = 0; i < lines.length; i++) {
                    const normLine = normalizeForMatch(lines[i]);
                    if (!normLine) continue;

                    const lenLine = normLine.length;
                    const lenLabel = label.length;
                    let score = 0;

                    if (normLine === label) {
                        score = 1.0;
                    } else if (normLine.indexOf(label) !== -1) {
                        // label 이 라인 안에 포함
                        score = label.length / lenLine;
                    } else if (label.indexOf(normLine) !== -1) {
                        // 반대로 라인이 label 안에 포함
                        score = lenLine / lenLabel;
                    } else {
                        continue;
                    }

                    if (score > bestScore) {
                        bestScore = score;
                        bestIdx = i;
                    }
                }

                if (bestScore > 0) {
                    bestLine = bestIdx;
                }
            }

            if (bestLine < 0 || bestLine >= lines.length) return -1;

            // 선택할 문자열의 시작/끝 인덱스 계산
            let start = 0;
            for (let i = 0; i < bestLine; i++) {
                start += lines[i].length + 1; // '\n' 포함
            }
            const end = start + lines[bestLine].length;

            // 텍스트 영역에 선택/포커스
            textarea.focus();
            textarea.setSelectionRange(start, end);

            // 대략적인 스크롤 위치 조정
            const totalLines = lines.length;
            const ratio = bestLine / Math.max(1, totalLines - 1);
            const targetScroll = textarea.scrollHeight * ratio - textarea.clientHeight / 2;
            textarea.scrollTop = Math.max(0, targetScroll);

            return bestLine;
        }

        // Mermaid 노드에 클릭 핸들러 연결
        function attachNodeClickHandlers() {
            const svg = document.querySelector("#chartInner svg");
            if (!svg) return;

            const nodeLines = window.__nodeLines || {};

            const nodes = svg.querySelectorAll(".node");
            nodes.forEach(node => {
                node.style.cursor = "pointer";
                node.addEventListener("click", () => {
                    // ✅ 클릭 시점에 항상 최신 textarea를 다시 가져온다
                    const textarea = document.getElementById("src");
                    if (!textarea) return;

                    // 선택된 노드 하이라이트
                    clearNodeHighlight();
                    node.classList.add("autoflow-selected");
                    scrollNodeIntoCenter(node);

                    // node id -> N1, N2 ...
                    const rawId = node.getAttribute("id") || "";
                    let nodeKey = rawId;
                    const m = rawId.match(/(?:flowchart-)?(N\d+)/);
                    if (m) {
                        nodeKey = m[1];
                    }

                    // 노드 라벨 텍스트
                    const rawText = node.textContent || "";
                    let label = rawText.replace(/\s+/g, " ").trim();
                    if (!label) return;

                    const lower = label.toLowerCase();
                    if (lower === "merge") return;
                    if (lower.startsWith("start")) return;
                    if (lower.startsWith("end")) return;

                    // node_lines에서 온 라인 번호는 "힌트"로만 사용
                    const mapped = nodeLines[nodeKey];
                    const approxHint =
                        (typeof mapped === "number") ? mapped : null;

                    // 1차: 항상 문자열 기반 매칭 사용
                    let bestLine = highlightCodeForLabel(label, approxHint);

                    // 2차: 텍스트 매칭이 완전히 실패한 경우에만
                    //      node_lines 라인 번호 그대로 사용 (fallback)
                    if (bestLine < 0 && typeof mapped === "number") {
                        bestLine = highlightCodeAtLine(mapped);
                    }
                });
            });
        }

        async function generateFlowchart(auto = false) {
            // ✅ legal 문서 페이지에서는 차트 생성이 문서를 덮어쓰지 않도록 막기
            if (window.__isLegalMode) return;
              
            const status      = document.getElementById("status");
            const chartInner  = document.getElementById("chartInner");
            const currentFunc = document.getElementById("currentFunc");

            // 로그인 상태 확인
            if (!window.currentUser) {
              setStatus("error", "Please log in to use mAutoFlow.");

              // ✅ (방어) 혹시 chartInner가 legal-doc 상태면 placeholder로 복구
              if (chartInner && chartInner.querySelector(".legal-doc")) {
                chartInner.innerHTML = `
                  <p class="placeholder">
                    When you enter C code on the left, a flowchart is automatically generated on the right.
                  </p>
                `;
              }
              if (currentFunc) currentFunc.textContent = "";
              return;
            }

            // 테스트 계정 여부
            const isTestUser = (window.currentUser.email === TEST_EMAIL);

            const srcEl = document.getElementById("src");

            // 우선 현재 textarea 기준으로 코드 읽기
            let src = srcEl ? srcEl.value.trim() : "";

            // 만약 SETTINGS/HELP 등으로 src가 없거나 비어 있어도,
            //    이전에 저장해둔 savedSourceCode가 있으면 그걸 사용
            if ((!src || src.length === 0) && typeof savedSourceCode === "string") {
                const saved = savedSourceCode.trim();
                if (saved) {
                    src = saved;
                }
            }

            if (!src) {
                if (!auto) {
                    setStatus("info", "Enter your C code on the left to generate a flowchart.");
                } else {
                    setStatus("idle", "");
                }
                currentFunc.textContent = "";
                chartInner.innerHTML = `
                    <p class="placeholder">
                        When you enter C code on the left, a flowchart is automatically generated on the right.
                    </p>`;
                return;
            }

            diagramZoom = 1.0;
            updateZoomLabel();

            setStatus("info", auto ? "Automatically updating the flowchart..." : "Creating the flowchart...");
            chartInner.innerHTML = "";

            const formData = new FormData();
            formData.append("source_code", src);
            formData.append("branch_shape", currentBranchShape);
            formData.append("func_name_style", funcNameStyle);

            // 미니 전처리기용 매크로 정의 문자열 전달
            if (macroMode === "defined") {
              const v = (macroDefines || "").trim();
              if (v.length > 0) {
                formData.append("macro_defines", v);
              } else {
                // Defined인데 비어있으면: #else 쪽을 타게 해야 함
                // (백엔드에서 이 값을 special-case로 처리)
                formData.append("macro_defines", "__USE_ELSE_ONLY__");
              }
            }
                        

            try {
                // ① Supabase에서 access_token 가져오기
                let accessToken = null;
                try {
                    const { data, error } = await supabase.auth.getUser();
                    // data.user 가 있고 session 이 있으면 토큰 읽기
                    const session = supabase.auth.getSession
                        ? (await supabase.auth.getSession()).data.session
                        : null;

                    if (session?.access_token) {
                        accessToken = session.access_token;
                    }
                } catch (e) {
                    console.warn("Failed to get Supabase user/session", e);
                }


                // 여기서 FormData 에 access_token 필드를 넣어준다
                if (accessToken) {
                    // console.log(
                    //    "accessToken from Supabase:",
                    //    accessToken.slice(0, 20) + "..."   // 앞 20글자만 찍어서 길이 확인
                    // );
                    formData.append("access_token", accessToken);
                    // 추가: user_id / user_email
                    if (window.currentUser) {
                        formData.append("user_id", window.currentUser.id);
                        formData.append("user_email", window.currentUser.email || "");
                    }
                } else {
                    setStatus("error", "Your login session has expired. Please log in again.");
                    return;
                }

                async function postConvertText(formData) {
                  // ✅ 백엔드가 /api/convert_text 또는 /api/convert_text/ 어느 쪽이든 redirect 없이 맞춰 타게 함
                  const candidates = [
                    API_BASE + "/api/convert_text"
                  ];

                  let lastErr = null;

                  for (const url of candidates) {
                    try {
                      const res = await fetch(url, {
                        method: "POST",
                        body: formData,
                        cache: "no-store",
                        // redirect: "follow" (default) 이지만, 여기서 핵심은 "redirect 자체를 안 타는 URL"을 찾는 것
                      });
                      return res; // ✅ 성공/실패 응답(res.ok 여부)은 바깥 로직에서 기존대로 처리
                    } catch (e) {
                      lastErr = e; // TypeError: Failed to fetch (CORS/네트워크 포함)
                    }
                  }

                  throw lastErr || new Error("Failed to call convert_text");
                }

                const res = await postConvertText(formData);

                if (!res.ok) {
                    let data = {};
                    try {
                        data = await res.json();
                    } catch (_) {}

                    // 에러 응답에도 계정/플랜 정보가 들어올 수 있으니 먼저 반영
                    if (typeof data.is_pro_user !== "undefined") {
                        window.__isProUser = !!data.is_pro_user;
                    }
                    if (typeof data.plan_name === "string") {
                        window.__planName = data.plan_name || null;
                    }
                    if (typeof data.is_test_account !== "undefined") {
                        window.__isTestAccount = !!data.is_test_account;
                    }
                    if (typeof data.plan_tier === "string") {
                        window.__planTier = data.plan_tier || null;   // "free" | "pro" | "expert"
                    }
                    if (typeof data.node_limit === "number") {
                        window.__nodeLimitFromServer = data.node_limit;
                        window.__nodeLimit = data.node_limit;
                    }
                    if (typeof data.usage_count === "number") {
                        window.__serverUsageCount = data.usage_count;
                    }
                    if (typeof data.daily_free_limit === "number") {
                        window.__dailyFreeLimit = data.daily_free_limit;
                    }

                    // 백엔드가 플랜 정보를 내려줬다면 더 이상 "로딩 중" 아님
                    window.__planLoading = false;

                    // 상단 quota 라벨 업데이트
                    updateQuotaInfo();
                    

                    // 429: 하루 무료 사용량 초과
                    if (res.status === 429) {
                        let detail = data.detail;

                        // detail 이 문자열이든 객체든 모두 처리
                        let code = null;
                        let usageFromServer = null;
                        let limitFromServer = null;

                        if (typeof detail === "string") {
                            code = detail;
                        } else if (detail && typeof detail === "object") {
                            code = detail.code || detail.detail || "";
                            if (typeof detail.usage_count === "number") {
                                usageFromServer = detail.usage_count;
                            }
                            if (typeof detail.daily_free_limit === "number") {
                                limitFromServer = detail.daily_free_limit;
                            }
                        }

                        code = (code || "").toString().toUpperCase();

                        if (code === "DAILY_LIMIT_EXCEEDED") {
                            if (!isTestUser) {
                                if (usageFromServer != null) {
                                    window.__serverUsageCount = usageFromServer;
                                }
                                if (limitFromServer != null) {
                                    window.__dailyFreeLimit = limitFromServer;
                                }
                                updateQuotaInfo();
                            }

                            setStatus(
                                "error",
                                `Daily free limit reached (${window.__dailyFreeLimit ?? DAILY_FREE_LIMIT} diagrams per day, up to ${FREE_NODE_LIMIT} nodes). Please try again tomorrow.`
                            );
                            chartInner.innerHTML = `
                                <p class="placeholder" style="color:#b91c1c;">
                                    Daily free limit reached. Please try again tomorrow.
                                </p>`;
                            currentFunc.textContent = "";

                            // ✅ 로그인 상태에서만 업그레이드 유도 (표시/블링크는 단일 함수로)
                            applyUpgradeButtonUI(null, { forceBlink: true });
                            return;
                        }
                    }

                    const errorCode = (data.error_code || data.error || "").toString().toUpperCase();
                    if (errorCode === "TOO_MANY_NODES") {
                        // 플랜/노드 한도 계산
                        const tier = window.__planTier || (window.__isProUser ? "pro" : "free");
                        const isTestAccount = !!window.__isTestAccount;

                        let nodeLimit = window.__nodeLimit;
                        if (!Number.isFinite(nodeLimit)) {
                            if (isTestAccount) {
                                nodeLimit = Infinity; // 테스트 계정은 사실상 무제한, 여기 걸리면 엔진 자체 상한
                            } else if (tier === "expert") {
                                nodeLimit = EXPERT_NODE_LIMIT;
                            } else if (window.__isProUser) {
                                nodeLimit = PRO_NODE_LIMIT;
                            } else {
                                nodeLimit = FREE_NODE_LIMIT;
                            }
                        }

                        // 백엔드에서 보내줄 수도 있는 실제 노드 수 (없으면 null)
                        const nodeCountFromServer =
                            typeof data.node_count === "number"
                                ? data.node_count
                                : (typeof data.actual_nodes === "number"
                                    ? data.actual_nodes
                                    : null);

                        let msgText = "";
                        let bannerText = "";

                        if (isTestAccount || !Number.isFinite(nodeLimit)) {
                            // 테스트 계정 + 엔진 글로벌 상한 등에 걸린 진짜 "너무 큼" 케이스
                            msgText = mapBackendError(errorCode, data.error);
                            bannerText = msgText;
                        } else if (tier === "expert") {
                            msgText = `This function has ${nodeCountFromServer ?? "too many"} nodes. The Expert plan supports up to ${nodeLimit} nodes per diagram.`;
                            bannerText = `Expert plan supports up to ${nodeLimit} nodes per diagram.`;
                        } else if (window.__isProUser) {
                            // 🔹 Pro 유저
                            msgText = `This function has ${nodeCountFromServer ?? "too many"} nodes. The Pro plan supports up to ${nodeLimit} nodes per diagram.`;
                            bannerText = `Pro plan supports up to ${nodeLimit} nodes per diagram.`;
                        } else {
                            // 🔹 Free 유저
                            msgText = `This function has ${nodeCountFromServer ?? "too many"} nodes. The free tier supports up to ${nodeLimit} nodes per diagram.`;
                            bannerText = `Free tier supports up to ${nodeLimit} nodes per diagram.`;
                        }

                        setStatus("error", msgText);

                        // ✅ in-flight 응답이 돌아왔을 때 이미 legal 모드면, 화면 덮어쓰기 금지
                        if (window.__isLegalMode) return;
                        
                        chartInner.innerHTML = `
                            <p class="placeholder" style="color:#b91c1c;">
                                ${bannerText}
                            </p>`;
                        currentFunc.textContent = "";

                        // free 또는 pro (expert 미만) 계정에서 UPGRADE 버튼 깜빡임
                        const ub = document.getElementById("upgradeButton");
                        if (ub && !isTestAccount && tier !== "expert") {
                            ub.classList.add("upgrade-blink");
                        }

                        return;
                    }

                    // 그 외 일반 서버 에러
                    setStatus("error", `Temporary server issue (${res.status}). Please try again later.`);
                    chartInner.innerHTML = '<p class="placeholder">A server error occurred.</p>';
                    currentFunc.textContent = "";
                    return;
                }
                
                const data = await res.json();
                let mermaidCode = data.mermaid || "";
                // ✅ 백엔드/중간 경로에서 escape가 2중으로 된 경우(&amp;amp;)까지 풀어줌
                mermaidCode = decodeHtmlEntitiesDeep(mermaidCode, 3);
                if (mermaidCode.includes("&amp;")) {
                  console.warn("⚠️ Mermaid code still contains &amp; after decode");
                }
                                

                window.__lastMermaidCode = mermaidCode;   // (Share에서 사용)
                window.__lastShareId = null; // 새로 생성되면 갱신
                
                const errorMsg      = data.error || "";
                const errorCode     = data.error_code || "";
                const funcName      = data.func_name || "";
                const fullSignature = data.full_signature || "";
                const nodeLines     = data.node_lines || {};

                // 백엔드에서 온 계정 상태 반영
                window.__isProUser      = !!data.is_pro_user;          // Pro + Expert 모두 true
                window.__planName       = data.plan_name || null;
                window.__isTestAccount  = !!data.is_test_account;
                window.__planTier       = data.plan_tier || null;      // "free" | "pro" | "expert"
                window.__nodeLimitFromServer = data.node_limit ?? null;
                window.__planLoading    = false;                       // 🔹 여기서도 로딩 종료

                // 플랜별 노드 제한 (클라이언트 기준)
                // - 테스트 계정: 사실상 무제한
                let effectiveNodeLimit = FREE_NODE_LIMIT;
                if (window.__isTestAccount) {
                    effectiveNodeLimit = Infinity;              // test account: no limit
                } else if (window.__planTier === "expert") {
                    effectiveNodeLimit = EXPERT_NODE_LIMIT;
                } else if (window.__isProUser) {
                    effectiveNodeLimit = PRO_NODE_LIMIT;
                } else {
                    effectiveNodeLimit = FREE_NODE_LIMIT;
                }

                // 서버에서 node_limit 를 보내주면 그 값 우선 사용
                if (typeof data.node_limit === "number") {
                    effectiveNodeLimit = data.node_limit;
                }
                window.__nodeLimit = effectiveNodeLimit;

                applyUpgradeButtonUI(); // nodeCount 계산 전이라도 UPGRADE 표시/숨김은 정리됨

                // 서버에서 내려준 사용량 정보 (일반 계정인 경우)
                if (!isTestUser && typeof data.usage_count === "number") {
                    window.__serverUsageCount = data.usage_count;
                }
                if (!isTestUser && typeof data.daily_free_limit === "number") {
                    window.__dailyFreeLimit = data.daily_free_limit;
                }

                if (errorMsg) {
                    const uiMsg = mapBackendError(errorCode, errorMsg);
                    setStatus("error", uiMsg);
                    chartInner.innerHTML = `<p class="placeholder" style="color:#b91c1c;">${uiMsg}</p>`;
                    currentFunc.textContent = "";

                    // ✅ [ADD] 제한/업그레이드 유도성 에러면 UPGRADE 버튼 표시 + 블링크
                    const codeUpper = (errorCode || "").toString().toUpperCase();
                    if (!isTestUser && ["TOO_MANY_NODES", "DAILY_LIMIT_EXCEEDED"].includes(codeUpper)) {
                      applyUpgradeButtonUI(undefined, { forceBlink: true });
                    }
                    
                    return;
                }

                const nodeCount = Object.keys(nodeLines).length;
                window.__nodeCount = nodeCount;

                // ✅ Pro: 노드 200 이상이면 UPGRADE 버튼 blink
                applyUpgradeButtonUI(nodeCount);
                
                window.__nodeLines = nodeLines;

                const codeHeader = document.getElementById("codeHeader");
                if (codeHeader) {
                    codeHeader.innerHTML = `
                        <span>mAutoFlow</span>
                        <span style="opacity:0.7;">Nodes: ${nodeCount}</span>`;
                }

                // 노드 제한 (테스트 계정은 무제한)
                // - Free   : 최대 FREE_NODE_LIMIT
                // - Pro    : 최대 PRO_NODE_LIMIT
                // - Expert : 최대 EXPERT_NODE_LIMIT
                if (!isTestUser) {
                    const tier = window.__planTier;

                    // 서버가 node_limit 를 내려주면 그 값을 우선 사용
                    let nodeLimit = window.__nodeLimit;
                    if (!Number.isFinite(nodeLimit)) {
                        if (window.__isTestAccount) {
                            nodeLimit = Infinity;                // 테스트 계정 무제한
                        } else if (tier === "expert") {
                            nodeLimit = EXPERT_NODE_LIMIT;
                        } else if (window.__isProUser) {
                            nodeLimit = PRO_NODE_LIMIT;
                        } else {
                            nodeLimit = FREE_NODE_LIMIT;
                        }
                    }

                    // nodeLimit 이 유한한 값일 때만 초과 체크
                    if (Number.isFinite(nodeLimit) && nodeCount > nodeLimit) {
                        let msgText = "";
                        let bannerText = "";

                        if (tier === "expert") {
                            // Expert 유저
                            msgText = `This function has ${nodeCount} nodes. The Expert plan supports up to ${nodeLimit} nodes per diagram.`;
                            bannerText = `Expert plan supports up to ${nodeLimit} nodes per diagram.`;
                        } else if (window.__isProUser) {
                            // Pro 유저
                            msgText = `This function has ${nodeCount} nodes. The Pro plan supports up to ${nodeLimit} nodes per diagram.`;
                            bannerText = `Pro plan supports up to ${nodeLimit} nodes per diagram.`;
                        } else {
                            // Free 유저
                            msgText = `This function has ${nodeCount} nodes. The free tier supports up to ${nodeLimit} nodes per diagram.`;
                            bannerText = `Free tier supports up to ${nodeLimit} nodes per diagram.`;
                        }

                        setStatus("error", msgText);

                        // ✅ in-flight 응답이 돌아왔을 때 이미 legal 모드면, 화면 덮어쓰기 금지
                        if (window.__isLegalMode) return;
                        
                        chartInner.innerHTML = `
                            <p class="placeholder" style="color:#b91c1c;">
                                ${bannerText}
                            </p>`;
                        currentFunc.textContent = "";

                        // UPGRADE 버튼 파스텔 연두색 블링크
                        // - Free : Pro로 업그레이드 유도
                        // - Pro  : Expert로 업그레이드 유도
                        applyUpgradeButtonUI(nodeCount, { forceBlink: true });

                        return;
                    }
                }

                // ✅ in-flight 응답이 돌아왔을 때 이미 legal 모드면, 화면 덮어쓰기 금지
                if (window.__isLegalMode) return;
                
                // 정상 플로우차트 생성
                chartInner.innerHTML = `<div class="mermaid">${mermaidCode}</div>`;

                try {
                  await mermaid.parse(mermaidCode);
                  await mermaid.init(undefined, chartInner.querySelector(".mermaid"));
                } catch (e) {
                  console.error("Mermaid render failed:", e);
                  setStatus("error", `Mermaid render failed: ${e?.message || e}`);
                  chartInner.innerHTML = `
                    <p class="placeholder" style="color:#b91c1c;">
                      Mermaid render failed: ${e?.message || e}
                    </p>`;
                  currentFunc.textContent = "";
                  return;
                }

                applyDiagramZoom();
                setTimeout(attachNodeClickHandlers, 50);

                // 사용량 증가 (클라이언트 기준, 테스트 계정 제외)
                if (!isTestUser) {
                    // 같은 코드인지 비교 용도만 필요하면 이 정도만
                    lastCountedSource = src;
                }

                // 사용량 증가 없이, 메시지만 표시
                // ✅ 여기서 플로우차트가 "성공적으로" 생성되면
                //    UPGRADE 버튼 깜빡임은 항상 끈다.
                if (!isTestUser) {
                    const ub = document.getElementById("upgradeButton");
                    if (ub) ub.classList.remove("upgrade-blink");

                    if (window.__planTier === "expert") {
                        setStatus(
                            "success",
                            `${auto ? "Refresh complete." : "Flowchart creation complete."} Expert plan: up to ${EXPERT_NODE_LIMIT} nodes per diagram.`
                        );
                    } else if (window.__isProUser) {
                        setStatus(
                            "success",
                            `${auto ? "Refresh complete." : "Flowchart creation complete."} Pro plan: up to ${PRO_NODE_LIMIT} nodes per diagram.`
                        );
                    } else {
                        // Free 유저: 가능하면 오늘 사용량 표시
                        const count = window.__serverUsageCount;
                        const limit = window.__dailyFreeLimit;

                        if (typeof count === "number" && typeof limit === "number") {
                            setStatus(
                                "success",
                                `Refresh complete. Free tier: Today ${count} / ${limit} (≤ ${FREE_NODE_LIMIT} nodes).`
                            );
                        } else {
                            setStatus(
                                "success",
                                `Refresh complete. Free tier: 5 diagrams/day, ≤ ${FREE_NODE_LIMIT} nodes.`
                            );
                        }
                    }
                } else {
                    setStatus(
                        "success",
                        `${auto ? "Refresh Complete." : "Flowchart creation complete."} (Test account: unlimited)`
                    );

                    const ub = document.getElementById("upgradeButton");
                    if (ub) ub.classList.remove("upgrade-blink");
                }

                // Function name 출력 방식 반영 (Short / Full)
                let displayName = funcName;
                if (funcNameStyle === "full" && fullSignature) {
                    displayName = fullSignature;
                }

                currentFunc.textContent = displayName ? `Function: ${displayName}` : "";

                // 상단 무료 정책 안내 갱신
                updateQuotaInfo();

            } catch (err) {
                console.error(err);
                const msg = "An unexpected error occurred while talking to the server. Please try again.";
                setStatus("error", msg);
                chartInner.innerHTML = `<p class="placeholder" style="color:#b91c1c;">${msg}</p>`;
                currentFunc.textContent = "";
            }
        }

        function setupSplitDrag() {
            const main = document.querySelector(".main");
            const leftPane = document.getElementById("leftPane");
            const rightPane = document.getElementById("rightPane");
            const divider = document.getElementById("divider");

            let isDragging = false;

            divider.addEventListener("mousedown", function(e) {
                e.preventDefault();
                isDragging = true;
                document.body.style.cursor = "col-resize";
            });

            document.addEventListener("mousemove", function(e) {
                if (!isDragging) return;
                const rect = main.getBoundingClientRect();
                const totalWidth = rect.width;
                let offsetX = e.clientX - rect.left;
                // 최소/최대 비율 제한 (20% ~ 70%)
                let leftPercent = Math.max(0.2, Math.min(0.7, offsetX / totalWidth));
                let rightPercent = 1 - leftPercent;

                leftPane.style.flex = "0 0 " + (leftPercent * 100).toFixed(1) + "%";
                rightPane.style.flex = "0 0 " + (rightPercent * 100).toFixed(1) + "%";
            });

            document.addEventListener("mouseup", function() {
                if (isDragging) {
                    isDragging = false;
                    document.body.style.cursor = "default";
                }
            });
        }


        function initSettingsRadios(root) {
            const scope = root || document;

            // ----- Theme -----
            let savedTheme = "classic";
            try {
                const t = localStorage.getItem("autoflow-theme");
                if (t) savedTheme = t;
            } catch (e) {}
            applyTheme(savedTheme);

            const themeRadios = scope.querySelectorAll('input[name="theme"]');
            themeRadios.forEach(r => {
                if (r.value === savedTheme) {
                    r.checked = true;
                }
                r.addEventListener("change", (e) => {
                    if (e.target.checked) {
                        applyTheme(e.target.value);
                        try {
                            localStorage.setItem("autoflow-theme", e.target.value);
                        } catch (e2) {}
                        // 필요하면 자동 재생성
                        // generateFlowchart(true);
                    }
                });
            });

            // ----- Branch Shape -----
            let savedBranchShape = "rounded";
            try {
                const bs = localStorage.getItem("autoflow-branch-shape");
                if (bs) savedBranchShape = bs;
            } catch (e) {}
            currentBranchShape = savedBranchShape;

            const branchRadios = scope.querySelectorAll('input[name="branchShape"]');
            branchRadios.forEach(r => {
                if (r.value === savedBranchShape) {
                    r.checked = true;
                }
                r.addEventListener("change", (e) => {
                    if (e.target.checked) {
                        currentBranchShape = e.target.value;
                        try {
                            localStorage.setItem("autoflow-branch-shape", currentBranchShape);
                        } catch (e2) {}

                        // 필요하면 테마처럼 자동 재생성도 가능:
                        generateFlowchart(true);
                    }
                });
            });

            // ----- Function Name Display -----
            try {
                const savedStyle = localStorage.getItem("autoflow-funcname-style");
                if (savedStyle) funcNameStyle = savedStyle;
            } catch (e){}

            const funcNameRadios = scope.querySelectorAll('input[name="funcNameStyle"]');
            funcNameRadios.forEach(r => {
                if (r.value === funcNameStyle) {
                    r.checked = true;
                }
                r.addEventListener("change", (e) => {
                    if (e.target.checked) {
                        funcNameStyle = e.target.value;
                        localStorage.setItem("autoflow-funcname-style", funcNameStyle);
                        generateFlowchart(true);
                    }
                });
            });

            // ----- Preprocessor Macros (-D) -----
            // macroMode = "all";
            // macroDefines = "";

            const macroModeRadios = scope.querySelectorAll('input[name="macroMode"]');
            const macroField = scope.querySelector("#macroInput");

            function applyMacroUIState() {
              if (!macroField) return;
              if (macroMode === "defined") {
                macroField.disabled = false;
                // ✅ Defined로 들어오면 현재 UI값을 전역에도 반영
                macroDefines = (macroField.value || "").trim();
              } else {
                macroField.disabled = true;
                macroField.value = "";
                macroDefines = "";
                try { localStorage.removeItem("autoflow-macros"); } catch(e) {}
              }
            }

            // 라디오 이벤트
            macroModeRadios.forEach(r => {
              if (r.value === macroMode) r.checked = true;

              r.addEventListener("change", (e) => {
                if (!e.target.checked) return;

                const nextMode = e.target.value; // all | defined

                // ✅ 로그아웃 상태면 Defined 금지 (로그인 + Pro/Expert 필요 안내)
                if (nextMode === "defined" && !window.currentUser) {
                  // 1) 라디오 선택 되돌리기 (Defined 선택 무효화)
                  macroMode = "all";
            
                  const allRadio = scope.querySelector('input[name="macroMode"][value="all"]');
                  const defRadio = scope.querySelector('input[name="macroMode"][value="defined"]');
                  if (defRadio) defRadio.checked = false;
                  if (allRadio) allRadio.checked = true;
            
                  // 2) 입력창 잠그고 값 정리
                  if (macroField) {
                    macroField.disabled = true;
                    macroField.value = "";
                  }
                  macroDefines = "";
                  try { localStorage.removeItem("autoflow-macros"); } catch (_) {}
            
                  // 3) 경고(로그인 + Pro/Expert 필요)
                  alert("Please log in to use Macro Defines (Defined mode).\n(Macro Defines is available on Pro/Expert.)");
                  return;
                }           

                // ✅ Lite(=free) 계정에서는 Defined 금지
                const tier = window.__planTier || (window.__isProUser ? "pro" : "free");
                const isTest = !!window.__isTestAccount || (window.currentUser && window.currentUser.email === TEST_EMAIL);
                const isLite = (!isTest && tier === "free");

                if (nextMode === "defined" && isLite) {
                  // 1) 라디오 선택 되돌리기 (Defined 선택 무효화)
                  macroMode = "all";

                  // scope 안에서 라디오를 다시 체크 (openSettings clone에서도 동작)
                  const allRadio = scope.querySelector('input[name="macroMode"][value="all"]');
                  const defRadio = scope.querySelector('input[name="macroMode"][value="defined"]');
                  if (defRadio) defRadio.checked = false;
                  if (allRadio) allRadio.checked = true;

                  // 2) 입력창 잠그고 값 정리
                  if (macroField) {
                    macroField.disabled = true;
                    macroField.value = "";
                  }
                  macroDefines = "";
                  try { localStorage.removeItem("autoflow-macros"); } catch (_) {}

                  // 3) 경고 + 업그레이드 유도
                  showMacroUpgradePrompt();
                  return;
                }

                // ✅ 허용되는 계정이면 정상 동작
                macroMode = nextMode;
                applyMacroUIState();
                generateFlowchart(true);
              });
            });

            // textarea 입력 이벤트 (Defined일 때만 의미)
            if (macroField) {
              // ✅ (1) 초기화 금지: 기존 값 복원
              // 우선순위: 현재 전역 macroDefines -> localStorage -> ""
              let saved = "";
              try { saved = localStorage.getItem("autoflow-macros") || ""; } catch (e) {}
              const restored = (macroDefines && macroDefines.trim().length > 0)
                ? macroDefines
                : saved;

              macroField.value = restored;

              // ✅ (2) 중복 이벤트 방지 (initSettingsRadios가 여러 번 호출됨)
              if (!macroField.__autoflowBound) {
                macroField.__autoflowBound = true;
                macroField.addEventListener("input", (e) => {
                  macroDefines = (e.target.value || "").trim();
                  try { localStorage.setItem("autoflow-macros", macroDefines); } catch (e2) {}
                  generateFlowchart(true);
                });
              }
            }

            applyMacroUIState();

            // ----- Download Options (SVG/PNG) -----
            try {
              const savedFmt = localStorage.getItem("autoflow-download-format");
              downloadFormat = (savedFmt === "png") ? "png" : "svg";
            } catch (e) {
              downloadFormat = "svg";
            }

            const dlRadios = scope.querySelectorAll('input[name="downloadFormat"]');
            dlRadios.forEach(r => {
              r.checked = (r.value === downloadFormat);

              r.addEventListener("change", () => {
                downloadFormat = (r.value === "png") ? "png" : "svg";
                try { localStorage.setItem("autoflow-download-format", downloadFormat); } catch(e2) {}
              });
            });

            // ----- PNG Options (Scale / Background) -----
            const pngScaleEl   = scope.querySelector("#pngScale");
            const pngBgEl      = scope.querySelector("#pngBg");

            // ✅ 저장값 복원
            if (pngScaleEl) {
              let savedScale = "2";
              try { savedScale = localStorage.getItem("autoflow-png-scale") || "2"; } catch (e) {}
              pngScaleEl.value = String(parseFloat(savedScale) || 2);

              // ✅ 중복 바인딩 방지
              if (!pngScaleEl.__autoflowBound) {
                pngScaleEl.__autoflowBound = true;
                pngScaleEl.addEventListener("change", () => {
                  const v = parseFloat(pngScaleEl.value || "2");
                  const safe = (Number.isFinite(v) && v > 0) ? v : 2;
                  try { localStorage.setItem("autoflow-png-scale", String(safe)); } catch (e) {}
                });
              }
            }

            if (pngBgEl) {
              let savedBg = "white";
              try { savedBg = localStorage.getItem("autoflow-png-bg") || "white"; } catch (e) {}
              savedBg = String(savedBg || "white").toLowerCase().trim();
              pngBgEl.value = (savedBg === "transparent") ? "transparent" : "white";

              // ✅ 중복 바인딩 방지
              if (!pngBgEl.__autoflowBound) {
                pngBgEl.__autoflowBound = true;
                pngBgEl.addEventListener("change", () => {
                  const v = String(pngBgEl.value || "white").toLowerCase().trim();
                  const safe = (v === "transparent") ? "transparent" : "white";
                  try { localStorage.setItem("autoflow-png-bg", safe); } catch (e) {}
                });
              }
            }
        }

        function initAnimatedLogo() {
          const el = document.getElementById("logo");
          if (!el) return;

          const text = "mAutoFlow";
          el.innerHTML = "";

          // 전역으로 레퍼런스 저장 (시나리오에서 사용)
          window.__logoMap = {};

          [...text].forEach((ch, i) => {
            const sp = document.createElement("span");
            sp.className = "logo-letter";
            sp.textContent = ch;
            sp.dataset.ch = ch;
            sp.style.animationDelay = `${i * 0.08}s`;

            // ✅ 시나리오 루프 클래스 부여
            if (ch === "w") {
              sp.classList.add("w-loop");
              sp.style.setProperty("--wDriftX", "70px"); // 원하는 만큼 조절
            }
            if (ch === "m" || ch === "A") {
              sp.classList.add("ma-loop");
            }

            // ✅ flip은 기본에서 제거 (이제 "스냅 순간"에만 ma-spin으로 돌릴 거라서)
            // if (ch === "m" || ch === "A") sp.classList.add("flip");

            el.appendChild(sp);

            // 같은 글자가 여러 번 나오면 배열로 관리 (o가 2개라서)
            if (!window.__logoMap[ch]) window.__logoMap[ch] = [];
            window.__logoMap[ch].push(sp);
          });
        }


        function runLogoScenario() {
          const map = window.__logoMap || {};
          const m = map["m"]?.[0];
          const A = map["A"]?.[0];
          const w = map["w"]?.[0];

          // o는 2개(o, o)니까 "w가 붙을 대상"을 두 번째 o로 잡는 걸 추천
          // mAutoFlow = m A u t o F l o w
          //                (첫 o)     (둘째 o) w
          const o = map["o"]?.[1] || map["o"]?.[0];

          if (!m || !A || !w || !o) return;

          // 1) w가 오른쪽으로 살짝 멀어지게 (드리프트 거리)
          w.style.setProperty("--wDriftX", "70px");

          // 2) 드리프트 시작
          w.classList.remove("w-snap");
          w.classList.add("w-drift");

          // 3) 드리프트가 끝나면: w를 o 옆으로 snap + 그 순간 mA 1회 회전
          // 변경 (✅ 좌표 계산 제거 + snap 끝나면 w 상태 정리)
          window.setTimeout(() => {
            // ✅ 이제 snap은 “원래 자리로 복귀(left:0)”만 하면 됨
            w.classList.remove("w-drift");
            w.classList.add("w-snap");

            // mA 1회 회전 트리거
            m.classList.remove("ma-spin");
            A.classList.remove("ma-spin");
            void m.offsetWidth;
            void A.offsetWidth;
            m.classList.add("ma-spin");
            A.classList.add("ma-spin");

            // ✅ snap(120ms) 끝나면 w-snap 제거해서 상태를 깨끗하게 복구
            window.setTimeout(() => {
              w.classList.remove("w-snap");
              // (선택) 혹시 남아있을 inline left 변형이 걱정되면 완전 초기화
              // w.style.left = "0px";  // 필요 시만
            }, 160);

            // 1회 회전 끝나면 ma-spin 제거
            window.setTimeout(() => {
              m.classList.remove("ma-spin");
              A.classList.remove("ma-spin");
            }, 950);
          }, 1200);
        }
            

        document.addEventListener("DOMContentLoaded", async function() {
            const src = document.getElementById("src");
            const lineNumbers = document.getElementById("lineNumbers");

            initAnimatedLogo();   // 로고 span 생성 + 애니메이션 적용
            // runLogoScenario();    // w 이동 → o 스냅 → mA 1회 회전 트리거

            // 라인 번호 업데이트 함수
            function updateLineNumbers() {
                if (!src || !lineNumbers) return;
                const lines = src.value.split("\n").length || 1;
                let html = "";
                for (let i = 1; i <= lines; i++) {
                    html += i + "<br>";
                }
                lineNumbers.innerHTML = html;
            }

            // 이벤트 연결 (입력/스크롤)
            if (src && lineNumbers) {
                src.addEventListener("input", updateLineNumbers);
                src.addEventListener("scroll", () => {
                    lineNumbers.scrollTop = src.scrollTop;  // 스크롤 동기화
                });
                updateLineNumbers(); // 초기 1,2,3,... 표시
            }

            // ✅ 공유 링크로 들어온 경우: /share/<id> mermaid_code 로드해서 바로 렌더
            const shareId = getShareIdFromPath();
            if (shareId) {
                applyShareViewMode();

                // ✅ (추가) 공유 페이지에서도 Ctrl+휠 줌/드래그 패닝 이벤트를 등록
                initChartInteractions();
                
                await loadSharedDiagram(shareId);
                return; // 공유 페이지에서는 일반 초기 플로우차트 생성 흐름을 타지 않게 종료
            }

            // ✅ 라우팅은 한 군데(handleRoute)에서만 처리
            handleRoute();
            

            // SETTINGS 라디오들 초기화 (기본은 모달 DOM 기준)
            initSettingsRadios(document);

            // ============================
            // SETTINGS 모달 드래그
            // ============================
            const settingsOverlay = document.getElementById("settingsOverlay");
            const settingsPanel = settingsOverlay
                ? settingsOverlay.querySelector(".modal-panel")
                : null;
            const settingsHeader = settingsPanel
                ? settingsPanel.querySelector(".modal-header")
                : null;       

            let isDraggingSettings = false;
            let dragStartX = 0;
            let dragStartY = 0;
            let panelStartLeft = 0;
            let panelStartTop = 0;

            if (settingsHeader && settingsPanel) {
                // 헤더에 마우스 아이콘 변경
                settingsHeader.style.cursor = "move";

                // 드래그 시작
                settingsHeader.addEventListener("mousedown", function (e) {
                    if (e.button !== 0) return; // 왼쪽 버튼만
                    isDraggingSettings = true;

                    const rect = settingsPanel.getBoundingClientRect();
                    dragStartX = e.clientX;
                    dragStartY = e.clientY;
                    panelStartLeft = rect.left;
                    panelStartTop = rect.top;

                    // 뷰포트 기준 고정 위치
                    settingsPanel.style.position = "fixed";
                    settingsPanel.style.left = `${panelStartLeft}px`;
                    settingsPanel.style.top = `${panelStartTop}px`;

                    e.preventDefault(); // 텍스트 선택 방지
                });
            }

            // 드래그 중
            document.addEventListener("mousemove", function (e) {
                if (!isDraggingSettings || !settingsPanel) return;

                const dx = e.clientX - dragStartX;
                const dy = e.clientY - dragStartY;

                let newLeft = panelStartLeft + dx;
                let newTop  = panelStartTop + dy;

                // 화면 밖으로 안 나가도록 제한
                const maxLeft = window.innerWidth - settingsPanel.offsetWidth;
                const maxTop  = window.innerHeight - settingsPanel.offsetHeight;

                if (newLeft < 0) newLeft = 0;
                if (newTop < 0) newTop = 0;
                if (newLeft > maxLeft) newLeft = maxLeft;
                if (newTop > maxTop) newTop = maxTop;

                settingsPanel.style.left = `${newLeft}px`;
                settingsPanel.style.top  = `${newTop}px`;
            });

            // 드래그 종료
            document.addEventListener("mouseup", function () {
                isDraggingSettings = false;
            });

            // ============================
            // SHARE 모달 드래그
            // ============================
            const shareOverlayDrag = document.getElementById("shareOverlay");
            const sharePanel = shareOverlayDrag
              ? shareOverlayDrag.querySelector(".modal-panel")
              : null;
            const shareHeader = sharePanel
              ? sharePanel.querySelector(".modal-header")
              : null;

            let isDraggingShare = false;
            let shareStartX = 0;
            let shareStartY = 0;
            let sharePanelStartLeft = 0;
            let sharePanelStartTop = 0;

            if (shareHeader && sharePanel) {
              shareHeader.style.cursor = "move";

              shareHeader.addEventListener("mousedown", function (e) {
                if (e.button !== 0) return; // 왼쪽 버튼만
                isDraggingShare = true;

                const rect = sharePanel.getBoundingClientRect();
                shareStartX = e.clientX;
                shareStartY = e.clientY;
                sharePanelStartLeft = rect.left;
                sharePanelStartTop = rect.top;

                // 뷰포트 기준 고정 위치
                sharePanel.style.position = "fixed";
                sharePanel.style.left = `${sharePanelStartLeft}px`;
                sharePanel.style.top = `${sharePanelStartTop}px`;

                e.preventDefault(); // 텍스트 선택 방지
              });
            }

            document.addEventListener("mousemove", function (e) {
              if (!isDraggingShare || !sharePanel) return;

              const dx = e.clientX - shareStartX;
              const dy = e.clientY - shareStartY;

              let newLeft = sharePanelStartLeft + dx;
              let newTop  = sharePanelStartTop + dy;

              const maxLeft = window.innerWidth - sharePanel.offsetWidth;
              const maxTop  = window.innerHeight - sharePanel.offsetHeight;

              if (newLeft < 0) newLeft = 0;
              if (newTop < 0) newTop = 0;
              if (newLeft > maxLeft) newLeft = maxLeft;
              if (newTop > maxTop) newTop = maxTop;

              sharePanel.style.left = `${newLeft}px`;
              sharePanel.style.top  = `${newTop}px`;
            });

            document.addEventListener("mouseup", function () {
              isDraggingShare = false;
            });


            updateZoomLabel();
            setupSplitDrag();
            initChartInteractions();

            // 코드 → 노드 하이라이트 연동
            ["click", "keyup", "mouseup"].forEach(ev => {
                src.addEventListener(ev, updateNodeHighlightFromCaret);
            });                       


            // 타이핑 자동 업데이트 (debounce)
            src.addEventListener("input", function() {
                // ✅ (여기!) 소스가 바뀌면 Macro 설정 초기화 (All 기본으로)
                macroMode = "all";
                macroDefines = "";
                try { localStorage.removeItem("autoflow-macros"); } catch(e) {}

                const allRadio = document.querySelector('input[name="macroMode"][value="all"]');
                const macroField = document.getElementById("macroInput");
                if (allRadio) allRadio.checked = true;
                if (macroField) {
                    macroField.value = "";
                    macroField.disabled = true;
                }

                if (typingTimer) clearTimeout(typingTimer);
                typingTimer = setTimeout(function() {
                    generateFlowchart(true);
                }, TYPING_DELAY_MS);
            });

            // ✅ SHARE: 바깥 클릭하면 닫기
            const shareOverlay = document.getElementById("shareOverlay");
            if (shareOverlay) {
              shareOverlay.addEventListener("mousedown", (e) => {
                // overlay(회색 배경) 자체를 찍었을 때만 닫기
                if (e.target === shareOverlay) closeShare();
              });
            }
            
            // 코드 클릭/이동 시 → 해당 라인 노드 하이라이트
            src.addEventListener("click", updateNodeHighlightFromCaret);
            src.addEventListener("keyup", updateNodeHighlightFromCaret);
            src.addEventListener("mouseup", updateNodeHighlightFromCaret);
        });
    </script>
</head>
<body>
    <header>
        <div>
            <h1 id="logo" class="logo" aria-label="mAutoFlow"></h1>
        </div>

        <!-- 오른쪽 상단 메뉴: 로그인 + 버튼 + 백엔드 버전 -->
        <div class="topbar-right">
            <!-- ✅ EDIT(복귀) 버튼 -->
            <button id="editButton" class="btn-settings" style="display:none;" onclick="goBackToEditor()">
              GET STARTED
            </button>

            <!-- 로그인 영역 -->
            <span id="welcomeText" style="margin-right:8px;"></span>

            <div id="loggedOutButtons" style="display:inline-flex; gap:4px; margin-right:8px;">
              <button class="btn-settings" onclick="loginWithGoogle()">Login with Google</button>
            </div>

            <div id="loggedInButtons" style="display:none; gap:4px; margin-right:8px;">
              <button class="btn-settings" onclick="logout()">Logout</button>
            </div>

            <!-- 기능 버튼들 -->
            <button id="upgradeButton" class="btn-settings" onclick="openProCheckout()">
                UPGRADE
            </button>

            <!-- DOWNLOAD 왼쪽 -->
            <button class="btn-settings" onclick="openShare()">SHARE</button>            
            <button class="btn-settings" onclick="downloadDiagram()">DOWNLOAD</button>         
            <button class="btn-settings" onclick="openSettings()">SETTINGS</button>
            <button id="helpToggleBtn" class="btn-settings" onclick="toggleHelp()">HELP</button>
        </div>
    </header>
    <div class="main">
        <div id="leftPane">
            <div class="pane-header">
                <span class="pane-title">Source Code</span>
            </div>
            <div id="codeContainer">
                <div id="codeHeader">
                    <span>mAutoFlow</span>
                    <span style="opacity:0.7;">Automatic Analysis</span>
                </div>
                <div id="codeArea">
                    <div id="lineNumbers"></div>
                    <textarea id="src" spellcheck="false" placeholder="Example:
void main(void)
{
    int x = 0;

    if (x == 0)
    {
        x++;
    }
    else
    {
        x--;
    }
}"></textarea>
                </div>
            </div>
        </div>

        <div id="divider"></div>

        <div id="rightPane">
            <div class="pane-header">
                <span class="pane-title">Flowchart</span>
                <div style="display:flex; align-items:center; gap:6px;">
                    <button class="btn btn-ghost" onclick="zoomChange(-0.1)">−</button>
                    <button class="btn btn-ghost" onclick="zoomReset()">100%</button>
                    <button class="btn btn-ghost" onclick="zoomChange(0.1)">+</button>
                    <span class="zoom-label" id="zoomLabel"></span>
                </div>
            </div>
            <div id="toolbar">
                <button class="btn btn-primary" onclick="generateFlowchart(false)">Regenerate Now</button>
                <span id="currentFunc"></span>
                <span id="status"></span>
                <span id="quotaInfo" style="margin-left:8px; font-size:12px; opacity:0.8;"></span>
            </div>
            <div id="chartContainer">
                <div id="chartInner">
                    <p class="placeholder">
                        When you enter C code on the left, a flowchart is automatically generated on the right.
                    </p>
                </div>
            </div>
        </div>
    </div>
    
    <!-- SETTINGS 모달: 여기 추가 -->
    <div id="settingsOverlay" class="modal-overlay modal-hidden">
        <div class="modal-panel">
            <div class="modal-group-title">Display Options</div>
            <!-- Theme 섹션 -->
            <div class="modal-section"> <!-- Theme -->
                <div class="modal-section-title">Theme</div>
                <div class="modal-radio-row">
                    <label>
                        <input type="radio" name="theme" value="classic" checked />
                        Classic
                    </label>
                    <label>
                        <input type="radio" name="theme" value="light" />
                        Light
                    </label>
                    <label>
                        <input type="radio" name="theme" value="dark" />
                        Dark
                    </label>
                </div>
            </div>

            <!-- Branch Shape 섹션 복구 -->
            <div class="modal-section"> <!-- Branch Shape -->
                <div class="modal-section-title">Branch Shape</div>
                <div class="modal-radio-row">
                      <label><input type="radio" name="branchShape" value="rounded" checked> Rounded</label>
                      <label><input type="radio" name="branchShape" value="diamond"> Diamond</label>
                      <label><input type="radio" name="branchShape" value="hexagon"> Hexagon</label>
                      <label><input type="radio" name="branchShape" value="parallelogram"> Parallelogram</label>
                </div>
            </div>

            <!-- Function Name Display 섹션 -->
            <div class="modal-section"> <!-- Function Name Display -->
                <div class="modal-section-title">Function Name Display</div>
                <div class="modal-radio-row">
                    <label>
                        <input type="radio" name="funcNameStyle" value="short" checked />
                        Short
                    </label>
                    <label>
                        <input type="radio" name="funcNameStyle" value="full" />
                        Full
                    </label>
                </div>
            </div>

            <div class="modal-group-title">Macro Options</div>

            <!-- Preprocessor Macros 섹션 -->
            <div class="modal-section macro-section">
              <div class="modal-section-title">Preprocessor Macros (-D)</div>

              <div class="modal-radio-row">
                <label>
                  <input type="radio" name="macroMode" value="all" checked />
                  All
                </label>

                <label>
                  <input type="radio" name="macroMode" value="defined" />
                  Defined
                </label>

                <label for="macroInput" style="font-size:12px; opacity:0.9; margin:4px 0 2px;">
                  Example: <code>DEBUG;TEST=2;RELEASE</code>
                </label>

                <textarea
                  id="macroInput"
                  class="macro-input"
                  rows="3"
                  placeholder="Type macros like: DEBUG;TEST=2;RELEASE"
                  disabled></textarea>
              </div>
            </div>
            <div class="modal-group-title">Download Options</div>

            <div class="modal-section">
              <div class="modal-section-title">Format</div>
              <div class="modal-radio-row">
                <label>
                  <input type="radio" name="downloadFormat" value="svg" checked />
                  SVG
                </label>

                <!-- PNG 추가 -->
                <label>
                  <input type="radio" name="downloadFormat" value="png" />
                  PNG
                </label>
                
                <div style="font-size:12px; opacity:0.8; margin-top:6px;">
                  Tip: For PDF, use Print → Save as PDF.
                </div>
              </div>
            </div>

            <div class="modal-section">
              <div class="modal-section-title">PNG Options</div>

              <div class="modal-radio-row">
                <label>
                  Scale:
                  <select id="pngScale" style="margin-left:8px;">
                    <option value="1">1x (Fast)</option>
                    <option value="2" selected>2x (Recommended)</option>
                    <option value="3">3x (High)</option>
                  </select>
                </label>

                <label>
                  Background:
                  <select id="pngBg" style="margin-left:8px;">
                    <option value="white" selected>White</option>
                    <option value="transparent">Transparent</option>
                  </select>
                </label>
              </div>
            </div>    
        </div>
    </div>

    <!-- SHARE 모달: settingsOverlay 바로 아래에 추가 -->
    <div id="shareOverlay" class="modal-overlay modal-hidden">
      <div class="modal-panel share-panel">
        <div class="modal-header">
          <h2>Share flowchart</h2>
          <button class="modal-close" onclick="closeShare()">×</button>
        </div>

        <div style="font-size:12px; opacity:0.85; margin-bottom:10px;">
          Read-only link (anyone with the link can view)
        </div>

        <div style="display:flex; gap:10px; align-items:center;">
          <input id="shareLinkInput"
                 type="text"
                 readonly
                 value=""
                 style="flex:1; padding:8px 10px; border-radius:6px; border:1px solid rgba(148,163,184,0.6);">
          <button class="btn btn-primary" onclick="copyShareLink()">COPY LINK</button>
        </div>

        <div id="shareHint"
             style="margin-top:10px; font-size:12px; opacity:0.75;">
        </div>
      </div>
    </div>
    <!-- SHARE 모달 끝 -->    

    
    <!--  Supabase Auth 스크립트: </body> 바로 위에 추가 -->
    <script type="module">
        import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

        //  여기 두 값은 본인 프로젝트 값으로 교체해야 함
        const SUPABASE_URL = "https://layaiawwnioetzuxcyev.supabase.co";   // 예시: 대쉬보드의 Project URL
        const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImxheWFpYXd3bmlvZXR6dXhjeWV2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQ3NjIxMjgsImV4cCI6MjA4MDMzODEyOH0.ZWC86hD5JaX2Jh0b0wR6bfmqNrEWBrq-YnLu3yg1JJo";            // API 탭의 anon public key

        const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        // 전역에서 접근할 수 있게 window에 붙이기
        window.supabase = supabase;

        // 현재 로그인 유저를 전역으로 보관
        window.currentUser = null;

        async function updateAuthUI() {
            const { data } = await supabase.auth.getUser();
            const user = data?.user ?? null;
            window.currentUser = user;

            const welcomeText   = document.getElementById("welcomeText");
            const loggedOutDiv  = document.getElementById("loggedOutButtons");
            const loggedInDiv   = document.getElementById("loggedInButtons");
            const upgradeBtn    = document.getElementById("upgradeButton");

            if (!welcomeText || !loggedOutDiv || !loggedInDiv) return;

            if (user) {
                welcomeText.textContent = user.email
                    ? `Welcome, ${user.email}`
                    : "Welcome!";

                // ✅ 로그인 성공 시, 예전에 남아있던 "Please log in..." 같은 에러 문구 제거
                setStatus("idle", ""); // 또는 setStatus("success", "")는 아이콘 생겨서 비추
                
                loggedOutDiv.style.display = "none";
                loggedInDiv.style.display  = "inline-flex";

                const isTestUser = (user.email === window.TEST_EMAIL);

                // UPGRADE 버튼: 로그인 직후엔 플랜 확정 전이므로 일단 숨김
                if (upgradeBtn) {
                  upgradeBtn.classList.remove("upgrade-blink");
                  upgradeBtn.style.display = "none";
                }

                // 🔹 로그인 직후: 플랜 상태 리셋 + 로딩 시작
                window.__planLoading        = true;
                window.__planTier           = null;
                window.__planName           = null;
                window.__isProUser          = false;
                window.__nodeLimitFromServer = null;
                window.__nodeLimit          = FREE_NODE_LIMIT;
                window.__serverUsageCount   = null;
                window.__dailyFreeLimit     = null;

            } else {
                welcomeText.textContent = "";
                loggedOutDiv.style.display = "inline-flex";
                loggedInDiv.style.display  = "none";
                if (upgradeBtn) {
                    upgradeBtn.style.display = "none";
                    // 로그아웃 시에도 깜빡임 제거
                    upgradeBtn.classList.remove("upgrade-blink");
                }

                // 로그아웃 시 플랜 관련 전역값 초기화
                window.__planLoading        = false;
                window.__planTier           = null;
                window.__planName           = null;
                window.__isProUser          = false;
                window.__nodeLimitFromServer = null;
                window.__nodeLimit          = FREE_NODE_LIMIT;
                window.__serverUsageCount   = null;
                window.__dailyFreeLimit     = null;
            }

            // 로그인/로그아웃 시 무료 사용량 표시 갱신 (위에서 상태 정리 후 호출)
            window.updateQuotaInfo?.();

            // 로그인 상태라면 Supabase에서 구독/플랜 정보도 한 번 더 불러와서 반영
            if (user) {
                window.refreshPlanFromSupabase?.();
            }
        }

        async function loginWithGoogle() {
            // ✅ 지금 보고 있는 페이지로 그대로 돌아오게 해서,
            //    로그인 성공 후 랜딩(/)이 잠깐 보이는 "깜빡임"을 제거
            const redirectTo = `${location.origin}${location.pathname}`;

            await supabase.auth.signInWithOAuth({
                provider: "google",
                options: {
                    redirectTo,
                    queryParams: {
                        // 매번 계정 선택 화면 강제
                        prompt: "select_account"
                    }
                }
            });
        }

        function clearAppUIOnLogout() {
            const src         = document.getElementById("src");
            const lineNumbers = document.getElementById("lineNumbers");
            const status      = document.getElementById("status");
            const currentFunc = document.getElementById("currentFunc");
            const chartInner  = document.getElementById("chartInner");
            const codeHeader  = document.getElementById("codeHeader");
            const quotaInfo = document.getElementById("quotaInfo");
            if (quotaInfo) {
              quotaInfo.textContent = "Free tier: up to 5 diagrams/day (≤ 20 nodes).";
            }

            // 코드 영역 비우기
            if (src) {
                src.value = "";
                src.scrollTop = 0;
            }

            // 라인 번호 초기화 (1 한 줄만)
            if (lineNumbers) {
                lineNumbers.innerHTML = "1<br>";
            }

            // 상태 메시지: 로그인 필요
            if (status) {
                status.textContent = "Please log in to use mAutoFlow.";
                status.className = "error";
            }

            // 현재 함수명 제거
            if (currentFunc) {
                currentFunc.textContent = "";
            }

            // 플로우차트 자리 초기화 문구
            if (chartInner) {
                chartInner.innerHTML = `
                    <p class="placeholder">
                        When you enter C code on the left, a flowchart is automatically generated on the right.
                    </p>
                `;
            }

            // 코드 헤더 텍스트도 기본값으로
            if (codeHeader) {
                codeHeader.innerHTML = `
                    <span>mAutoFlow</span>
                    <span style="opacity:0.7;">Automatic Analysis</span>
                `;
            }

            // 내부 상태 리셋
            window.__nodeLines = {};
            window.__nodeCount = 0;
            lastCountedSource = "";   // 로그아웃하면 기준 코드도 초기화
        }

        async function logout() {
            await supabase.auth.signOut();
            await updateAuthUI();
            clearAppUIOnLogout();
        }

        //  전역에서 호출 가능하도록 window에 붙이기
        window.loginWithGoogle = loginWithGoogle;
        window.logout          = logout;

        // 첫 로딩 시 로그인 상태 반영
        document.addEventListener("DOMContentLoaded", updateAuthUI);
        window.updateQuotaInfo = updateQuotaInfo;
    </script>
    <!--  Supabase Auth 스크립트 끝 -->

    <footer id="footerBar">
      <div class="footer-left">
        mAutoFlow © 2026. All rights reserved.
      </div>

      <div class="footer-right" id="footerNav">
        <a class="footer-link" href="/app/pricing" onclick="return navigateTo('/app/pricing', event)">Pricing</a>
        <a class="footer-link" href="/app/terms-of-service" onclick="return navigateTo('/app/terms-of-service', event)">Terms</a>
        <a class="footer-link" href="/app/privacy-policy" onclick="return navigateTo('/app/privacy-policy', event)">Privacy</a>
      </div>
    </footer>

</body>
</html>

