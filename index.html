<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <title>mAutoFlow</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        :root {
            /* ê¸°ë³¸ í…Œë§ˆ (classic) */
            --bg-main: #f3f4f6;
            --bg-header: #1f2933;
            --header-text: #f9fafb;

            --bg-code: #111827;
            --code-text: #e5e7eb;
            --code-border: #d1d5db;

            --bg-chart: #ffffff;
            --chart-border: #d1d5db;

            --accent-primary: #2563eb;
            --accent-primary-hover: #1d4ed8;

            --toolbar-text: #374151;
        }

        /* ë¼ì´íŠ¸ í…Œë§ˆ */
        body[data-theme="light"] {
            --bg-main: #f9fafb;
            --bg-header: #2563eb;
            --header-text: #ffffff;

            --bg-code: #ffffff;
            --code-text: #111827;
            --code-border: #d1d5db;

            --bg-chart: #ffffff;
            --chart-border: #d1d5db;

            --accent-primary: #2563eb;
            --accent-primary-hover: #1d4ed8;

            --toolbar-text: #111827;
        }

        /* ë‹¤í¬ í…Œë§ˆ */
        body[data-theme="dark"] {
            --bg-main: #020617;
            --bg-header: #020617;
            --header-text: #e5e7eb;

            --bg-code: #020617;
            --code-text: #e5e7eb;
            --code-border: #1f2937;

            --bg-chart: #020617;
            --chart-border: #1f2937;

            --accent-primary: #22c55e;
            --accent-primary-hover: #16a34a;

            --toolbar-text: #e5e7eb;
        }

        /* Mermaid SVG Override (dark) */
        body[data-theme="dark"] #chartInner svg path {
            stroke: #f8fafc !important;
        }
        body[data-theme="dark"] #chartInner svg line {
            stroke: #f8fafc !important;
        }
        body[data-theme="dark"] #chartInner svg polygon {
            stroke: #f8fafc !important;
            fill: #f8fafc !important;
        }
        body[data-theme="dark"] #chartInner svg marker path {
            stroke: #f8fafc !important;
            fill: #f8fafc !important;
        }
    
        * { box-sizing: border-box; }
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
        }
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            font-size: 14px; /* UI ê¸°ë³¸ í°íŠ¸ */
            background: var(--bg-main);
        }
        header {
            padding: 10px 16px;
            background: var(--bg-header); /* â† ë³€ê²½ */
            color: var(--header-text);    /* â† ë³€ê²½ */
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        header h1 {
            margin: 0;
            font-size: 20px;
        }
        header .subtitle {
            font-size: 12px;
            opacity: 0.85;
        }

        .main {
            flex: 1;
            display: flex;
            min-height: 0;
            background: var(--bg-main);
        }

        #helpContent .help-link {
            color: var(--accent-primary);
            text-decoration: underline;
            font-weight: 600;
        }

        /* ì¢Œì¸¡/ìš°ì¸¡ íŒ¨ë„ + ë“œë˜ê·¸ ë¶„í• ë°” */
        #leftPane {
            flex: 0 0 33%; /* ì´ˆê¸° ì•½ 1/3 */
            min-width: 200px;
            display: flex;
            flex-direction: column;
            padding: 8px;
            min-height: 0;
        }
        #divider {
            flex: 0 0 6px;
            cursor: col-resize;
            background: #d1d5db;
        }
        #divider:hover {
            background: #9ca3af;
        }
        #rightPane {
            flex: 0 0 67%; /* ì´ˆê¸° ì•½ 2/3 */
            min-width: 260px;
            display: flex;
            flex-direction: column;
            padding: 8px;
        }

        .pane-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 6px;
        }
        .pane-title {
            font-weight: 600;
            font-size: 14px;
            color: var(--toolbar-text);
        }

        /* ì¢Œì¸¡ ì½”ë“œ ì˜ì—­ */
        #codeContainer {
            flex: 1;
            border-radius: 4px;
            border: 1px solid var(--code-border);  /* â† ë³€ê²½ */
            background: var(--bg-code);            /* â† ë³€ê²½ */
            display: flex;
            flex-direction: column;
            min-height: 0;
        }
        #codeHeader {
            padding: 4px 8px;
            border-bottom: 1px solid #4b5563;
            color: var(--code-text);      /* â† ë³€ê²½ */
            font-size: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #codeArea {
            flex: 1;
            padding: 6px;
            display: flex;    /* â† ë¼ì¸ë²ˆí˜¸ + textarea ê°€ ê°€ë¡œë¡œ ë°°ì¹˜ë˜ë„ë¡ */
            min-height: 0;
        }

        /* HELP / SETTINGS ì—ì„œ ì™¼ìª½ íŒ¨ë„ ì•ˆì—ì„œë§Œ ì„¸ë¡œ ìŠ¤í¬ë¡¤ ë˜ë„ë¡ */
        #leftPane,
        #codeContainer,
        #codeArea {
            min-height: 0;   /* flex column ì•ˆì—ì„œ ìì‹ì´ ë‚´ìš©ë³´ë‹¤ ì‘ì•„ì§ˆ ìˆ˜ ìˆê²Œ í—ˆìš© */
        }


        #lineNumbers {
            width: 40px;  /* ë¼ì¸ ë²ˆí˜¸ ì˜ì—­ ë„ˆë¹„ */
            padding: 6px 4px;
            text-align: right;
            color: var(--code-text);
            background: var(--bg-code);
            border-right: 1px solid var(--code-border);
            font-family: "Consolas", "Roboto Mono", monospace;
            font-size: 13px;
            line-height: 1.4;
            user-select: none;        /* ë¼ì¸ ë²ˆí˜¸ ë“œë˜ê·¸ ë°©ì§€ */
            overflow: hidden;
        }
        
        #src {
            width: 100%;
            height: 100%;
            border: none;
            outline: none;
            resize: none;
            background: transparent;
            color: var(--code-text);      /* â† ë³€ê²½ */
            font-family: "Consolas", "Roboto Mono", monospace;
            font-size: 13px;  /* ì½”ë“œ ê¸€ì í¬ê¸° (ë„ˆë¬´ í¬ì§€ ì•Šê²Œ) */
            line-height: 1.4;
            flex: 1;                  /* â† ë‚¨ì€ ì˜ì—­ ê½‰ ì±„ìš°ê¸° */
        }

        /* ìš°ì¸¡ í”Œë¡œìš°ì°¨íŠ¸ ì˜ì—­ */
        #toolbar {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
            font-size: 12px;
        }
        .btn {
            padding: 4px 10px;
            border-radius: 4px;
            border: none;
            cursor: pointer;
            font-size: 12px;
        }
        .btn-primary {
            background: var(--accent-primary);           /* â† ë³€ê²½ */
            color: white;
        }
        .btn-primary:hover {
            background: var(--accent-primary-hover);     /* â† ë³€ê²½ */
        }
        .btn-ghost {
            background: #e5e7eb;
            color: #111827;
        }
        .btn-ghost:hover {
            background: #d1d5db;
        }

        #status {
            font-size: 12px;
            color: var(--toolbar-text);                  /* â† ë³€ê²½ */
        }
        #status.error {
            color: #b91c1c;
        }
        #status.success {
            color: #15803d;
        }
        #currentFunc {
            font-weight: 600;
            font-size: 12px;
            color: var(--toolbar-text);
        }

        #chartContainer {
            flex: 1;
            border-radius: 4px;
            border: 1px solid var(--chart-border); /* â† ë³€ê²½ */
            background: var(--bg-chart);           /* â† ë³€ê²½ */
            overflow: auto;

            /* flex ì œê±°í•˜ê³ , ì¼ë°˜ ë¸”ë¡ + í…ìŠ¤íŠ¸ ì •ë ¬ë¡œ ê°€ìš´ë° ë§ì¶”ê¸° */
            text-align: center;
        }
        #chartInner {
            display: inline-block;   /* ê°€ìš´ë° ì •ë ¬ ëŒ€ìƒ */
            margin: 8px;
            transform-origin: top center;  /* í™•ëŒ€ ê¸°ì¤€ì€ ê·¸ëŒ€ë¡œ ì¤‘ì•™ */
        }
        #chartInner .mermaid {
            margin: 0 auto;
        }

        .placeholder {
            color: #9ca3af;
            font-size: 14px;
            text-align: center;
            margin-top: 40px;
        }

        /* Mermaidê°€ ê·¸ë¦¬ëŠ” SVGë¥¼ ìš°ì¸¡ íŒ¨ë„ ë„ˆë¹„ì— ë§ê²Œ ì¡°ì • */
        #chartInner svg {
            max-width: none;
            height: auto;
            display: block;
            margin: 0 auto;
        }
        

        .zoom-label {
            font-size: 12px;
            min-width: 42px;
            color: var(--toolbar-text);
        }

        /* ì½”ë“œ â†” ë…¸ë“œ ì—°ë™: ì„ íƒëœ ë…¸ë“œ í•˜ì´ë¼ì´íŠ¸ (ë” ì§„í•˜ê²Œ) */
        .node.autoflow-selected rect,
        .node.autoflow-selected polygon,
        .node.autoflow-selected path {
            stroke: #ff0000;              /* ë” ê°•í•œ ë¹¨ê°„ìƒ‰ */
            stroke-width: 4px;            /* í…Œë‘ë¦¬ ë‘ê»˜ ì—… */
            stroke-dasharray: 0;          /* ì‹¤ì„  */
            filter: drop-shadow(0 0 6px rgba(255, 0, 0, 0.9));
        }

        /* ì„ íƒëœ ë…¸ë“œ í…ìŠ¤íŠ¸ë„ ê°•ì¡° */
        .node.autoflow-selected text {
            font-weight: 700;
            fill: #000000;
        }

        .topbar-right {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            opacity: 0.9;
            flex-wrap: nowrap;    /* ë²„íŠ¼ ì¤„ë°”ê¿ˆ ë°©ì§€ */
            white-space: nowrap;  /* í…ìŠ¤íŠ¸ ì¤„ë°”ê¿ˆ ë°©ì§€ */
        }

        .btn-settings {
            padding: 4px 10px;
            border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.4);
            background: transparent;
            color: inherit;
            cursor: pointer;
            font-size: 12px;
        }
        .btn-settings:hover {
            background: rgba(255,255,255,0.12);
        }

        /* HELP ëª¨ë“œì—ì„œ CODE ë²„íŠ¼ ë§¤ìš° ë¶€ë“œëŸ¬ìš´ ê°•ì¡°ìš© */
        .btn-code-blink {
            background: #f59e0b;             /* ê¸°ì¡´ë³´ë‹¤ ë” ì—°í•œ ì£¼í™©ìƒ‰ */
            color: #ffffff;
            border-color: #fcd34d;           /* ì—°í•œ í…Œë‘ë¦¬ */
            animation: codeSoftBlink 2.4s ease-in-out infinite; /* ë” ëŠë¦¬ê³  ë¶€ë“œëŸ½ê²Œ */
        }

        /* Upgrade ë²„íŠ¼ ë¸”ë§í¬ ì• ë‹ˆë©”ì´ì…˜ */
        @keyframes upgradeBlink {
            0%   { background-color: #a7f3d0; }  /* pastel green */
            50%  { background-color: #6ee7b7; }
            100% { background-color: #a7f3d0; }
        }

        .upgrade-blink {
            animation: upgradeBlink 1s infinite;
        }

        @keyframes codeSoftBlink {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.6;                /* ê¸°ì¡´ 0.35 â†’ í›¨ì”¬ ëœ íë ¤ì§ */
            }
        }
                

        /* SETTINGS ëª¨ë‹¬ */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(15,23,42,0.55);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 50;
        }
        .modal-hidden {
            display: none;
        }
        .modal-panel {
            background: #ffffff;
            border-radius: 8px;
            padding: 16px 20px;
            min-width: 260px;
            max-width: 320px;
            box-shadow: 0 10px 40px rgba(15,23,42,0.45);
            font-size: 13px;
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }
        .modal-header h2 {
            margin: 0;
            font-size: 14px;
        }
        .modal-close {
            border: none;
            background: transparent;
            cursor: pointer;
            font-size: 16px;
        }

        /* SETTINGS - Macro Input width alignment */
        #macroInput{
          display: block;
          width: 100%;
          margin: 0;
          box-sizing: border-box;
        }     
                   
        /* SETTINGS ì¹´ë“œ ì„¹ì…˜ */
        .modal-section {
            /* ìœ„/ì•„ë˜ ê°„ê²© + ì¢Œìš° ì‚´ì§ ì—¬ë°± */
            margin: 18px 4px 22px;
            padding: 0 0 6px;
            background-color: transparent;      /* ì¹´ë“œ ì•ˆ/ë°– ìƒ‰ ë™ì¼ */
        }

        /* SETTINGS ê·¸ë£¹ íƒ€ì´í‹€ (Display Options / Macro Options) */
        .modal-group-title{
            font-weight: 700;
            font-size: 13px;

            /* âœ… 1ë‹¨ ë“¤ì—¬ì“°ê¸° ëŠë‚Œ */
            margin: 14px 16px 8px;
            padding: 6px 10px 6px 12px;   /* âœ… ì™¼ìª½ë§Œ ê¹Šê²Œ */

            border-top: 1px solid rgba(148, 163, 184, 0.45);
            border-bottom: 1px solid rgba(148, 163, 184, 0.45);
        }

                           

        /* ì„¹ì…˜ ìœ„ìª½ì—ë§Œ ê°€ë¡œì„  í•˜ë‚˜ (ì¢Œìš° ì—¬ë°± ìˆìŒ) */
        .modal-section::before {
            content: "";
            display: block;

            border-top: 1px solid rgba(148, 163, 184, 0.35);

            /* âœ… ê·¸ë£¹ íƒ€ì´í‹€(1ë‹¨) ì‹œì‘ì ê³¼ ë§ì¶¤ */
            margin: 0 16px 10px 12px;
        }

                   
        /* ì²« ì„¹ì…˜ì€ ë§¨ ìœ„ ì„  ì œê±° */
        .modal-section:first-of-type::before {
            border-top: none;
            margin-bottom: 0;
        }

        /* ì„¹ì…˜ ì œëª© */
        .modal-section-title {
            font-weight: 600;
            margin: 0;

            /* âœ… 2ë‹¨ ë“¤ì—¬ì“°ê¸° */
            padding: 0 10px 6px 44px;   /* left = 44px */

            background-color: transparent;
        }


        /* ë¼ë””ì˜¤ ì˜ì—­ */
        .modal-radio-row {
            /* âœ… 3ë‹¨ ë“¤ì—¬ì“°ê¸° */
            padding: 0 12px 0 62px;   /* left = 62px */

            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        /* âœ… Macro ì„¹ì…˜ë„ ì˜µì…˜ ë ˆë²¨(3ë‹¨) ë“¤ì—¬ì“°ê¸° ìœ ì§€ */
        .macro-section .modal-radio-row {
            padding: 0 12px 0 62px;
        }
            
        .modal-footer {
            margin-top: 16px;
            display: flex;
            justify-content: flex-end;  /* ì˜¤ë¥¸ìª½ ì •ë ¬ */
        }

        .modal-footer-inner {
            background-color: transparent;   /* ì¹´ë“œ ì•ˆ/ë°– ë™ì¼ ìƒ‰ */
            border-radius: 4px;
            border: 1px solid rgba(15, 23, 42, 0.95);
            padding: 8px 12px 10px;
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .modal-footer-contact {
            font-size: 11px;
            opacity: 0.85;
        }

        .settings-contact-link {
            color: #facc15;              /* ì–´ë‘ìš´ ë°°ê²½ì—ì„œ ì˜ ë³´ì´ëŠ” ë…¸ë€ìƒ‰ */
            text-decoration: underline;
            font-weight: 600;
        }

        body[data-theme="dark"] input[type="radio"] {
            accent-color: #34d399;   /* ì—°ë‘(emerald) */
        }
        body:not([data-theme="dark"]) input[type="radio"] {
            accent-color: #22c55e;   /* ì—°ë‘(green) */
        }

        /* SHARE ëª¨ë‹¬ì€ ì¡°ê¸ˆ ë” ë„“ê²Œ */
        .share-panel{
          max-width: 520px;
          width: 520px;
        }                   

        /* ===============================
           SETTINGS - Macro textarea style
           =============================== */
        .macro-input {
            resize: vertical;
            font-size: 12px;
            font-family: Consolas, "Roboto Mono", monospace;
            padding: 4px 6px;
            border-radius: 4px;
            border: 1px solid rgba(148,163,184,0.6);
            background-color: var(--bg-code);
            color: var(--code-text);
        }           
      
    </style>


    <script>
        const API_BASE = "https://mautoflow-backend.onrender.com";
        const PRO_CHECKOUT_URL =
          "https://mautoflow-lab.lemonsqueezy.com/buy/0d07c522-4264-4c87-a865-85ef42852174";
        const EXPERT_CHECKOUT_URL =
          "https://mautoflow-lab.lemonsqueezy.com/buy/EXPERT_SLUG_HERE";

        const PAYMENT_ENABLED = false;  // â† Live ì „í™˜ ì‹œ true

        function openProCheckout() {

          if (!PAYMENT_ENABLED) {
            alert("Upgrade (Coming Soon)\nPayments are currently being enabled.\nUpgrade to Pro or Expert will be available soon.");
            return;
          }  
            
          // Supabase ë¡œê·¸ì¸ ìœ ì € ì •ë³´ê°€ ìˆì–´ì•¼ user_idë¥¼ ë„˜ê¸¸ ìˆ˜ ìˆìŒ
          const user = window.currentUser;

          if (!user) {
            alert("ë¨¼ì € Google ë¡œê·¸ì¸ í›„ ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.");
            return;
          }

          // Hosted Checkout URL + custom user_id ì „ë‹¬
          // docs: https://[STORE].lemonsqueezy.com/checkout/buy/[VARIANT_ID]?checkout[custom][user_id]=123 
          const baseUrl = PRO_CHECKOUT_URL;
          const url = `${baseUrl}?checkout[custom][user_id]=${encodeURIComponent(user.id)}`;

          window.location.href = url;
        }

        function getMaxEdgesByPlan() {
          // TODO: ë‚˜ì¤‘ì— ì‹¤ì œ í”Œëœ ë³€ìˆ˜ë¡œ êµì²´
          const plan = window.currentUserPlan || "free"; 
          // ì˜ˆìƒ ê°’: "free" | "pro" | "expert"

          switch (plan) {
            case "expert":
              return 20000;   // ë…¸ë“œ 1000 ëŒ€ì‘
            case "pro":
              return 8000;
            case "free":
            default:
              return 2000;
          }
        }


	// mermaid.initialize({ startOnLoad: false });
        mermaid.initialize({
          startOnLoad: false,
          maxTextSize: 2000000,
          maxEdges: getMaxEdgesByPlan(),   // âœ… í”Œëœ ê¸°ë°˜
          securityLevel: "loose",
          flowchart: {
            htmlLabels: false,
            useMaxWidth: true
          }
        });


	// ì „ì—­ ì„ ì–¸ (ì–´ë””ì„œë“  ì ‘ê·¼ ê°€ëŠ¥)
        let funcNameStyle = "short";
        let macroDefines  = "";      // -D ë§¤í¬ë¡œ ë¬¸ìì—´ (í”„ë¡ íŠ¸ì—ì„œ ì…ë ¥ë°›ëŠ” ê°’)
        let macroMode = "all";   // "all" | "defined"
        let downloadFormat = "svg";   // svg | png | pdf (ê¸°ë³¸ svg)

	// ì„œë²„ì—ì„œ ë‚´ë ¤ì¤€ ì‚¬ìš©ëŸ‰ / í•œë„ (ì—†ìœ¼ë©´ null)
        window.__serverUsageCount = null;
        window.__dailyFreeLimit  = null;

        // êµ¬ë…/ê³„ì • ìƒíƒœ
        window.__isProUser      = false;
        window.__planName       = null;
        window.__isTestAccount  = false;
        // "free" | "pro" | "expert" | null(ì•„ì§ ì„œë²„ ì¡°íšŒ ì „)
        window.__planTier       = null;
        // ë¡œê·¸ì¸ ì§í›„ í”Œëœ ì •ë³´ ê°€ì ¸ì˜¤ëŠ” ë™ì•ˆ true
        window.__planLoading    = false;

	let lastCountedSource = "";   // ë§ˆì§€ë§‰ìœ¼ë¡œ ì‚¬ìš©ëŸ‰ì„ ì˜¬ë ¸ë˜ ì†ŒìŠ¤ ì½”ë“œ

        // âœ… í…ŒìŠ¤íŠ¸ ì „ìš© ê³„ì • (ë¬´ì œí•œ) - moduleì—ì„œë„ ì“°ê¸° ìœ„í•´ ì „ì—­(window)ì— ë“±ë¡
        window.TEST_EMAIL = "exitgiveme@gmail.com";

        // ===== í•˜ë£¨ ë¬´ë£Œ ì‚¬ìš©ëŸ‰ ì„¤ì • =====
        const DAILY_FREE_LIMIT = 5;       // í•˜ë£¨ ë¬´ë£Œ 5íšŒ
        const FREE_NODE_LIMIT  = 20;      // Free: ë…¸ë“œ 20ê°œê¹Œì§€
        const PRO_NODE_LIMIT   = 200;     // Pro: ë…¸ë“œ 200ê°œê¹Œì§€
        const EXPERT_NODE_LIMIT  = 1000;  // Expert: ë…¸ë“œ 1000ê°œê¹Œì§€
        const USAGE_KEY        = "autoflow_daily_usage";

        function getTodayKey() {
            // YYYY-MM-DD í˜•ì‹
            return new Date().toISOString().slice(0, 10);
        }

        function getTodayUsage() {
            const today = getTodayKey();
            let raw = null;
            try {
                raw = localStorage.getItem(USAGE_KEY);
            } catch (e) {
                return { date: today, count: 0 };
            }

            if (!raw) {
                return { date: today, count: 0 };
            }

            try {
                const data = JSON.parse(raw);
                if (!data.date || data.date !== today) {
                    // ë‚ ì§œê°€ ë‹¤ë¥´ë©´ ìƒˆë¡œ ì‹œì‘
                    return { date: today, count: 0 };
                }
                if (typeof data.count !== "number") {
                    return { date: today, count: 0 };
                }
                return { date: today, count: data.count };
            } catch (e) {
                return { date: today, count: 0 };
            }
        }

        function saveTodayUsage(obj) {
            try {
                localStorage.setItem(USAGE_KEY, JSON.stringify(obj));
            } catch (e) {
                // ì €ì¥ ì‹¤íŒ¨ëŠ” ê·¸ëƒ¥ ë¬´ì‹œ
            }
        }
	

const HELP_TEXT_HTML = `
          <h2 style="margin-top:0;">mAutoFlow â€“ Help</h2>

          <p>
            mAutoFlow converts C / pseudo-C functions into a structured flowchart.
            The left side is the source editor and the right side is the diagram viewer.
            Code and nodes are synchronized in both directions.
          </p>

          <h3>1. Basic Concept</h3>
          <ul>
            <li>mAutoFlow focuses on <strong>a single function</strong> at a time.</li>
            <li>When you type or paste C code on the left, mAutoFlow finds a function.</li>
            <li>The body of the selected function is analyzed and rendered as a flowchart on the right.</li>
            <li>
              Use the <strong>HELP</strong> button in the top-right toolbar to switch between
              <strong>Code view</strong> and <strong>Help view</strong>.
              When Help is open, the button label becomes <strong>CODE</strong>; click it again to return to the editor.
            </li>
          </ul>

          <h3>2. Writing / Pasting Code</h3>
          <ul>
            <li>Paste normal C code or pseudo-C code into the editor.</li>
            <li>Function prototypes and global variables are allowed; mAutoFlow focuses on the chosen function body.</li>
            <li>Supported constructs:
              <ul>
                <li><code>if / else if / else</code></li>
                <li><code>for</code>, <code>while</code>, <code>doâ€¦while</code></li>
                <li><code>switch / case / default</code></li>
                <li><code>return</code>, <code>break</code>, <code>continue</code></li>
                <li>Simple assignments and expressions (e.g. <code>x++;</code>, <code>flag = true;</code>)</li>
              </ul>
            </li>
            <li>
              Very complex or unusual syntax may not be visualized perfectly,
              but the main control flow should still appear.
            </li>
          </ul>

          <h3>3. Automatic Refresh</h3>
          <ul>
            <li>mAutoFlow watches your typing in the left editor.</li>
            <li>After a short idle delay, the flowchart is automatically regenerated.</li>
            <li>If you do not want to wait, press <strong>â€œRegenerate Nowâ€</strong> to force an immediate update.</li>
          </ul>

          <h3>4. Code â‡„ Flowchart Synchronization</h3>
          <ul>
            <li><strong>From code to flowchart</strong>:
              <ul>
                <li>Click a line in the editor (or move the caret).</li>
                <li>The best-matching node in the chart is highlighted in red.</li>
                <li>The diagram view automatically scrolls to keep the node visible.</li>
              </ul>
            </li>
            <li><strong>From flowchart to code</strong>:
              <ul>
                <li>Click a node on the diagram.</li>
                <li>The corresponding line in the editor is selected.</li>
                <li>The editor scrolls so the line is centered vertically.</li>
                <li>â€œstart / end / mergeâ€ nodes are ignored to avoid meaningless jumps.</li>
              </ul>
            </li>
            <li>A fuzzy matching algorithm is used, so minor formatting differences are tolerated.</li>
          </ul>

          <h3>5. Zooming & Panning the Diagram</h3>
          <ul>
            <li>Use the buttons in the Flowchart header:
              <ul>
                <li><strong>âˆ’</strong>: zoom out</li>
                <li><strong>100%</strong>: reset zoom</li>
                <li><strong>+</strong>: zoom in</li>
              </ul>
            </li>
            <li><strong>Ctrl + mouse wheel</strong> over the diagram zooms as well.</li>
            <li><strong>Left-drag</strong> to pan when the chart is larger than the viewport.</li>
            <li>The current zoom level is shown on the right side of the toolbar.</li>
          </ul>

          <h3>6. Typical Workflow</h3>
          <ol>
            <li>Paste a function from your C project into the editor.</li>
            <li>Wait for automatic refresh or click â€œRegenerate Nowâ€.</li>
            <li>Inspect the resulting flowchart.</li>
            <li>Click nodes to jump directly to code.</li>
            <li>Modify code to simplify logic or conditions.</li>
            <li>Download SVG for documentation or design reviews.</li>
          </ol>

          <h3>7. Example Code Snippet</h3>
          <pre style="background:#111827; color:#e5e7eb; padding:8px; border-radius:4px; font-size:12px; overflow:auto;">
        void main(void)
        {
            int x = 0;

            if (x == 0)
            {
                x++;
            }
            else
            {
                x--;
            }
        }
          </pre>
          <p>
            Paste this sample into the editor and observe how mAutoFlow renders the branches.
            Try modifying conditions or adding loops to see dynamic updates.
          </p>

          <h3>8. Notes &amp; Limitations</h3>
          <ul>
            <li>mAutoFlow focuses on <strong>control flow</strong>, not a full C compiler.</li>
            <li>Complicated macros or vendor-specific extensions may not be shown perfectly.</li>
            <li>If a function body cannot be detected, mAutoFlow displays an error message.</li>
            <li>Extremely long single-line statements may reduce matching accuracy.</li>
          </ul>


		  <h3>9. Upgrade</h3>

		  <p>
		    Some advanced features in mAutoFlow are available only on paid plans.
		    When you attempt to use such a feature, an <strong>UPGRADE</strong> button
		    may appear in the UI.
		  </p>

		  <ul>
		    <li>
		      Upgrading requires login so that your plan can be linked to your account.
		    </li>
		    <li>
		      Typical features that may trigger an upgrade prompt include:
		      <ul>
		        <li>Macro analysis using <strong>Defined</strong> mode</li>
		        <li>Higher node limits for large functions</li>
		      </ul>
		    </li>
		    <li>
		      After upgrading, your plan status is automatically refreshed.
		      In some cases, a page reload or re-login may be required.
		    </li>
		  </ul>


          <h3>10. Sharing (Public Link)</h3>
          <ul>
            <li><strong>Create a share link (login required)</strong>:
              <ul>
                <li>Generate a flowchart first.</li>
                <li>Click <strong>SHARE</strong> â†’ a public URL is generated.</li>
                <li>Copy the link and send it to others.</li>
              </ul>
            </li>
            <li><strong>Open a shared link (no login required)</strong>:
              <ul>
                <li>Anyone with the link can open <code>/share/&lt;share_id&gt;</code>.</li>
                <li>The shared page is <strong>view-only</strong> (diagram only).</li>
                <li>
				  Downloading is disabled on shared pages.
				  Only the original owner can download diagrams.
				</li>
              </ul>
            </li>
            <li><strong>Expiration</strong>:
              <ul>
                <li>There is no limit on the total number of shares, but each link expires automatically after 7 days.</li>
                <li>Can create up to 20 share links per day(based on server time: UTC, resets around 09:00 AM KST).</li>
                <li>If a share is expired or removed, the page will show: <strong>â€œExpired or removedâ€</strong>.</li>
                <li>A share link may be removed before expiration by its creator (owner) only.</li>
              </ul>
            </li>
          </ul>

          <h3>11. Downloading the Diagram</h3>
          <ul>
            <li>Click the <strong>DOWNLOAD</strong> button in the top-right toolbar.</li>
            <li>The current flowchart is exported as an <strong>SVG</strong> file.</li>
            <li>File name is based on the current function name (e.g. <code>MyFunction.svg</code>).</li>
            <li>SVG is resolution-independent and ideal for documents and high-quality printing.</li>
            <li>If you need PNG or PDF, you can convert the SVG using external tools or your browserâ€™s print-to-PDF feature.</li>
          </ul>

		  <h3>12. Settings</h3>

		  <p>
		    The <strong>SETTINGS</strong> panel allows you to customize how the flowchart is generated
		    and displayed. When SETTINGS is open, the main editor is temporarily hidden.
		  </p>

		  <p>
		    To return to the code editor at any time, click the <strong>CODE</strong> button
		    in the top-right toolbar.
		    (The same CODE button is used to exit both <strong>HELP</strong> and <strong>SETTINGS</strong>.)
		  </p>

		<ul>
		  <h4>12.1 Display Options</h4>
		  <ul>
		    <li>
		      <strong>Theme</strong><br/>
		      Controls the overall visual appearance of the diagram and UI.
		      Available themes include Classic, Light, and Dark.
		      Your selection is saved locally and restored automatically.
		    </li>
		    <li>
		      <strong>Branch Shape</strong><br/>
		      Controls how conditional branches (<code>if</code>, <code>else</code>, <code>switch</code>)
		      are drawn in the flowchart.
		      You can choose between rounded rectangles and diamond-style decision nodes.
		      The diagram is regenerated when this option changes.
		    </li>
		    <li>
		      <strong>Function Name Display</strong><br/>
		      Controls how function names are shown in the diagram.
		      <ul>
		        <li><strong>Short</strong>: compact function names for readability</li>
		        <li><strong>Full</strong>: full function signature for detailed documentation</li>
		      </ul>
		      Changing this option regenerates the diagram.
		    </li>
		  </ul>

		  <h4>12.2 Macro Options</h4>
		  <ul>
		    <li>
		      <strong>Preprocessor Macros (-D)</strong><br/>
		      Allows you to control how conditional compilation paths are analyzed.
		    </li>
		    <li>
		      Macros should be entered using the following format:
		      <br/>
		      <code>DEBUG;TEST=2;FEATURE_X</code>
		    </li>
		    <li>
		      Use semicolons (<code>;</code>) to separate macros.
		      Use equals (<code>=</code>) to assign values.
		    </li>
		    <li>
		      <strong>All</strong>: analyze the code without applying custom macro definitions.
		    </li>
		    <li>
		      <strong>Defined</strong>: analyze the code using the specified macro definitions.
		      This option affects which branches appear in the flowchart.
		    </li>
		    <li>
		      <strong>Note:</strong> The <em>Defined</em> macro mode is available only for
		      <strong>Pro</strong> and <strong>Expert</strong> plans.
		      Free users will see an upgrade prompt when attempting to use it.
		    </li>
		  </ul>

		  <h4>12.3 Download Options</h4>
		  <ul>
		    <li>
		      <strong>Format</strong><br/>
		      Currently, diagrams can be downloaded as <strong>SVG</strong>.
		    </li>
		    <li>
		      SVG files are vector-based and suitable for documentation, presentations,
		      and high-resolution printing.
		    </li>
		    <li>
		      If you need PNG or PDF, you can convert the SVG using external tools
		      or your browserâ€™s print-to-PDF feature.
		    </li>
		  </ul>
		</ul>

          <h3>13. Login, Plans &amp; Usage Limits</h3>
          <ul>
            <li>mAutoFlow uses Google login (Supabase) for authentication.</li>
            <li>Some features require login (for example: Share link creation, server-side limits).</li>
            <li>
              Limits may apply depending on your plan:
              <ul>
                <li><strong>Free</strong>: limited number of diagrams per day + node limit per diagram</li>
                <li><strong>Pro / Expert</strong>: higher node limits or unlimited diagrams</li>
              </ul>
            </li>
            <li>The UI shows your current plan and todayâ€™s usage in the top area after login.</li>
          </ul>

          <h3>14. Troubleshooting</h3>
          <ul>
            <li><strong>â€œUnexpected errorâ€ even when Network shows 200</strong>:
              <ul>
                <li>This is usually a <em>response parsing</em> issue or a <em>Mermaid rendering</em> exception.</li>
                <li>Try regenerating once, or simplify the function temporarily.</li>
              </ul>
            </li>
            <li><strong>Share link loads but shows an error</strong>:
              <ul>
                <li>If HTTP 404: the share is expired or removed.</li>
                <li>If HTTP 500: contact support with the share_id and timestamp.</li>
              </ul>
            </li>
          </ul>

          <h3>15. Upgrade and Cancellation Processing</h3>
          <ul>
            <li>Upgrades are prorated automatically.</li>
            <li>If you upgrade mid-cycle, unused time from your current plan is credited.</li>
            <li>Cancelling a subscription stops future billing but allows access until the end of the current period.</li>
          </ul>

          <h3>Contact &amp; Feedback</h3>
          <p>
            If you find a bug, have a feature request, or need help using mAutoFlow,
            feel free to contact us:
            <br />
            <strong>Email:</strong>
            <a href="mailto:mautoflow.lab@gmail.com" class="help-link">
              mautoflow.lab@gmail.com
            </a>
          </p>
        `;
	
   
        let isHelpMode = false;
        let isSettingsMode = false;   // SETTINGSê°€ ì¢Œì¸¡ì— ëœ¨ëŠ” ìƒíƒœ           

        // í˜„ì¬ ë¡œê·¸ì¸ ìœ ì € ê¸°ì¤€ localStorage í‚¤
        function getUsageStorageKey() {
            if (!window.currentUser || !window.currentUser.id) return null;
            return `autoflow-usage-${window.currentUser.id}`;
        }

        function getUsageCount() {
            const key = getUsageStorageKey();
            if (!key) return 0;
            try {
                const raw = localStorage.getItem(key);
                const n = parseInt(raw, 10);
                return Number.isNaN(n) ? 0 : n;
            } catch (e) {
                return 0;
            }
        }

        function setUsageCount(n) {
            const key = getUsageStorageKey();
            if (!key) return;
            try {
                localStorage.setItem(key, String(n));
            } catch (e) {
                // ì €ì¥ ì‹¤íŒ¨í•˜ë©´ ê·¸ëƒ¥ ë¬´ì‹œ
            }
        }

        function incrementUsageCount() {
            const used = getUsageCount();
            setUsageCount(used + 1);
            updateQuotaInfo();
        }

        function updateQuotaInfo() {
            const span = document.getElementById("quotaInfo");
            if (!span) return;

            // ë¡œê·¸ì¸ ì•ˆ í–ˆìœ¼ë©´ í‘œì‹œ X
            if (!window.currentUser) {
                span.textContent = "";
                span.title = "";
                return;
            }

            const email = window.currentUser.email;

            // Test ê³„ì • (exitgiveme)
            if (email === TEST_EMAIL) {
                span.textContent = "Free tier: unlimited (test account).";
                span.title = "Test account is not subject to any limits.";
                return;
            }

            const tier = window.__planTier;
            const isLoading = !!window.__planLoading && !tier;

            // í”Œëœ ë¡œë”© ì¤‘: Free ë¬¸êµ¬ ëŒ€ì‹  ë¡œë”© í‘œì‹œ
            if (isLoading) {
                span.textContent = "Loading plan info...";
                span.title       = "Fetching your subscription from Supabase...";
                return;
            }

            // Expert ê³„ì •
            if (tier === "expert") {
                span.textContent =
                    `Expert (${window.__planName || "expert"}): unlimited diagrams (â‰¤ ${EXPERT_NODE_LIMIT} nodes).`;
                span.title =
                    `Expert plan active. Up to ${EXPERT_NODE_LIMIT} nodes per diagram.`;
                return;
            }

            // Pro ê³„ì •
            if (tier === "pro") {
                span.textContent =
                    `Pro (${window.__planName || "pro"}): unlimited diagrams (â‰¤ ${PRO_NODE_LIMIT} nodes).`;
                span.title =
                    `Pro plan active. Up to ${PRO_NODE_LIMIT} nodes per diagram.`;
                return;
            }

            // Free ê³„ì • (ìœ ì¼í•˜ê²Œ ì¼ì¼ ì œí•œ ì¡´ì¬)
            if (tier === "free") {
                // ì•„ì§ ì„œë²„ usage ì •ë³´ê°€ ì—†ëŠ” ì´ˆê¸° ìƒíƒœë¼ë©´ ê¸°ë³¸ ë¬¸êµ¬
                if (window.__serverUsageCount == null || window.__dailyFreeLimit == null) {
                    span.textContent = `Free tier: 5 diagrams/day, â‰¤ ${FREE_NODE_LIMIT} nodes.`;
                    span.title = "Daily limit is enforced on the server.";
                    return;
                }

                // ì„œë²„ usage ë°˜ì˜ëœ ìƒíƒœ
                span.textContent = `Today: ${window.__serverUsageCount} / ${window.__dailyFreeLimit} (â‰¤ ${FREE_NODE_LIMIT} nodes).`;
                span.title = "Daily free usage returned from server.";
                return;
            }

            // í˜¹ì‹œ ëª¨ë¥¼ fallback
            span.textContent = "";
            span.title = "";
        }

        async function refreshPlanFromSupabase() {
            // ì•„ì§ ë¡œê·¸ì¸ ì „ì´ë©´ ì•„ë¬´ ê²ƒë„ ì•ˆ í•¨
            if (!window.supabase || !window.currentUser) return;

            const user  = window.currentUser;
            const email = user.email || "";

            // í…ŒìŠ¤íŠ¸ ê³„ì •ì€ ì—¬ê¸°ì„œ ë³„ë„ ì²˜ë¦¬
            if (email === TEST_EMAIL) {
                window.__planLoading = false;
                window.__planTier    = "free";
                window.__planName    = null;
                window.__isProUser   = false;
                window.__nodeLimit   = Infinity;  // ì‚¬ì‹¤ìƒ ë¬´ì œí•œ
                updateQuotaInfo();
                return;
            }

            // Supabase ì¡°íšŒ ì‹œì‘: Freeë¡œ ì ê¹ ë³´ì´ì§€ ì•Šë„ë¡ ìƒíƒœ ë¦¬ì…‹
            window.__planLoading        = true;
            window.__planTier           = null;
            window.__planName           = null;
            window.__isProUser          = false;
            window.__nodeLimitFromServer = null;
            window.__nodeLimit          = FREE_NODE_LIMIT;
            window.__serverUsageCount   = null;
            window.__dailyFreeLimit     = null;
            updateQuotaInfo();   // â†’ "Loading plan info..." í‘œì‹œ

            try {
                const { data, error } = await supabase
                    .from("subscriptions")
                    .select("plan_tier, plan_name, status")
                    .eq("user_id", user.id)
                    .eq("status", "active")
                    .order("created_at", { ascending: false })
                    .limit(1)
                    .maybeSingle();

                if (error) {
                    console.warn("[UI] failed to load subscription from Supabase:", error);
                    window.__planLoading = false;
                    // ì‹¤íŒ¨ ì‹œì—ëŠ” ì¼ë‹¨ Free ë¡œ ê°„ì£¼
                    if (!window.__planTier) {
                        window.__planTier = "free";
                    }
                    updateQuotaInfo();
                    return;
                }

                const tier      = (data && data.plan_tier) || "free";
                const planName  = data?.plan_name || null;

                window.__planTier  = tier;                         // "free" | "pro" | "expert" | ...
                window.__planName  = planName;
                window.__isProUser = (tier === "pro" || tier === "expert");

                // í”„ë¡ íŠ¸ì—ì„œ ì°¸ê³ ìš© ë…¸ë“œ í•œë„ë„ ê°™ì´ ë„£ì–´ ë‘ 
                if (tier === "expert") {
                    window.__nodeLimit = EXPERT_NODE_LIMIT;
                } else if (tier === "pro") {
                    window.__nodeLimit = PRO_NODE_LIMIT;
                } else {
                    window.__nodeLimit = FREE_NODE_LIMIT;
                }

                window.__planLoading = false;

                // ìƒˆ í”Œëœ ì •ë³´ ë°˜ì˜í•´ì„œ ìƒë‹¨ ë¬¸êµ¬/ëŒ€ì‹œë³´ë“œ ë‹¤ì‹œ ê·¸ë¦¬ê¸°
                updateQuotaInfo();
                try { updateDashboardUI(); } catch (_) {}

            } catch (e) {
                console.error("[UI] refreshPlanFromSupabase error:", e);
                window.__planLoading = false;
                if (!window.__planTier) {
                    window.__planTier = "free";
                }
                updateQuotaInfo();
            }
        }
        
        let currentBranchShape = "rounded";   // ë¶„ê¸° ëª¨ì–‘: ê¸°ë³¸ì€ ë‘¥ê·¼ ì‚¬ê°í˜•
        let savedSourceCode = "";             // HELP ì§„ì… ì „ ì½”ë“œ ì €ì¥ìš©

        function restoreCodeEditor() {
            const codeArea   = document.getElementById("codeArea");
            const codeHeader = document.getElementById("codeHeader");
            const btn        = document.getElementById("helpToggleBtn");

            if (!codeArea || !codeHeader || !btn) return;

            isHelpMode = false;
            isSettingsMode = false;

            btn.textContent = "HELP";
            btn.classList.remove("btn-code-blink");

            let rightText = "Automatic analysis";
            if (typeof window.__nodeCount === "number" && window.__nodeCount > 0) {
                rightText = `Nodes: ${window.__nodeCount}`;
            }

            codeHeader.innerHTML = `
                <span>mAutoFlow</span>
                <span style="opacity:0.7;">${rightText}</span>
            `;

            // âœ… ì´ˆê¸° ìƒíƒœì™€ ë™ì¼í•˜ê²Œ: lineNumbers + textarea ë‘˜ ë‹¤ ë³µì›
            codeArea.innerHTML = `
                <div id="lineNumbers"></div>
                <textarea id="src" spellcheck="false" placeholder="Paste your C / pseudo-C code here."></textarea>
            `;

            const src = document.getElementById("src");
            const lineNumbers = document.getElementById("lineNumbers");

            if (src) {
                src.value = savedSourceCode || "";

                // ì½”ë“œ â†” ë…¸ë“œ ì—°ë™ ì´ë²¤íŠ¸
                ["click", "keyup", "mouseup"].forEach(ev => {
                    src.addEventListener(ev, updateNodeHighlightFromCaret);
                });

                // ìë™ í”Œë¡œìš°ì°¨íŠ¸ ê°±ì‹ 
                src.addEventListener("input", function() {
                    if (typingTimer) clearTimeout(typingTimer);
                    typingTimer = setTimeout(function() {
                        generateFlowchart(true);
                    }, TYPING_DELAY_MS);

                    // ë¼ì¸ ë²ˆí˜¸ë„ ê°™ì´ ê°±ì‹ 
                    if (lineNumbers) updateLineNumbersLocal();
                });
            }

            // ğŸ”¹ ë¼ì¸ ë²ˆí˜¸ ê°±ì‹ ìš© ì‘ì€ í•¨ìˆ˜ (restore ì „ìš©)
            function updateLineNumbersLocal() {
                if (!src || !lineNumbers) return;
                const lines = src.value.split("\n").length || 1;
                let html = "";
                for (let i = 1; i <= lines; i++) {
                    html += i + "<br>";
                }
                lineNumbers.innerHTML = html;
            }

            // ìŠ¤í¬ë¡¤ ë™ê¸°í™”
            if (src && lineNumbers) {
                src.addEventListener("scroll", () => {
                    lineNumbers.scrollTop = src.scrollTop;
                });

                // ì´ˆê¸° í•œ ë²ˆ ì¶œë ¥
                updateLineNumbersLocal();
            }
        }


        function toggleHelp() {
            const codeArea   = document.getElementById("codeArea");
            const codeHeader = document.getElementById("codeHeader");
            const btn        = document.getElementById("helpToggleBtn");

            if (!codeArea || !codeHeader || !btn) return;

            // ğŸ”¹ í˜„ì¬ CODE ìƒíƒœ â†’ HELP ì§„ì… (SETTINGS ëª¨ë“œë„ ì•„ë‹˜)
            if (!isHelpMode && !isSettingsMode) {
                // í˜„ì¬ ì½”ë“œ ì €ì¥
                const srcNow = document.getElementById("src");
                if (srcNow) {
                    savedSourceCode = srcNow.value;
                } else {
                    savedSourceCode = "";
                }

                isHelpMode = true;
                isSettingsMode = false;

                btn.textContent = "CODE";
                btn.classList.add("btn-code-blink");   // CODE ê¹œë¹¡ì„ ON

                codeHeader.innerHTML = "<span>HELP</span>";
                codeArea.innerHTML = `
                    <div id="helpContent"
                         style="
                            flex: 1;
                            padding: 10px;
                            color: var(--code-text);
                            font-size: 13px;
                            overflow-y: auto;
                        ">
                        ${HELP_TEXT_HTML}
                    </div>
                `;
            }
            // HELP ëª¨ë“œì´ê±°ë‚˜ SETTINGS ëª¨ë“œì¼ ë•Œ â†’ CODEë¡œ ë³µê·€
            else {
                restoreCodeEditor();
            }
        }

        // ============================
        //  Theme ê´€ë¦¬
        // ============================
        let currentTheme = "classic"; // ê¸°ë³¸
        
        function applyTheme(theme) {
            currentTheme = theme;

            // classic ì€ data-theme ì œê±° (ê¸°ë³¸ ìƒ‰ ì‚¬ìš©)
            if (theme === "classic") {
                document.body.removeAttribute("data-theme");
            } else {
                document.body.setAttribute("data-theme", theme);
            }

            // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì— ì €ì¥
            try {
                localStorage.setItem("autoflow-theme", theme);
            } catch (e) {
                // storage ëª»ì“¸ ë•ŒëŠ” ê·¸ëƒ¥ ë¬´ì‹œ
            }
        }

        // SETTINGSë¥¼ HELPì²˜ëŸ¼ ì¢Œì¸¡ ì½”ë“œ ì˜ì—­ì— ë„ìš°ëŠ” ë²„ì „
        function openSettings() {
            const codeArea   = document.getElementById("codeArea");
            const codeHeader = document.getElementById("codeHeader");
            const btn        = document.getElementById("helpToggleBtn");

            if (!codeArea || !codeHeader || !btn) return;

            // ì´ë¯¸ SETTINGS ëª¨ë“œë©´ ë‹¤ì‹œ ëˆŒëŸ¬ë„ ê·¸ëƒ¥ ë¬´ì‹œ
            if (isSettingsMode) return;

            // í˜„ì¬ ì½”ë“œ ì €ì¥ (HELPì™€ ë™ì¼ ë¡œì§)
            const srcNow = document.getElementById("src");
            if (srcNow) {
                savedSourceCode = srcNow.value;
            } else if (!savedSourceCode) {
                savedSourceCode = "";
            }

            isHelpMode = false;
            isSettingsMode = true;

            // HELP ë²„íŠ¼ì„ CODE ëª¨ë“œë¡œ ì „í™˜ + ê¹œë¹¡ì„
            btn.textContent = "CODE";
            btn.classList.add("btn-code-blink");

            // í—¤ë” íƒ€ì´í‹€ì„ SETTINGSë¡œ ë³€ê²½
            codeHeader.innerHTML = "<span>SETTINGS</span>";

            // ê¸°ì¡´ SETTINGS ëª¨ë‹¬ ì•ˆì˜ íŒ¨ë„ ë‚´ìš©ì„ í…œí”Œë¦¿ìœ¼ë¡œ í™œìš©
            const overlay = document.getElementById("settingsOverlay");
            if (overlay) overlay.classList.add("modal-hidden");
            
            const panel   = overlay ? overlay.querySelector(".modal-panel") : null;
            if (!panel) {
                // í˜¹ì‹œ ëª» ì°¾ìœ¼ë©´ ì—ëŸ¬ ë¬¸êµ¬ë§Œ í‘œì‹œ
                codeArea.innerHTML = `
                    <div style="padding:10px; color:var(--code-text); font-size:13px;">
                        SETTINGS panel not found.
                    </div>
                `;
                return;
            }

            // panel.innerHTMLì„ ê·¸ëŒ€ë¡œ ì“°ì§€ ë§ê³ , ë³µì œ í›„ â€œë¶ˆí•„ìš”í•œ ìƒë‹¨ íƒ€ì´í‹€/í—¤ë”(ë˜ëŠ” ì¤‘ë³µ ìš”ì†Œ)â€ë¥¼ ì œê±°í•œë‹¤.
            const panelClone = panel.cloneNode(true);

            // (1) í˜¹ì‹œ ì˜ˆì „ ì½”ë“œê°€ ë‚¨ì•„ modal-headerê°€ ì¡´ì¬í•˜ë©´ ì œê±° (ì¤‘ë³µ SETTINGS ì›ì¸ 1ìˆœìœ„)
            const header = panelClone.querySelector(".modal-header");
            if (header) header.remove();

            // (2) panelClone ìì²´ëŠ” .modal-panelì´ë¯€ë¡œ ë‚´ë¶€ë§Œ êº¼ë‚´ì„œ ì‚¬ìš©
            const panelHTML = panelClone.innerHTML;

            // ì¢Œì¸¡ ì½”ë“œ ì˜ì—­ì— SETTINGS UI ë Œë”ë§
            codeArea.innerHTML = `
              <div id="settingsContent"
                   style="
                     flex: 1;              /* âœ… ì´ê²Œ í•µì‹¬: ì¢Œì¸¡ ì°½ ì „ì²´ í­/ë†’ì´ ì‚¬ìš© */
                     min-width: 0;         /* âœ… flex ìì‹ overflow ë°©ì§€(ê°€ë¡œ ìŠ¤í¬ë¡¤ë°” ì›ì¸ ì œê±°) */
                     width: 100%;
                     padding: 10px;        /* HELPì²˜ëŸ¼ ì ë‹¹íˆ ì—¬ë°± (ì›í•˜ë©´ 0ìœ¼ë¡œ) */
                     color: var(--code-text);
                     font-size: 13px;
                     overflow-y: auto;
                     overflow-x: hidden;   /* âœ… ê°€ë¡œ ìŠ¤í¬ë¡¤ ì œê±°(í•„ìš”ì‹œ) */
                   ">
                ${panelHTML}
              </div>
            `;


            // ìƒˆë¡œ ìƒê¸´ SETTINGS DOM ê¸°ì¤€ìœ¼ë¡œ ë¼ë””ì˜¤ ì´ˆê¸°í™”/ì´ë²¤íŠ¸ ì—°ê²°
            const settingsRoot = document.getElementById("settingsContent");
            initSettingsRadios(settingsRoot);
        }

        async function openShare() {
          if (getShareIdFromPath()) {
            setStatus("info", "This is a shared view-only page.");
            return;
          }  
            
          // ë¡œê·¸ì¸í•œ ì‚¬ìš©ìë§Œ
          if (!window.currentUser) {
            alert("Please log in to use Share.");
            return;
          }

          const overlay = document.getElementById("shareOverlay");
          const input = document.getElementById("shareLinkInput");
          const hint  = document.getElementById("shareHint");

          if (!overlay || !input) return;

          overlay.classList.remove("modal-hidden");
          input.value = "";
          if (hint) hint.textContent = "Generating share link...";

          // âœ… 1) ë§ˆì§€ë§‰ ìƒì„±ëœ mermaid code í™•ë³´
          const mermaid_code = (window.__lastMermaidCode || "").trim();
          if (!mermaid_code) {
            if (hint) hint.textContent = "No flowchart to share yet. Please generate a flowchart first.";
            return;
          }

          // âœ… 2) access_token í™•ë³´
          let accessToken = null;
          try {
            const session = supabase.auth.getSession
              ? (await supabase.auth.getSession()).data.session
              : null;
            if (session?.access_token) accessToken = session.access_token;
          } catch (e) {}

          if (!accessToken) {
            if (hint) hint.textContent = "Login session not found. Please log in again.";
            return;
          }

          // âœ… 3) ë°±ì—”ë“œì— share ìƒì„± ìš”ì²­ (FormDataë¡œ!)
          try {
            const formData = new FormData();
            formData.append("mermaid_code", mermaid_code);
            formData.append("access_token", accessToken);

            const res = await fetch(`${API_BASE}/api/share/create`, {
              method: "POST",
              body: formData,
            });

            if (!res.ok) {
              let detail = "";
              try { detail = JSON.stringify(await res.json()); } catch(_) {}
              if (hint) hint.textContent = `Share create failed (HTTP ${res.status}). ${detail}`;
              return;
            }

            const data = await res.json();
            const share_id = data.share_id;

            if (!share_id) {
              if (hint) hint.textContent = "Share create failed: share_id missing.";
              return;
            }

            // âœ… 4) ìµœì¢… ë§í¬ êµ¬ì„± (ë„¤ê°€ ì›í•˜ëŠ” í˜•ì‹)
            const url = `${window.location.origin}/share/${share_id}`;
            window.__lastShareId = share_id;

            input.value = url;
            if (hint) hint.textContent = "";
          } catch (e) {
            if (hint) hint.textContent = `Unexpected error: ${e?.message || e}`;
          }
        }

        function closeShare() {
          const overlay = document.getElementById("shareOverlay");
          if (overlay) overlay.classList.add("modal-hidden");
        }

        function copyShareLink() {
          const input = document.getElementById("shareLinkInput");
          const hint  = document.getElementById("shareHint");
          if (!input || !input.value) return;

          navigator.clipboard.writeText(input.value)
            .then(() => { if (hint) hint.textContent = "Copied!"; })
            .catch(() => { if (hint) hint.textContent = "Copy failed. Please copy manually."; });
        }
                   

        // ============================
        //  SHARE í˜ì´ì§€ ë¡œë”©(/share/<id>)
        // ============================

        function getShareIdFromPath() {
          // ì˜ˆ: /share/4e9203e9-0602-42d4-9016-b1b9a8a04ecc
          const m = window.location.pathname.match(/^\/share\/([0-9a-fA-F-]{36})\/?$/);
          return m ? m[1] : null;
        }

        async function renderSharedMermaid(mermaidCode) {
          const chartInner = document.getElementById("chartInner");
          if (!chartInner) return;

          chartInner.innerHTML = `<div class="mermaid">${mermaidCode}</div>`;

          try {
            // âœ… ë¨¼ì € ë¬¸ë²•/êµ¬ì¡° ê²€ì¦ (ì—¬ê¸°ì„œ ê±¸ë¦¬ë©´ init í•˜ì§€ ì•ŠìŒ)
            await mermaid.parse(mermaidCode);

            // âœ… ê²€ì¦ í†µê³¼ ì‹œì—ë§Œ ë Œë”
            await mermaid.init(undefined, chartInner.querySelector(".mermaid"));
          } catch (e) {
            console.error("Mermaid render failed:", e);
            chartInner.innerHTML = `
              <p class="placeholder" style="color:#b91c1c;">
                Mermaid render failed: ${e?.message || e}
              </p>`;
            return;
          }


          // ê¸°ì¡´ ì½”ë“œì— ìˆëŠ” í™•ëŒ€/í´ë¦­í•¸ë“¤ëŸ¬ë„ ê·¸ëŒ€ë¡œ ì¬ì‚¬ìš©
          try { applyDiagramZoom(); } catch(e) {}
          try { setTimeout(attachNodeClickHandlers, 50); } catch(e) {}

          // âœ… ê³µìœ  í˜ì´ì§€ëŠ” ë¬´ì¡°ê±´ 100%ë¡œ ì‹œì‘(ìë™ë§ì¶¤ X)
          setTimeout(() => {
            try { zoomReset(); } catch(_) {}
          }, 80);
        }

        function applyShareViewMode() {
          const hide = (sel) => {
            const el = document.querySelector(sel);
            if (el) el.style.display = "none";
          };

          hide("#loggedOutButtons");
          hide("#loggedInButtons");
          hide('button[onclick="openShare()"]');
          hide('button[onclick="downloadDiagram()"]');
          hide('button[onclick="openSettings()"]');
          hide("#helpToggleBtn");
          hide('button[onclick="openProCheckout()"]');

          const regenBtn = document.querySelector('#toolbar button[onclick^="generateFlowchart"]');
          if (regenBtn) regenBtn.style.display = "none";

          const subtitle = document.querySelector("header .subtitle");
          if (subtitle) subtitle.style.display = "none";

          const header = document.querySelector("header");
          if (header) header.style.padding = "6px 12px";

          const h1 = document.querySelector("header h1");
          if (h1) h1.style.fontSize = "18px";

          // âœ… ì—¬ê¸°ì„œë§Œ í•œ ë²ˆì”© ì„ ì–¸
          const src = document.getElementById("src");
          if (src) src.disabled = true;

          const leftPane = document.getElementById("leftPane");
          if (leftPane) leftPane.style.display = "none";

          const divider = document.getElementById("divider");
          if (divider) divider.style.display = "none";

          const rightPane = document.getElementById("rightPane");
          if (rightPane) {
            rightPane.style.flex = "1 1 100%";
            rightPane.style.minWidth = "0";
            rightPane.style.width = "100%";
            rightPane.style.padding = "6px";
          }

          const chartInner = document.getElementById("chartInner");
          if (chartInner) chartInner.style.margin = "0";
        }


        // ============================
        //  HTML entity decode helpers
        // ============================
        function decodeHtmlEntitiesOnce(str) {
          if (!str || typeof str !== "string") return str;
          const textarea = document.createElement("textarea");
          textarea.innerHTML = str;
          return textarea.value;
        }

        // &amp;amp; ê°™ì€ "ì¤‘ë³µ escape"ë¥¼ 2~3ë²ˆ í’€ì–´ì£¼ëŠ” ìš©ë„
        function decodeHtmlEntitiesDeep(str, maxIter = 3) {
          let out = str;
          for (let i = 0; i < maxIter; i++) {
            const next = decodeHtmlEntitiesOnce(out);
            if (next === out) break;
            out = next;
          }
          return out;
        }


        async function loadSharedDiagram(shareId) {
          try {
            const res = await fetch(`${API_BASE}/api/share/${shareId}`);

            if (!res.ok) {
              // âœ… ë§Œë£Œ/ì‚­ì œ/ì—†ìŒì€ 404ë¡œ í†µì¼ â†’ ë¬¸êµ¬ë„ í†µì¼
              if (res.status === 404) {
                setStatus("error", "Expired or removed");
                return;
              }

              const txt = await res.text().catch(() => "");
              setStatus("error", `Share load failed (HTTP ${res.status}) ${txt}`);
              return;
            }

            const data = await res.json();
            let mermaidCode = (data.mermaid_code || "").trim();
            mermaidCode = decodeHtmlEntitiesDeep(mermaidCode, 3);

            // ğŸ‘‡ Mermaid ë¬¸ë²• ê¹¨ì§ˆ ê²½ìš° ëŒ€ë¹„(ì„ íƒ)
            if (mermaidCode.includes("&amp;")) {
               console.warn("âš ï¸ Mermaid code still contains &amp; after decode");
            }
            
            if (!mermaidCode) {
              setStatus("error", "Shared diagram is empty.");
              return;
            }

            window.__lastMermaidCode = mermaidCode;

            const src = document.getElementById("src");
            if (src) {
              src.value = "/* Shared diagram (read-only) */";
              src.disabled = true;
            }

            await renderSharedMermaid(mermaidCode);
            setStatus("success", "Shared diagram loaded.");
          } catch (e) {
            console.error(e);
            setStatus("error", "Failed to load shared diagram.");
          }
        }


        // ============================
        //  Download í—¬í¼ë“¤
        // ============================

        // í˜„ì¬ í•¨ìˆ˜ ì´ë¦„ ê¸°ì¤€ìœ¼ë¡œ íŒŒì¼ëª… ë§Œë“¤ê¸°
        function getCurrentFilename(ext) {
            const labelEl = document.getElementById("currentFunc");
            let base = "autoflow_diagram";

            if (labelEl && labelEl.textContent) {
                const txt = labelEl.textContent;

                // "í•¨ìˆ˜: Foo()" ë˜ëŠ” "Function : Foo()" ë‘˜ ë‹¤ ì§€ì›
                const m = txt.match(/(?:í•¨ìˆ˜|Function)\s*:\s*([^(]+)/);
                if (m && m[1]) {
                    base = m[1].trim();
                }
            }
            return base + "." + ext;
        }

        function triggerDownload(url, filename) {
            const a = document.createElement("a");
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }

        // SVG ë‹¤ìš´ë¡œë“œ
        function downloadAsSVG() {
            const svg = document.querySelector("#chartInner svg");
            if (!svg) {
                alert("There is no flowchart to download yet.");
                return;
            }

            const cloned = svg.cloneNode(true);
            cloned.setAttribute("xmlns", "http://www.w3.org/2000/svg");

            const serializer = new XMLSerializer();
            const source = serializer.serializeToString(cloned);
            const blob = new Blob([source], { type: "image/svg+xml;charset=utf-8" });
            const url = URL.createObjectURL(blob);

            triggerDownload(url, getCurrentFilename("svg"));
            setTimeout(() => URL.revokeObjectURL(url), 1000);
        }


        // PNG ë‹¤ìš´ë¡œë“œ (í”„ë¡ íŠ¸ì—ì„œ SVG -> Canvas ë³€í™˜) + ì˜µì…˜(Scale/BG/Padding)
        async function downloadAsPNG() {
          const svg = document.querySelector("#chartInner svg");
          if (!svg) {
            alert("There is no flowchart to download yet.");
            return;
          }

          // âœ… Settingsì—ì„œ ì €ì¥í•œ PNG ì˜µì…˜ ì½ê¸°
          let scale = 2;
          let bg = "white";

          try {
            scale = parseFloat(localStorage.getItem("autoflow-png-scale") || "2");
            bg = localStorage.getItem("autoflow-png-bg") || "white";
            bg = String(bg || "white").toLowerCase().trim();
          } catch (e) {}

          // ë°©ì–´
          if (!Number.isFinite(scale) || scale <= 0) scale = 2;
          if (bg !== "transparent") bg = "white";

          // 1) SVG ë³µì œ + xmlns ë³´ì¥
          const cloned = svg.cloneNode(true);
          cloned.setAttribute("xmlns", "http://www.w3.org/2000/svg");

          // 2) í¬ê¸° ê³„ì‚° (viewBox ìš°ì„ , ì—†ìœ¼ë©´ bbox)
          const vb = cloned.viewBox && cloned.viewBox.baseVal ? cloned.viewBox.baseVal : null;

          let width = 0, height = 0;
          if (vb && vb.width && vb.height) {
            width = vb.width;
            height = vb.height;
          } else {
            const bbox = svg.getBBox();
            width = Math.ceil(bbox.width);
            height = Math.ceil(bbox.height);
          }

          if (!width || !height) {
            alert("Failed to determine SVG size for PNG export.");
            return;
          }

          // 3) SVG ë¬¸ìì—´í™”
          const serializer = new XMLSerializer();
          const source = serializer.serializeToString(cloned);

          // 4) Blob URL -> Image ë¡œë“œ -> Canvas draw
          const svgBlob = new Blob([source], { type: "image/svg+xml;charset=utf-8" });
          const url = URL.createObjectURL(svgBlob);

          try {
            const img = new Image();
            img.crossOrigin = "anonymous";

            await new Promise((resolve, reject) => {
              img.onload = resolve;
              img.onerror = reject;
              img.src = url;
            });

            const dpr = window.devicePixelRatio || 1;

            // Chrome/ë¸Œë¼ìš°ì €ì—ì„œ ì•ˆì „í•œ ìº”ë²„ìŠ¤ ìµœëŒ€ì¹˜ ê°€ë“œ(ê²½í—˜ìƒ)
            // (ë„ˆë¬´ í¬ê²Œ ì¡ìœ¼ë©´ ì—¬ì „íˆ ë©”ëª¨ë¦¬ í„°ì§ˆ ìˆ˜ ìˆìŒ)
            const MAX_DIM = 16384; // í•œ ë³€ ìµœëŒ€
            const MAX_PIXELS = 160_000_000; // ì´ í”½ì…€ ìˆ˜ ì œí•œ(ëŒ€ëµ 160MP)

            let effScale = scale;

            // 1) í•œ ë³€ ì œí•œ ê¸°ë°˜ scale ì¶•ì†Œ
            effScale = Math.min(
              effScale,
              MAX_DIM / (width * dpr),
              MAX_DIM / (height * dpr)
            );

            // 2) ì´ í”½ì…€ ì œí•œ ê¸°ë°˜ scale ì¶•ì†Œ
            const pixelsAtScale = (width * dpr * effScale) * (height * dpr * effScale);
            if (pixelsAtScale > MAX_PIXELS) {
              const shrink = Math.sqrt(MAX_PIXELS / pixelsAtScale);
              effScale = effScale * shrink;
            }

            // ìµœì†Œ 0.1 ë¯¸ë§Œì´ë©´ ë„ˆë¬´ ì‘ìœ¼ë‹ˆ ì¤‘ë‹¨(ë˜ëŠ” 1xë¡œ ê°•ì œ)
            if (effScale < 0.1) {
              alert("Diagram is too large to export as PNG in this browser. Try lower scale or export as SVG.");
              return;
            }

            const canvas = document.createElement("canvas");
            canvas.width = Math.max(1, Math.floor(width * dpr * effScale));
            canvas.height = Math.max(1, Math.floor(height * dpr * effScale));

            const ctx = canvas.getContext("2d");
            if (!ctx) {
              alert("Canvas is not supported in this browser.");
              return;
            }

            // âœ… dpr * scale ì ìš© (ê³ í•´ìƒë„)
            ctx.setTransform(dpr * effScale, 0, 0, dpr * effScale, 0, 0);

            // âœ… ë°°ê²½ (white / transparent)
            if (bg === "white") {
              ctx.fillStyle = "#ffffff";
              ctx.fillRect(0, 0, width, height);
            }

            // âœ… padding ë§Œí¼ offset
            ctx.drawImage(img, 0, 0, width, height);

            // 5) PNG ì €ì¥
            let blob = null;

            // âœ… ì—¬ëŸ¬ ë²ˆ ì ì§„ì ìœ¼ë¡œ ì¶•ì†Œ ì¬ì‹œë„
            let tries = 0;
            while (!blob && effScale >= 0.1 && tries < 6) {
              canvas.width  = Math.max(1, Math.floor(width  * dpr * effScale));
              canvas.height = Math.max(1, Math.floor(height * dpr * effScale));
              ctx.setTransform(dpr * effScale, 0, 0, dpr * effScale, 0, 0);

              if (bg === "white") {
                ctx.fillStyle = "#ffffff";
                ctx.fillRect(0, 0, width, height);
              }
              ctx.drawImage(img, 0, 0, width, height);

              blob = await new Promise((resolve) => canvas.toBlob(resolve, "image/png"));

              if (!blob) {
                // âœ… ë‹¤ìŒ ë¼ìš´ë“œì—ì„œ ë” ì¤„ì—¬ì„œ ì¬ì‹œë„
                effScale *= 0.75;
                tries += 1;
              }
            }

            if (!blob) {
              alert("Failed to create PNG blob. Try lowering PNG Scale in Settings, or export as SVG.");
              return;
            }


            const pngUrl = URL.createObjectURL(blob);
            triggerDownload(pngUrl, getCurrentFilename("png"));
            setTimeout(() => URL.revokeObjectURL(pngUrl), 2000);
          } catch (e) {
            console.error(e);
            alert("PNG export failed. (SVG->Canvas render error)");
          } finally {
            URL.revokeObjectURL(url);
          }
        }

        async function downloadFromServer(format) {
          // format: "png" | "pdf"
          if (!window.currentUser) {
            alert("Please log in to download.");
            return;
          }

          // 1) í˜„ì¬ ì½”ë“œ í™•ë³´ (generateFlowchartì™€ ë™ì¼í•˜ê²Œ)
          const srcEl = document.getElementById("src");
          let src = srcEl ? (srcEl.value || "").trim() : "";
          if ((!src || src.length === 0) && typeof savedSourceCode === "string") {
            const saved = savedSourceCode.trim();
            if (saved) src = saved;
          }
          if (!src) {
            alert("There is no code to export yet.");
            return;
          }

          // 2) access_token í™•ë³´
          let accessToken = null;
          try {
            const session = supabase.auth.getSession
              ? (await supabase.auth.getSession()).data.session
              : null;
            if (session?.access_token) accessToken = session.access_token;
          } catch (e) {}

          if (!accessToken) {
            alert("Login session not found. Please log in again.");
            return;
          }

          // 3) macro / branch_shape ë™ì¼ ì „ë‹¬
          const formData = new FormData();
          formData.append("source_code", src);
          formData.append("out_format", format);
          formData.append("branch_shape", currentBranchShape);

          if (macroMode === "defined") {
            const v = (macroDefines || "").trim();
            formData.append("macro_defines", v.length > 0 ? v : "__USE_ELSE_ONLY__");
          }

          formData.append("access_token", accessToken);
          formData.append("user_id", window.currentUser.id);
          formData.append("user_email", window.currentUser.email || "");

          // 4) ì„œë²„ì—ì„œ íŒŒì¼(blob) ë°›ì•„ì„œ ë‹¤ìš´ë¡œë“œ
          const res = await fetch(API_BASE + "/api/export", {
            method: "POST",
            body: formData,
          });

          if (!res.ok) {
            alert(`Export failed (HTTP ${res.status}). Try again.`);
            return;
          }

          const blob = await res.blob();

          // ì„œë²„ê°€ ì£¼ëŠ” íŒŒì¼ëª… ìš°ì„  ì‚¬ìš©
          let filename = getCurrentFilename(format);
          const cd = res.headers.get("content-disposition") || "";
          const m = cd.match(/filename\*=UTF-8''([^;]+)|filename="?([^"]+)"?/i);
          if (m) {
            const raw = m[1] || m[2];
            if (raw) filename = decodeURIComponent(raw);
          }

          const url = URL.createObjectURL(blob);
          triggerDownload(url, filename);
          setTimeout(() => URL.revokeObjectURL(url), 2000);
        }
                    

        // ë‹¤ìš´ë¡œë“œ íƒ€ì…ì— ë”°ë¼ ë¶„ê¸°
        async function downloadDiagram() {
          if (downloadFormat === "png") {
            await downloadAsPNG();   // âœ… í”„ë¡ íŠ¸ ë³€í™˜
          } else {
            downloadAsSVG();
          }
        }
        
        let typingTimer = null;
        const TYPING_DELAY_MS = 600;

        // ë‹¤ì´ì–´ê·¸ë¨ ì¤Œ ìƒíƒœ (ë‚´ìš©ë§Œ í™•ëŒ€, ë ˆì´ì•„ì›ƒì€ ê·¸ëŒ€ë¡œ)
        let diagramZoom = 1.0;

        function clampZoom(z) {
            if (z < 0.5) return 0.5;   // 50%
            if (z > 7.0) return 7.0;   // 700%
            return z;
        }
        function updateZoomLabel() {
            const label = document.getElementById("zoomLabel");
            label.textContent = Math.round(diagramZoom * 100) + "%";
        }

        // ê³µí†µ ì ìš© í•¨ìˆ˜
        function applyDiagramZoom() {
            const svg = document.querySelector("#chartInner svg");
            if (!svg) return;

            // ë‹¤ì´ì–´ê·¸ë¨ì˜ ê¸°ì¤€ í¬ê¸°(100%)ë¥¼ ê¸°ì¤€ìœ¼ë¡œ í™•ëŒ€/ì¶•ì†Œ
            const percent = diagramZoom * 100;
            svg.style.width = percent + "%";
            svg.style.height = "auto";
        }

        // âœ… í™”ë©´ ë§ì¶¤(Fit to screen): í˜„ì¬ SVG ì „ì²´ê°€ ì»¨í…Œì´ë„ˆ ì•ˆì— ë“¤ì–´ì˜¤ë„ë¡ zoom ìë™ ê³„ì‚°
        function fitDiagramToScreen(padding = 16) {
            const container = document.getElementById("chartContainer");
            const svg = document.querySelector("#chartInner svg");
            if (!container || !svg) return;

            // ì»¨í…Œì´ë„ˆ ê°€ìš© ì˜ì—­
            const cw = Math.max(1, container.clientWidth  - padding);
            const ch = Math.max(1, container.clientHeight - padding);

            // SVGì˜ "ê¸°ë³¸" í¬ê¸° ì¶”ì • (Mermaid SVGëŠ” ë³´í†µ width/height ë˜ëŠ” viewBoxê°€ ì¡´ì¬)
            let sw = 0, sh = 0;

            try {
                // 1ìˆœìœ„: viewBox ê¸°ë°˜ (ê°€ì¥ ì•ˆì •ì )
                const vb = svg.viewBox && svg.viewBox.baseVal;
                if (vb && vb.width && vb.height) {
                    sw = vb.width;
                    sh = vb.height;
                }
            } catch (_) {}

            try {
                // 2ìˆœìœ„: width/height ì†ì„±
                if ((!sw || !sh) && svg.width && svg.height) {
                    const w = parseFloat(svg.getAttribute("width"));
                    const h = parseFloat(svg.getAttribute("height"));
                    if (Number.isFinite(w) && Number.isFinite(h)) {
                        sw = w; sh = h;
                    }
                }
            } catch (_) {}

            try {
                // 3ìˆœìœ„: bbox
                if (!sw || !sh) {
                    const bb = svg.getBBox();
                    if (bb && bb.width && bb.height) {
                        sw = bb.width;
                        sh = bb.height;
                    }
                }
            } catch (_) {}

            if (!sw || !sh) return;

            // "ì „ì²´ê°€ ë“¤ì–´ì˜¤ë„ë¡" ë¹„ìœ¨ ê³„ì‚° (ì—¬ìœ ë¥¼ ì¡°ê¸ˆ ì£¼ê³  ì‹¶ìœ¼ë©´ 0.98 ê°™ì€ ê°’ ê³±í•´ë„ ë¨)
            let z = Math.min(cw / sw, ch / sh);

            // ë„ˆë¬´ ì‘ì•„ì§€ì§€ ì•Šê²Œ ìµœì†Œê°’(ê³µìœ  í˜ì´ì§€ì—ì„œ ì‘ì„ ìˆ˜ ìˆì–´ì„œ 0.2 ì •ë„ í—ˆìš©)
            if (z < 0.2) z = 0.2;

            diagramZoom = z;           // âœ… ì „ì—­ ì¤Œ ê°±ì‹ 
            applyDiagramZoom();
            updateZoomLabel();

            // âœ… Fit í›„ì—ëŠ” ì¢Œìƒë‹¨ìœ¼ë¡œ ëª°ë ¤ ë³´ì¼ ìˆ˜ ìˆì–´ì„œ ìƒë‹¨/ì¢Œì¸¡ 0ìœ¼ë¡œ ì´ˆê¸°í™” (ì„ íƒ)
            container.scrollLeft = 0;
            container.scrollTop  = 0;
        }

        

        // âœ… ë¶€ë“œëŸ¬ìš´ ìŠ¤í¬ë¡¤ ì• ë‹ˆë©”ì´ì…˜ (container ì „ìš©)
        function smoothScrollTo(container, targetLeft, targetTop, duration = 260) {
            if (!container) return;

            // ì´ë¯¸ ë¸Œë¼ìš°ì €ê°€ ì§€ì›í•˜ë©´ ì´ê²Œ ì œì¼ ê°„ë‹¨ (ëŒ€ë¶€ë¶„ ì§€ì›)
            // ë‹¨, ì¼ë¶€ í™˜ê²½ì—ì„œ behaviorê°€ containerì— ì˜ ì•ˆ ë¨¹ì„ ë•Œê°€ ìˆì–´ fallbackë„ ê°™ì´ ë‘ .
            try {
                container.scrollTo({ left: targetLeft, top: targetTop, behavior: "smooth" });
                return;
            } catch (_) {}

            // ---- fallback: requestAnimationFrame ê¸°ë°˜ ----
            const startLeft = container.scrollLeft;
            const startTop  = container.scrollTop;
            const deltaLeft = targetLeft - startLeft;
            const deltaTop  = targetTop - startTop;

            const startTime = performance.now();

            // easeOutCubic
            const ease = (t) => 1 - Math.pow(1 - t, 3);

            function tick(now) {
                const elapsed = now - startTime;
                const t = Math.min(1, elapsed / duration);
                const k = ease(t);

                container.scrollLeft = startLeft + deltaLeft * k;
                container.scrollTop  = startTop  + deltaTop  * k;

                if (t < 1) requestAnimationFrame(tick);
            }

            requestAnimationFrame(tick);
        }
        

        // âœ… í”Œë¡œìš°ì°¨íŠ¸ ì»¨í…Œì´ë„ˆ ì•ˆì—ì„œ ë…¸ë“œë¥¼ í™”ë©´ ê°€ìš´ë°ë¡œ "ë¶€ë“œëŸ½ê²Œ" ìŠ¤í¬ë¡¤
        function scrollNodeIntoCenter(node, smooth = true) {
            const container = document.getElementById("chartContainer");
            if (!node || !container) return;

            try {
                // í˜„ì¬ ë·°í¬íŠ¸ ê¸°ì¤€ ì¢Œí‘œ
                const nodeRect = node.getBoundingClientRect();
                const contRect = container.getBoundingClientRect();

                // ì»¨í…Œì´ë„ˆ ë‚´ë¶€ ìŠ¤í¬ë¡¤ ì¢Œí‘œë¡œ ë³€í™˜
                // (ë…¸ë“œì˜ í™”ë©´ ì¢Œí‘œ - ì»¨í…Œì´ë„ˆì˜ í™”ë©´ ì¢Œí‘œ) + í˜„ì¬ scroll ê°’
                const nodeOffsetLeft = (nodeRect.left - contRect.left) + container.scrollLeft;
                const nodeOffsetTop  = (nodeRect.top  - contRect.top)  + container.scrollTop;

                // ë…¸ë“œ ì¤‘ì‹¬ì´ ì»¨í…Œì´ë„ˆ ì¤‘ì‹¬ì— ì˜¤ë„ë¡ ëª©í‘œ scroll ê³„ì‚°
                const targetLeft = nodeOffsetLeft + nodeRect.width  / 2 - container.clientWidth  / 2;
                const targetTop  = nodeOffsetTop  + nodeRect.height / 2 - container.clientHeight / 2;

                // ìŠ¤í¬ë¡¤ ë²”ìœ„ í´ë¨í”„ (ëìœ¼ë¡œ íŠ€ëŠ” ê²ƒ ë°©ì§€)
                const maxLeft = container.scrollWidth  - container.clientWidth;
                const maxTop  = container.scrollHeight - container.clientHeight;

                const clampedLeft = Math.max(0, Math.min(maxLeft, targetLeft));
                const clampedTop  = Math.max(0, Math.min(maxTop, targetTop));

                if (smooth) {
                    smoothScrollTo(container, clampedLeft, clampedTop, 260);
                } else {
                    container.scrollLeft = clampedLeft;
                    container.scrollTop  = clampedTop;
                }
            } catch (e) {
                console.warn("scrollNodeIntoCenter error:", e);
            }
        }
        
        function zoomChange(delta) {
            diagramZoom = clampZoom(diagramZoom + delta);
            applyDiagramZoom();       // â† zoom ì ìš©
            updateZoomLabel();
        }
        function zoomReset() {
            diagramZoom = 1.0;
            applyDiagramZoom();       // â† 100%ë¡œ
            updateZoomLabel();
        }

        let __chartInteractionsInited = false;

        function initChartInteractions() {
            if (__chartInteractionsInited) return;
            __chartInteractionsInited = true;

            const chartContainer = document.getElementById("chartContainer");
            if (!chartContainer) return;

            // âœ… Ctrl+íœ : "í¬ì¸í„°(ë§ˆìš°ìŠ¤ ìœ„ì¹˜) ì¤‘ì‹¬" ì¤Œ
            chartContainer.addEventListener("wheel", function (e) {
                if (!e.ctrlKey) return;

                // ë¸Œë¼ìš°ì € ê¸°ë³¸ í˜ì´ì§€ ì¤Œ ë°©ì§€
                e.preventDefault();

                const rect = chartContainer.getBoundingClientRect();

                // ì»¨í…Œì´ë„ˆ ë‚´ë¶€ì—ì„œ ë§ˆìš°ìŠ¤ ìœ„ì¹˜(px)
                const offsetX = e.clientX - rect.left;
                const offsetY = e.clientY - rect.top;

                // ì¤Œ ì „ ìŠ¤í¬ë¡¤(px)
                const prevScrollLeft = chartContainer.scrollLeft;
                const prevScrollTop  = chartContainer.scrollTop;

                // ì¤Œ ì „ ì¤Œê°’
                const prevZoom = diagramZoom;

                // âœ… í˜„ì¬ ë§ˆìš°ìŠ¤ê°€ ê°€ë¦¬í‚¤ëŠ” "ì½˜í…ì¸  ì¢Œí‘œ(ì¤Œ ì œê±° ì¢Œí‘œ)"
                const contentX = (prevScrollLeft + offsetX) / prevZoom;
                const contentY = (prevScrollTop  + offsetY) / prevZoom;

                // ì¤Œ ë³€í™”ëŸ‰
                const delta = (e.deltaY < 0) ? +0.1 : -0.1;

                // âœ… ì¤Œê°’ ê°±ì‹  + ì ìš©
                diagramZoom = clampZoom(diagramZoom + delta);
                applyDiagramZoom();
                updateZoomLabel();

                // âœ… ì¤Œ í›„ì—ë„ ê°™ì€ ì½˜í…ì¸ ê°€ ê°™ì€ í™”ë©´ ìœ„ì¹˜ì— ìœ ì§€ë˜ë„ë¡ ìŠ¤í¬ë¡¤ ë³´ì •
                requestAnimationFrame(() => {
                    chartContainer.scrollLeft = (contentX * diagramZoom) - offsetX;
                    chartContainer.scrollTop  = (contentY * diagramZoom) - offsetY;
                });
            }, { passive: false });


            // âœ… ì¢Œí´ë¦­ ë“œë˜ê·¸ë¡œ íŒ¨ë‹
            let isPanning = false;
            let startX = 0;
            let startY = 0;
            let startScrollLeft = 0;
            let startScrollTop = 0;

            chartContainer.addEventListener("mousedown", function(e) {
                if (e.button !== 0) return;
                isPanning = true;
                startX = e.clientX;
                startY = e.clientY;
                startScrollLeft = chartContainer.scrollLeft;
                startScrollTop = chartContainer.scrollTop;
                e.preventDefault();
            });

            document.addEventListener("mousemove", function(e) {
                if (!isPanning) return;
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                chartContainer.scrollLeft = startScrollLeft - dx;
                chartContainer.scrollTop  = startScrollTop - dy;
            });

            document.addEventListener("mouseup", function() {
                isPanning = false;
            });
        }

        

        // ============================
        //  Status / Error helpers
        // ============================
        function setStatus(type, message) {
            const status = document.getElementById("status");
            if (!status) return;

            // type: "success" | "error" | "info" | "idle"
            let icon = "";
            if (type === "success") icon = "âœ…";
            else if (type === "error") icon = "âŒ";
            else if (type === "info") icon = "â„¹ï¸";

            status.className = "";  // ê¸°ì¡´ í´ë˜ìŠ¤ ì œê±°
            if (type === "success") status.classList.add("success");
            if (type === "error")   status.classList.add("error");

            status.textContent = icon ? `${icon} ${message}` : message;
        }

        function showMacroUpgradePrompt() {
          // 1) ìƒíƒœ ë©”ì‹œì§€
          setStatus("error", "Macro Defines is available on Pro/Expert. Please upgrade to use this feature.");

          // 2) í”Œë¡œìš°ì°¨íŠ¸ ì˜ì—­ì—ë„ ì•ˆë‚´ ë¬¸êµ¬
          const chartInner = document.getElementById("chartInner");
          if (chartInner) {
            chartInner.innerHTML = `
              <p class="placeholder" style="color:#b91c1c;">
                Macro Defines (Defined mode) is a Pro/Expert feature.<br/>
                Please upgrade to enable macro-based preprocessing.
              </p>
            `;
          }

          // 3) UPGRADE ë²„íŠ¼ ë¸”ë§í¬
          const ub = document.getElementById("upgradeButton");
          if (ub) {
            const tier = window.__planTier || (window.__isProUser ? "pro" : "free");
            const shouldShow = (tier === "free") && !window.__isTestAccount;

            ub.style.display = shouldShow ? "inline-flex" : "none";
            if (shouldShow) ub.classList.add("upgrade-blink");
          }
        }
                

        // ë°±ì—”ë“œì—ì„œ ë‚´ë ¤ì˜¤ëŠ” ì—ëŸ¬ ì½”ë“œë¥¼ ë³´ê¸° ì¢‹ê²Œ ë§¤í•‘
        function mapBackendError(errorCode, rawError) {
            const msg  = (rawError || "").toString();
            const code = (errorCode || "").toString().toUpperCase();

            // 1) ëª…ì‹œì  ì½”ë“œ ìš°ì„ 
            if (code === "NO_FUNCTION") {
                return "No function body was found in the code.";
            }
            if (code === "TOO_MANY_NODES") {
                return "The function is too large to analyze (too many flowchart nodes).";
            }
            if (code === "UNSUPPORTED_SYNTAX") {
                return "The code uses syntax that is not supported yet (for example, 'goto' inside 'switch').";
            }

            // 2) ì½”ë“œê°€ ì—†ìœ¼ë©´ ë©”ì‹œì§€ íŒ¨í„´ìœ¼ë¡œ ì¶”ë¡ 
            if (/no function/i.test(msg)) {
                return "No function body was found in the code.";
            }
            if (/too many nodes/i.test(msg)) {
                return "The function is too large to analyze (too many flowchart nodes).";
            }
            if (/unsupported/i.test(msg)) {
                return "The code uses syntax that is not supported yet.";
            }

            // 3) ì¼ë‹¨ ì•Œ ìˆ˜ ì—†ëŠ” ì—ëŸ¬ëŠ” ì›ë¬¸ì„ ê´„í˜¸ë¡œ ë‚¨ê²¨ì¤Œ
            if (msg) {
                return `Failed to generate the flowchart. (${msg})`;
            }
            return "Failed to generate the flowchart due to an unknown error.";
        }


        // ============================
        //  ì½”ë“œ ë¼ì¸ í•˜ì´ë¼ì´íŠ¸ ê´€ë ¨ í•¨ìˆ˜ë“¤
        // ============================

        // ë§¤ì¹­ìš© ë¬¸ìì—´ ì •ê·œí™” (ê³µë°±/ê´„í˜¸/ì„¸ë¯¸ì½œë¡  ë“± ì •ë¦¬)
        function normalizeForMatch(s) {
            if (!s) return "";
            return String(s)
                .toLowerCase()
                .replace(/["']/g, "")       // ë”°ì˜´í‘œ ì œê±°
                .replace(/[{};]/g, "")      // ì¤‘ê´„í˜¸/ì„¸ë¯¸ì½œë¡  ì œê±°
                .replace(/\s+/g, " ")       // ì—¬ëŸ¬ ê³µë°± -> í•œ ì¹¸
                .trim();
        }

        // ============================
        //  ì½”ë“œ ë¼ì¸ â†’ ë…¸ë“œ í•˜ì´ë¼ì´íŠ¸
        // ============================

        // ì„ íƒëœ ë…¸ë“œ í•˜ì´ë¼ì´íŠ¸ í•´ì œ
        function clearNodeHighlight() {
            const svg = document.querySelector("#chartInner svg");
            if (!svg) return;
            svg.querySelectorAll(".node.autoflow-selected").forEach(n => {
                n.classList.remove("autoflow-selected");
            });
        }

        // ë…¸ë“œ ë¼ë²¨ì—ì„œ "í•µì‹¬ í•œ ì¤„"ë§Œ ë½‘ê¸° (if ì¤„ + ëŒ€ì…ë¬¸ ê°™ì´ ìˆì„ ë•Œ ëŒ€ë¹„)
        function getNodeLabelCore(node) {
            const rawText = (node.textContent || "").trim();
            if (!rawText) return "";

            if (rawText.indexOf("\n") !== -1) {
                const parts = rawText.split(/\n/).map(p => p.trim()).filter(Boolean);
                if (parts.length > 0) {
                    // ê°€ì¥ ì§§ì€ í•œ ì¤„ì„ ëŒ€í‘œ ë¼ë²¨ë¡œ ì‚¬ìš©
                    return parts.reduce((a, b) => (a.length <= b.length ? a : b));
                }
            }
            return rawText;
        }

        // í˜„ì¬ ì¤„ê³¼ ë…¸ë“œ ë¼ë²¨ì˜ ë§¤ì¹­ ì ìˆ˜ ê³„ì‚°
        function calcMatchScore(normLine, normLabel) {
            if (!normLine || !normLabel) return 0;

            if (normLine === normLabel) return 3.0;  // ì™„ì „ ì¼ì¹˜ ìµœìš°ì„ 

            if (normLine.indexOf(normLabel) !== -1) {
                // ë¼ë²¨ì´ ì¤„ ì•ˆì— í¬í•¨
                return normLabel.length / Math.max(1, normLine.length);
            }
            if (normLabel.indexOf(normLine) !== -1) {
                // ì¤„ì´ ë¼ë²¨ ì•ˆì— í¬í•¨
                return normLine.length / Math.max(1, normLabel.length);
            }
            return 0;
        }

        // íŠ¹ì • ë¼ì¸ ë²ˆí˜¸ì— ë§¤í•‘ëœ "ê°€ì¥ ì˜ ë§ëŠ”" ë…¸ë“œë¥¼ ì°¾ì•„ í•˜ì´ë¼ì´íŠ¸ + ìŠ¤í¬ë¡¤
        function highlightNodesForLine(lineIdx) {
            const svg = document.querySelector("#chartInner svg");
            if (!svg) return;

            const textarea = document.getElementById("src");
            if (!textarea) return;

            const code = textarea.value || "";
            const lines = code.split("\n");
            if (!lines.length) return;

            // ë¼ì¸ ì¸ë±ìŠ¤ ë³´ì •
            let idx = lineIdx;
            if (idx < 0) idx = 0;
            if (idx >= lines.length) idx = lines.length - 1;

            const normLine = normalizeForMatch(lines[idx]);
            if (!normLine) {
                clearNodeHighlight();
                return;
            }

            const nodeLines = window.__nodeLines || {};

            clearNodeHighlight();

            const nodes = svg.querySelectorAll(".node");
            const container = document.getElementById("chartContainer");

            let bestNode = null;
            let bestScore = 0;
            let bestDist = Infinity;

            nodes.forEach(node => {
                const rawId = node.getAttribute("id") || "";
                const m = rawId.match(/(?:flowchart-)?(N\d+)/);
                if (!m) return;
                const nodeKey = m[1];   // N1, N2 ...

                const mappedLine = nodeLines[nodeKey];

                const coreLabel = getNodeLabelCore(node);
                const normLabel = normalizeForMatch(coreLabel);
                if (!normLabel) return;

                const score = calcMatchScore(normLine, normLabel);
                if (score <= 0) return;   // ì „í˜€ ì•ˆ ë§ìœ¼ë©´ í›„ë³´ ì œì™¸

                // body_start_line í•œ ì¹¸ ì˜¤ì°¨ ê°™ì€ ê²½ìš°ë¥¼ ìœ„í•´ "ë¼ì¸ ê±°ë¦¬"ë„ ê°™ì´ ê³ ë ¤
                const dist = (typeof mappedLine === "number")
                    ? Math.abs(mappedLine - idx)
                    : Infinity;

                if (
                    score > bestScore ||
                    (score === bestScore && dist < bestDist)
                ) {
                    bestScore = score;
                    bestDist = dist;
                    bestNode = node;
                }
            });

            if (!bestNode) return;

            bestNode.classList.add("autoflow-selected");

            // ì¤Œ ìƒíƒœì™€ ìƒê´€ì—†ì´, í•­ìƒ í™”ë©´ ì¤‘ì•™ìœ¼ë¡œ ê°€ì ¸ì˜¤ê¸°
            scrollNodeIntoCenter(bestNode);
        }

        // í…ìŠ¤íŠ¸ ì»¤ì„œ ìœ„ì¹˜ ê¸°ì¤€ìœ¼ë¡œ í˜„ì¬ ë¼ì¸ ê³„ì‚° â†’ ë…¸ë“œ í•˜ì´ë¼ì´íŠ¸
        function updateNodeHighlightFromCaret() {
            const textarea = document.getElementById("src");
            if (!textarea) return;

            const pos = textarea.selectionStart || 0;
            const textBefore = textarea.value.slice(0, pos);
            const lineIdx = textBefore.split("\n").length - 1;

            highlightNodesForLine(lineIdx);
        }

        // lineIdx ì— í•´ë‹¹í•˜ëŠ” ì¤„ì„ ê·¸ëŒ€ë¡œ í•˜ì´ë¼ì´íŠ¸ (fallback ìš©)
        function highlightCodeAtLine(lineIdx) {
            const textarea = document.getElementById("src");
            if (!textarea) return -1;

            const code  = textarea.value;
            const lines = code.split("\n");
            if (!lines.length) return -1;

            // ì¸ë±ìŠ¤ ë³´ì •
            let idx = lineIdx;
            if (idx < 0) idx = 0;
            if (idx >= lines.length) idx = lines.length - 1;

            // ì„ íƒ ë²”ìœ„ ê³„ì‚°
            let start = 0;
            for (let i = 0; i < idx; i++) {
                start += lines[i].length + 1; // '\n'
            }
            const end = start + lines[idx].length;

            textarea.focus();
            textarea.setSelectionRange(start, end);

            // ê°€ìš´ë° ì¯¤ìœ¼ë¡œ ìŠ¤í¬ë¡¤
            const ratio        = idx / Math.max(1, lines.length - 1);
            const targetScroll = textarea.scrollHeight * ratio - textarea.clientHeight / 2;
            textarea.scrollTop = Math.max(0, targetScroll);

            return idx;
        }


        // ë…¸ë“œ ë¼ë²¨ + (ì„ íƒ) ëŒ€ëµ ë¼ì¸ ìœ„ì¹˜ íŒíŠ¸ë¡œ ì½”ë“œ ë¼ì¸ í•˜ì´ë¼ì´íŠ¸
        // -> ì°¾ì€ ë¼ì¸ ì¸ë±ìŠ¤ë¥¼ ë°˜í™˜ (ì—†ìœ¼ë©´ -1)
        function highlightCodeForLabel(rawLabel, approxLineHint) {
            const textarea = document.getElementById("src");
            if (!textarea) return -1;

            const code = textarea.value;
            if (!code) return -1;

            const lines = code.split("\n");

            // Mermaidê°€ í•œ ë…¸ë“œì— ì—¬ëŸ¬ ì¤„ í…ìŠ¤íŠ¸ë¥¼ ë„£ëŠ” ê²½ìš° ëŒ€ë¹„:
            //    - if ì¤„ + ëŒ€ì…ë¬¸ì´ ê°™ì´ ë“¤ì–´ì˜¤ë©´, ë³´í†µ "ëŒ€ì…ë¬¸"ì´ ë” ì§§ìŒ
            //    - ê·¸ë˜ì„œ ì¤„ë°”ê¿ˆ ê¸°ì¤€ìœ¼ë¡œ ë‚˜ëˆ ì„œ "ê°€ì¥ ì§§ì€ í•œ ì¤„"ë§Œ ì„ íƒ
            let core = rawLabel || "";
            if (core.indexOf("\n") !== -1) {
                const parts = core.split(/\n/).map(p => p.trim()).filter(Boolean);
                if (parts.length > 0) {
                    core = parts.reduce((a, b) => (a.length <= b.length ? a : b));
                }
            }

            let label = normalizeForMatch(core);
            if (!label) return -1;

            // ë„ˆë¬´ ê¸¸ë©´ ì• ë¶€ë¶„ë§Œ ì‚¬ìš© (ë§¤ì¹­ìš©)
            if (label.length > 120) {
                label = label.slice(0, 120);
            }

            // 1) ì •í™•íˆ ê°™ì€ ì¤„(eqCandidates)ê³¼
            // 2) ë¶€ë¶„ ì¼ì¹˜(subCandidates)ë¥¼ ë”°ë¡œ ëª¨ì€ë‹¤.
            const eqCandidates = [];
            const subCandidates = [];

            for (let i = 0; i < lines.length; i++) {
                const normLine = normalizeForMatch(lines[i]);
                if (!normLine) continue;

                if (normLine === label) {
                    // ğŸ”¹ ì™„ì „ ì¼ì¹˜ ë¼ì¸
                    eqCandidates.push(i);
                } else {
                    // ğŸ”¹ ë¶€ë¶„ ì¼ì¹˜ (ì´ê±´ ì •í™• ì¼ì¹˜ê°€ í•˜ë‚˜ë„ ì—†ì„ ë•Œë§Œ ì‚¬ìš©í•  ì˜ˆì •)
                    if (
                        normLine.indexOf(label) !== -1 ||      // ë¼ì¸ ì•ˆì— ë¼ë²¨ ë¬¸ìì—´ í¬í•¨
                        (label.indexOf(normLine) !== -1 && normLine.length > 5)
                    ) {
                        subCandidates.push(i);
                    }
                }
            }

            let bestLine = -1;
            let candidates = [];

            // 1ìˆœìœ„: "ì •í™• ì¼ì¹˜" í›„ë³´ê°€ ìˆìœ¼ë©´ ê·¸ê²ƒë§Œ ì‚¬ìš©
            if (eqCandidates.length > 0) {
                candidates = eqCandidates;
            }
            // 2ìˆœìœ„: ì •í™• ì¼ì¹˜ê°€ í•˜ë‚˜ë„ ì—†ì„ ë•Œë§Œ ë¶€ë¶„ ì¼ì¹˜ ì‚¬ìš©
            else if (subCandidates.length > 0) {
                candidates = subCandidates;
            }

            if (candidates.length > 0) {
                // 2) ë…¸ë“œ Yì¢Œí‘œë¡œë¶€í„° ì¶”ì •í•œ ë¼ì¸ ê°€ê¹Œìš´ ê²ƒ ìš°ì„  ì„ íƒ
                if (typeof approxLineHint === "number" && !Number.isNaN(approxLineHint)) {
                    let minDist = Infinity;
                    candidates.forEach(idx => {
                        const d = Math.abs(idx - approxLineHint);
                        if (d < minDist) {
                            minDist = d;
                            bestLine = idx;
                        }
                    });
                } else {
                    // íŒíŠ¸ ì—†ìœ¼ë©´ ì²« ë²ˆì§¸ í›„ë³´ ì‚¬ìš©
                    bestLine = candidates[0];
                }
            } else {
                // 3) ê·¸ë˜ë„ ëª» ì°¾ìœ¼ë©´, ë¼ì¸ë³„ ìœ ì‚¬ë„ ê¸°ë°˜ìœ¼ë¡œ "ê°€ì¥ ë¹„ìŠ·í•œ" í•œ ì¤„ì„ ì°¾ëŠ”ë‹¤.
                let bestScore = 0;
                let bestIdx = -1;

                for (let i = 0; i < lines.length; i++) {
                    const normLine = normalizeForMatch(lines[i]);
                    if (!normLine) continue;

                    const lenLine = normLine.length;
                    const lenLabel = label.length;
                    let score = 0;

                    if (normLine === label) {
                        score = 1.0;
                    } else if (normLine.indexOf(label) !== -1) {
                        // label ì´ ë¼ì¸ ì•ˆì— í¬í•¨
                        score = label.length / lenLine;
                    } else if (label.indexOf(normLine) !== -1) {
                        // ë°˜ëŒ€ë¡œ ë¼ì¸ì´ label ì•ˆì— í¬í•¨
                        score = lenLine / lenLabel;
                    } else {
                        continue;
                    }

                    if (score > bestScore) {
                        bestScore = score;
                        bestIdx = i;
                    }
                }

                if (bestScore > 0) {
                    bestLine = bestIdx;
                }
            }

            if (bestLine < 0 || bestLine >= lines.length) return -1;

            // ì„ íƒí•  ë¬¸ìì—´ì˜ ì‹œì‘/ë ì¸ë±ìŠ¤ ê³„ì‚°
            let start = 0;
            for (let i = 0; i < bestLine; i++) {
                start += lines[i].length + 1; // '\n' í¬í•¨
            }
            const end = start + lines[bestLine].length;

            // í…ìŠ¤íŠ¸ ì˜ì—­ì— ì„ íƒ/í¬ì»¤ìŠ¤
            textarea.focus();
            textarea.setSelectionRange(start, end);

            // ëŒ€ëµì ì¸ ìŠ¤í¬ë¡¤ ìœ„ì¹˜ ì¡°ì •
            const totalLines = lines.length;
            const ratio = bestLine / Math.max(1, totalLines - 1);
            const targetScroll = textarea.scrollHeight * ratio - textarea.clientHeight / 2;
            textarea.scrollTop = Math.max(0, targetScroll);

            return bestLine;
        }

        // Mermaid ë…¸ë“œì— í´ë¦­ í•¸ë“¤ëŸ¬ ì—°ê²°
        function attachNodeClickHandlers() {
            const svg = document.querySelector("#chartInner svg");
            if (!svg) return;

            const nodeLines = window.__nodeLines || {};

            const nodes = svg.querySelectorAll(".node");
            nodes.forEach(node => {
                node.style.cursor = "pointer";
                node.addEventListener("click", () => {
                    // âœ… í´ë¦­ ì‹œì ì— í•­ìƒ ìµœì‹  textareaë¥¼ ë‹¤ì‹œ ê°€ì ¸ì˜¨ë‹¤
                    const textarea = document.getElementById("src");
                    if (!textarea) return;

                    // ì„ íƒëœ ë…¸ë“œ í•˜ì´ë¼ì´íŠ¸
                    clearNodeHighlight();
                    node.classList.add("autoflow-selected");
                    scrollNodeIntoCenter(node);

                    // node id -> N1, N2 ...
                    const rawId = node.getAttribute("id") || "";
                    let nodeKey = rawId;
                    const m = rawId.match(/(?:flowchart-)?(N\d+)/);
                    if (m) {
                        nodeKey = m[1];
                    }

                    // ë…¸ë“œ ë¼ë²¨ í…ìŠ¤íŠ¸
                    const rawText = node.textContent || "";
                    let label = rawText.replace(/\s+/g, " ").trim();
                    if (!label) return;

                    const lower = label.toLowerCase();
                    if (lower === "merge") return;
                    if (lower.startsWith("start")) return;
                    if (lower.startsWith("end")) return;

                    // node_linesì—ì„œ ì˜¨ ë¼ì¸ ë²ˆí˜¸ëŠ” "íŒíŠ¸"ë¡œë§Œ ì‚¬ìš©
                    const mapped = nodeLines[nodeKey];
                    const approxHint =
                        (typeof mapped === "number") ? mapped : null;

                    // 1ì°¨: í•­ìƒ ë¬¸ìì—´ ê¸°ë°˜ ë§¤ì¹­ ì‚¬ìš©
                    let bestLine = highlightCodeForLabel(label, approxHint);

                    // 2ì°¨: í…ìŠ¤íŠ¸ ë§¤ì¹­ì´ ì™„ì „íˆ ì‹¤íŒ¨í•œ ê²½ìš°ì—ë§Œ
                    //      node_lines ë¼ì¸ ë²ˆí˜¸ ê·¸ëŒ€ë¡œ ì‚¬ìš© (fallback)
                    if (bestLine < 0 && typeof mapped === "number") {
                        bestLine = highlightCodeAtLine(mapped);
                    }
                });
            });
        }

        async function generateFlowchart(auto = false) {
            const status      = document.getElementById("status");
            const chartInner  = document.getElementById("chartInner");
            const currentFunc = document.getElementById("currentFunc");

            // ë¡œê·¸ì¸ ìƒíƒœ í™•ì¸
            if (!window.currentUser) {
                setStatus("error", "Please log in to use mAutoFlow.");
                return;
            }

            // í…ŒìŠ¤íŠ¸ ê³„ì • ì—¬ë¶€
            const isTestUser = (window.currentUser.email === TEST_EMAIL);

            const srcEl = document.getElementById("src");

            // ìš°ì„  í˜„ì¬ textarea ê¸°ì¤€ìœ¼ë¡œ ì½”ë“œ ì½ê¸°
            let src = srcEl ? srcEl.value.trim() : "";

            // ë§Œì•½ SETTINGS/HELP ë“±ìœ¼ë¡œ srcê°€ ì—†ê±°ë‚˜ ë¹„ì–´ ìˆì–´ë„,
            //    ì´ì „ì— ì €ì¥í•´ë‘” savedSourceCodeê°€ ìˆìœ¼ë©´ ê·¸ê±¸ ì‚¬ìš©
            if ((!src || src.length === 0) && typeof savedSourceCode === "string") {
                const saved = savedSourceCode.trim();
                if (saved) {
                    src = saved;
                }
            }

            if (!src) {
                if (!auto) {
                    setStatus("info", "Enter your C code on the left to generate a flowchart.");
                } else {
                    setStatus("idle", "");
                }
                currentFunc.textContent = "";
                chartInner.innerHTML = `
                    <p class="placeholder">
                        When you enter C code on the left, a flowchart is automatically generated on the right.
                    </p>`;
                return;
            }

            diagramZoom = 1.0;
            updateZoomLabel();

            setStatus("info", auto ? "Automatically updating the flowchart..." : "Creating the flowchart...");
            chartInner.innerHTML = "";

            const formData = new FormData();
            formData.append("source_code", src);
            formData.append("branch_shape", currentBranchShape);
            formData.append("func_name_style", funcNameStyle);

            // ë¯¸ë‹ˆ ì „ì²˜ë¦¬ê¸°ìš© ë§¤í¬ë¡œ ì •ì˜ ë¬¸ìì—´ ì „ë‹¬
            if (macroMode === "defined") {
              const v = (macroDefines || "").trim();
              if (v.length > 0) {
                formData.append("macro_defines", v);
              } else {
                // Definedì¸ë° ë¹„ì–´ìˆìœ¼ë©´: #else ìª½ì„ íƒ€ê²Œ í•´ì•¼ í•¨
                // (ë°±ì—”ë“œì—ì„œ ì´ ê°’ì„ special-caseë¡œ ì²˜ë¦¬)
                formData.append("macro_defines", "__USE_ELSE_ONLY__");
              }
            }
                        

            try {
                // â‘  Supabaseì—ì„œ access_token ê°€ì ¸ì˜¤ê¸°
                let accessToken = null;
                try {
                    const { data, error } = await supabase.auth.getUser();
                    // data.user ê°€ ìˆê³  session ì´ ìˆìœ¼ë©´ í† í° ì½ê¸°
                    const session = supabase.auth.getSession
                        ? (await supabase.auth.getSession()).data.session
                        : null;

                    if (session?.access_token) {
                        accessToken = session.access_token;
                    }
                } catch (e) {
                    console.warn("Failed to get Supabase user/session", e);
                }


                // ì—¬ê¸°ì„œ FormData ì— access_token í•„ë“œë¥¼ ë„£ì–´ì¤€ë‹¤
                if (accessToken) {
                    console.log(
                        "accessToken from Supabase:",
                        accessToken.slice(0, 20) + "..."   // ì• 20ê¸€ìë§Œ ì°ì–´ì„œ ê¸¸ì´ í™•ì¸
                    );
                    formData.append("access_token", accessToken);
                    // ì¶”ê°€: user_id / user_email
                    if (window.currentUser) {
                        formData.append("user_id", window.currentUser.id);
                        formData.append("user_email", window.currentUser.email || "");
                    }
                } else {
                    setStatus("error", "Login session not found. Please log in again.");
                    return;
                }

                const res = await fetch(API_BASE + "/api/convert_text", {
                    method: "POST",
                    body: formData
                });

                if (!res.ok) {
                    let data = {};
                    try {
                        data = await res.json();
                    } catch (_) {}

                    // ì—ëŸ¬ ì‘ë‹µì—ë„ ê³„ì •/í”Œëœ ì •ë³´ê°€ ë“¤ì–´ì˜¬ ìˆ˜ ìˆìœ¼ë‹ˆ ë¨¼ì € ë°˜ì˜
                    if (typeof data.is_pro_user !== "undefined") {
                        window.__isProUser = !!data.is_pro_user;
                    }
                    if (typeof data.plan_name === "string") {
                        window.__planName = data.plan_name || null;
                    }
                    if (typeof data.is_test_account !== "undefined") {
                        window.__isTestAccount = !!data.is_test_account;
                    }
                    if (typeof data.plan_tier === "string") {
                        window.__planTier = data.plan_tier || null;   // "free" | "pro" | "expert"
                    }
                    if (typeof data.node_limit === "number") {
                        window.__nodeLimitFromServer = data.node_limit;
                        window.__nodeLimit = data.node_limit;
                    }
                    if (typeof data.usage_count === "number") {
                        window.__serverUsageCount = data.usage_count;
                    }
                    if (typeof data.daily_free_limit === "number") {
                        window.__dailyFreeLimit = data.daily_free_limit;
                    }

                    // ë°±ì—”ë“œê°€ í”Œëœ ì •ë³´ë¥¼ ë‚´ë ¤ì¤¬ë‹¤ë©´ ë” ì´ìƒ "ë¡œë”© ì¤‘" ì•„ë‹˜
                    window.__planLoading = false;

                    // ìƒë‹¨ quota ë¼ë²¨ ì—…ë°ì´íŠ¸
                    updateQuotaInfo();
                    

                    // 429: í•˜ë£¨ ë¬´ë£Œ ì‚¬ìš©ëŸ‰ ì´ˆê³¼
                    if (res.status === 429) {
                        let detail = data.detail;

                        // detail ì´ ë¬¸ìì—´ì´ë“  ê°ì²´ë“  ëª¨ë‘ ì²˜ë¦¬
                        let code = null;
                        let usageFromServer = null;
                        let limitFromServer = null;

                        if (typeof detail === "string") {
                            code = detail;
                        } else if (detail && typeof detail === "object") {
                            code = detail.code || detail.detail || "";
                            if (typeof detail.usage_count === "number") {
                                usageFromServer = detail.usage_count;
                            }
                            if (typeof detail.daily_free_limit === "number") {
                                limitFromServer = detail.daily_free_limit;
                            }
                        }

                        code = (code || "").toString().toUpperCase();

                        if (code === "DAILY_LIMIT_EXCEEDED") {
                            if (!isTestUser) {
                                if (usageFromServer != null) {
                                    window.__serverUsageCount = usageFromServer;
                                }
                                if (limitFromServer != null) {
                                    window.__dailyFreeLimit = limitFromServer;
                                }
                                updateQuotaInfo();
                            }

                            setStatus(
                                "error",
                                `Daily free limit reached (${window.__dailyFreeLimit ?? DAILY_FREE_LIMIT} diagrams per day, up to ${FREE_NODE_LIMIT} nodes). Please try again tomorrow.`
                            );
                            chartInner.innerHTML = `
                                <p class="placeholder" style="color:#b91c1c;">
                                    Daily free limit reached. Please try again tomorrow.
                                </p>`;
                            currentFunc.textContent = "";

                            // Free ê³„ì • ì¼ì¼ í•œë„ ì´ˆê³¼ ì‹œì—ë„ UPGRADE ë²„íŠ¼ ë¸”ë§í¬ (Pro ì—…ê·¸ë ˆì´ë“œ ìœ ë„)
                            const ub = document.getElementById("upgradeButton");
                            if (ub && !isTestUser) {
                                ub.style.display = "inline-flex";
                                ub.classList.add("upgrade-blink");
                            }
                            return;
                        }
                    }

                    const errorCode = (data.error_code || data.error || "").toString().toUpperCase();
                    if (errorCode === "TOO_MANY_NODES") {
                        // í”Œëœ/ë…¸ë“œ í•œë„ ê³„ì‚°
                        const tier = window.__planTier || (window.__isProUser ? "pro" : "free");
                        const isTestAccount = !!window.__isTestAccount;

                        let nodeLimit = window.__nodeLimit;
                        if (!Number.isFinite(nodeLimit)) {
                            if (isTestAccount) {
                                nodeLimit = Infinity; // í…ŒìŠ¤íŠ¸ ê³„ì •ì€ ì‚¬ì‹¤ìƒ ë¬´ì œí•œ, ì—¬ê¸° ê±¸ë¦¬ë©´ ì—”ì§„ ìì²´ ìƒí•œ
                            } else if (tier === "expert") {
                                nodeLimit = EXPERT_NODE_LIMIT;
                            } else if (window.__isProUser) {
                                nodeLimit = PRO_NODE_LIMIT;
                            } else {
                                nodeLimit = FREE_NODE_LIMIT;
                            }
                        }

                        // ë°±ì—”ë“œì—ì„œ ë³´ë‚´ì¤„ ìˆ˜ë„ ìˆëŠ” ì‹¤ì œ ë…¸ë“œ ìˆ˜ (ì—†ìœ¼ë©´ null)
                        const nodeCountFromServer =
                            typeof data.node_count === "number"
                                ? data.node_count
                                : (typeof data.actual_nodes === "number"
                                    ? data.actual_nodes
                                    : null);

                        let msgText = "";
                        let bannerText = "";

                        if (isTestAccount || !Number.isFinite(nodeLimit)) {
                            // í…ŒìŠ¤íŠ¸ ê³„ì • + ì—”ì§„ ê¸€ë¡œë²Œ ìƒí•œ ë“±ì— ê±¸ë¦° ì§„ì§œ "ë„ˆë¬´ í¼" ì¼€ì´ìŠ¤
                            msgText = mapBackendError(errorCode, data.error);
                            bannerText = msgText;
                        } else if (tier === "expert") {
                            msgText = `This function has ${nodeCountFromServer ?? "too many"} nodes. The Expert plan supports up to ${nodeLimit} nodes per diagram.`;
                            bannerText = `Expert plan supports up to ${nodeLimit} nodes per diagram.`;
                        } else if (window.__isProUser) {
                            // ğŸ”¹ Pro ìœ ì €
                            msgText = `This function has ${nodeCountFromServer ?? "too many"} nodes. The Pro plan supports up to ${nodeLimit} nodes per diagram.`;
                            bannerText = `Pro plan supports up to ${nodeLimit} nodes per diagram.`;
                        } else {
                            // ğŸ”¹ Free ìœ ì €
                            msgText = `This function has ${nodeCountFromServer ?? "too many"} nodes. The free tier supports up to ${nodeLimit} nodes per diagram.`;
                            bannerText = `Free tier supports up to ${nodeLimit} nodes per diagram.`;
                        }

                        setStatus("error", msgText);
                        chartInner.innerHTML = `
                            <p class="placeholder" style="color:#b91c1c;">
                                ${bannerText}
                            </p>`;
                        currentFunc.textContent = "";

                        // free ë˜ëŠ” pro (expert ë¯¸ë§Œ) ê³„ì •ì—ì„œ UPGRADE ë²„íŠ¼ ê¹œë¹¡ì„
                        const ub = document.getElementById("upgradeButton");
                        if (ub && !isTestAccount && tier !== "expert") {
                            ub.classList.add("upgrade-blink");
                        }

                        return;
                    }

                                    // ê·¸ ì™¸ ì¼ë°˜ ì„œë²„ ì—ëŸ¬
                    setStatus("error", `Server error (${res.status}). Please try again later.`);
                    chartInner.innerHTML = '<p class="placeholder">A server error occurred.</p>';
                    currentFunc.textContent = "";
                    return;
                }
                
                const data = await res.json();
                let mermaidCode = data.mermaid || "";
                // âœ… ë°±ì—”ë“œ/ì¤‘ê°„ ê²½ë¡œì—ì„œ escapeê°€ 2ì¤‘ìœ¼ë¡œ ëœ ê²½ìš°(&amp;amp;)ê¹Œì§€ í’€ì–´ì¤Œ
                mermaidCode = decodeHtmlEntitiesDeep(mermaidCode, 3);
                if (mermaidCode.includes("&amp;")) {
                  console.warn("âš ï¸ Mermaid code still contains &amp; after decode");
                }
                                

                window.__lastMermaidCode = mermaidCode;   // (Shareì—ì„œ ì‚¬ìš©)
                window.__lastShareId = null; // ìƒˆë¡œ ìƒì„±ë˜ë©´ ê°±ì‹ 
                
                const errorMsg      = data.error || "";
                const errorCode     = data.error_code || "";
                const funcName      = data.func_name || "";
                const fullSignature = data.full_signature || "";
                const nodeLines     = data.node_lines || {};

                // ë°±ì—”ë“œì—ì„œ ì˜¨ ê³„ì • ìƒíƒœ ë°˜ì˜
                window.__isProUser      = !!data.is_pro_user;          // Pro + Expert ëª¨ë‘ true
                window.__planName       = data.plan_name || null;
                window.__isTestAccount  = !!data.is_test_account;
                window.__planTier       = data.plan_tier || null;      // "free" | "pro" | "expert"
                window.__nodeLimitFromServer = data.node_limit ?? null;
                window.__planLoading    = false;                       // ğŸ”¹ ì—¬ê¸°ì„œë„ ë¡œë”© ì¢…ë£Œ

                // í”Œëœë³„ ë…¸ë“œ ì œí•œ (í´ë¼ì´ì–¸íŠ¸ ê¸°ì¤€)
                // - í…ŒìŠ¤íŠ¸ ê³„ì •: ì‚¬ì‹¤ìƒ ë¬´ì œí•œ
                let effectiveNodeLimit = FREE_NODE_LIMIT;
                if (window.__isTestAccount) {
                    effectiveNodeLimit = Infinity;              // test account: no limit
                } else if (window.__planTier === "expert") {
                    effectiveNodeLimit = EXPERT_NODE_LIMIT;
                } else if (window.__isProUser) {
                    effectiveNodeLimit = PRO_NODE_LIMIT;
                } else {
                    effectiveNodeLimit = FREE_NODE_LIMIT;
                }

                // ì„œë²„ì—ì„œ node_limit ë¥¼ ë³´ë‚´ì£¼ë©´ ê·¸ ê°’ ìš°ì„  ì‚¬ìš©
                if (typeof data.node_limit === "number") {
                    effectiveNodeLimit = data.node_limit;
                }
                window.__nodeLimit = effectiveNodeLimit;

                // UPGRADE ë²„íŠ¼ í‘œì‹œ/ìˆ¨ê¹€
                const upgradeBtn = document.getElementById("upgradeButton");
                if (upgradeBtn) {
                    // Expert í”Œëœ ë˜ëŠ” í…ŒìŠ¤íŠ¸ ê³„ì •(exitgiveme)ë§Œ UPGRADE ìˆ¨ê¹€
                    const tier = window.__planTier || (window.__isProUser ? "pro" : "free");

                    // âœ… Freeì—ì„œë§Œ ë³´ì—¬ì£¼ê¸°
                    const shouldShow = (tier === "free") && !window.__isTestAccount;

                    upgradeBtn.style.display = shouldShow ? "inline-flex" : "none";
                    upgradeBtn.classList.remove("upgrade-blink");
                }

                // ì„œë²„ì—ì„œ ë‚´ë ¤ì¤€ ì‚¬ìš©ëŸ‰ ì •ë³´ (ì¼ë°˜ ê³„ì •ì¸ ê²½ìš°)
                if (!isTestUser && typeof data.usage_count === "number") {
                    window.__serverUsageCount = data.usage_count;
                }
                if (!isTestUser && typeof data.daily_free_limit === "number") {
                    window.__dailyFreeLimit = data.daily_free_limit;
                }

                if (errorMsg) {
                    const uiMsg = mapBackendError(errorCode, errorMsg);
                    setStatus("error", uiMsg);
                    chartInner.innerHTML = `<p class="placeholder" style="color:#b91c1c;">${uiMsg}</p>`;
                    currentFunc.textContent = "";
                    return;
                }

                const nodeCount = Object.keys(nodeLines).length;
                window.__nodeCount = nodeCount;
                window.__nodeLines = nodeLines;

                const codeHeader = document.getElementById("codeHeader");
                if (codeHeader) {
                    codeHeader.innerHTML = `
                        <span>mAutoFlow</span>
                        <span style="opacity:0.7;">Nodes: ${nodeCount}</span>`;
                }

                // ë…¸ë“œ ì œí•œ (í…ŒìŠ¤íŠ¸ ê³„ì •ì€ ë¬´ì œí•œ)
                // - Free   : ìµœëŒ€ FREE_NODE_LIMIT
                // - Pro    : ìµœëŒ€ PRO_NODE_LIMIT
                // - Expert : ìµœëŒ€ EXPERT_NODE_LIMIT
                if (!isTestUser) {
                    const tier = window.__planTier;

                    // ì„œë²„ê°€ node_limit ë¥¼ ë‚´ë ¤ì£¼ë©´ ê·¸ ê°’ì„ ìš°ì„  ì‚¬ìš©
                    let nodeLimit = window.__nodeLimit;
                    if (!Number.isFinite(nodeLimit)) {
                        if (window.__isTestAccount) {
                            nodeLimit = Infinity;                // í…ŒìŠ¤íŠ¸ ê³„ì • ë¬´ì œí•œ
                        } else if (tier === "expert") {
                            nodeLimit = EXPERT_NODE_LIMIT;
                        } else if (window.__isProUser) {
                            nodeLimit = PRO_NODE_LIMIT;
                        } else {
                            nodeLimit = FREE_NODE_LIMIT;
                        }
                    }

                    // nodeLimit ì´ ìœ í•œí•œ ê°’ì¼ ë•Œë§Œ ì´ˆê³¼ ì²´í¬
                    if (Number.isFinite(nodeLimit) && nodeCount > nodeLimit) {
                        let msgText = "";
                        let bannerText = "";

                        if (tier === "expert") {
                            // Expert ìœ ì €
                            msgText = `This function has ${nodeCount} nodes. The Expert plan supports up to ${nodeLimit} nodes per diagram.`;
                            bannerText = `Expert plan supports up to ${nodeLimit} nodes per diagram.`;
                        } else if (window.__isProUser) {
                            // Pro ìœ ì €
                            msgText = `This function has ${nodeCount} nodes. The Pro plan supports up to ${nodeLimit} nodes per diagram.`;
                            bannerText = `Pro plan supports up to ${nodeLimit} nodes per diagram.`;
                        } else {
                            // Free ìœ ì €
                            msgText = `This function has ${nodeCount} nodes. The free tier supports up to ${nodeLimit} nodes per diagram.`;
                            bannerText = `Free tier supports up to ${nodeLimit} nodes per diagram.`;
                        }

                        setStatus("error", msgText);
                        chartInner.innerHTML = `
                            <p class="placeholder" style="color:#b91c1c;">
                                ${bannerText}
                            </p>`;
                        currentFunc.textContent = "";

                        // UPGRADE ë²„íŠ¼ íŒŒìŠ¤í…” ì—°ë‘ìƒ‰ ë¸”ë§í¬
                        // - Free : Proë¡œ ì—…ê·¸ë ˆì´ë“œ ìœ ë„
                        // - Pro  : Expertë¡œ ì—…ê·¸ë ˆì´ë“œ ìœ ë„
                        const ub = document.getElementById("upgradeButton");
                        if (ub) {
                          const shouldShow = (tier === "free") && !window.__isTestAccount;
                          ub.style.display = shouldShow ? "inline-flex" : "none";
                          if (shouldShow) ub.classList.add("upgrade-blink");
                        }

                        return;
                    }
                }
                
                // ì •ìƒ í”Œë¡œìš°ì°¨íŠ¸ ìƒì„±
                chartInner.innerHTML = `<div class="mermaid">${mermaidCode}</div>`;

                try {
                  await mermaid.parse(mermaidCode);
                  await mermaid.init(undefined, chartInner.querySelector(".mermaid"));
                } catch (e) {
                  console.error("Mermaid render failed:", e);
                  setStatus("error", `Mermaid render failed: ${e?.message || e}`);
                  chartInner.innerHTML = `
                    <p class="placeholder" style="color:#b91c1c;">
                      Mermaid render failed: ${e?.message || e}
                    </p>`;
                  currentFunc.textContent = "";
                  return;
                }

                applyDiagramZoom();
                setTimeout(attachNodeClickHandlers, 50);

                // ì‚¬ìš©ëŸ‰ ì¦ê°€ (í´ë¼ì´ì–¸íŠ¸ ê¸°ì¤€, í…ŒìŠ¤íŠ¸ ê³„ì • ì œì™¸)
                if (!isTestUser) {
                    // ê°™ì€ ì½”ë“œì¸ì§€ ë¹„êµ ìš©ë„ë§Œ í•„ìš”í•˜ë©´ ì´ ì •ë„ë§Œ
                    lastCountedSource = src;
                }

                // ì‚¬ìš©ëŸ‰ ì¦ê°€ ì—†ì´, ë©”ì‹œì§€ë§Œ í‘œì‹œ
                // âœ… ì—¬ê¸°ì„œ í”Œë¡œìš°ì°¨íŠ¸ê°€ "ì„±ê³µì ìœ¼ë¡œ" ìƒì„±ë˜ë©´
                //    UPGRADE ë²„íŠ¼ ê¹œë¹¡ì„ì€ í•­ìƒ ëˆë‹¤.
                if (!isTestUser) {
                    const ub = document.getElementById("upgradeButton");
                    if (ub) ub.classList.remove("upgrade-blink");

                    if (window.__planTier === "expert") {
                        setStatus(
                            "success",
                            `${auto ? "Refresh complete." : "Flowchart creation complete."} Expert plan: up to ${EXPERT_NODE_LIMIT} nodes per diagram.`
                        );
                    } else if (window.__isProUser) {
                        setStatus(
                            "success",
                            `${auto ? "Refresh complete." : "Flowchart creation complete."} Pro plan: up to ${PRO_NODE_LIMIT} nodes per diagram.`
                        );
                    } else {
                        // Free ìœ ì €: ê°€ëŠ¥í•˜ë©´ ì˜¤ëŠ˜ ì‚¬ìš©ëŸ‰ í‘œì‹œ
                        const count = window.__serverUsageCount;
                        const limit = window.__dailyFreeLimit;

                        if (typeof count === "number" && typeof limit === "number") {
                            setStatus(
                                "success",
                                `Refresh complete. Free tier: Today ${count} / ${limit} (â‰¤ ${FREE_NODE_LIMIT} nodes).`
                            );
                        } else {
                            setStatus(
                                "success",
                                `Refresh complete. Free tier: 5 diagrams/day, â‰¤ ${FREE_NODE_LIMIT} nodes.`
                            );
                        }
                    }
                } else {
                    setStatus(
                        "success",
                        `${auto ? "Refresh Complete." : "Flowchart creation complete."} (Test account: unlimited)`
                    );

                    const ub = document.getElementById("upgradeButton");
                    if (ub) ub.classList.remove("upgrade-blink");
                }

                // Function name ì¶œë ¥ ë°©ì‹ ë°˜ì˜ (Short / Full)
                let displayName = funcName;
                if (funcNameStyle === "full" && fullSignature) {
                    displayName = fullSignature;
                }

                currentFunc.textContent = displayName ? `Function: ${displayName}` : "";

                // ìƒë‹¨ ë¬´ë£Œ ì •ì±… ì•ˆë‚´ ê°±ì‹ 
                updateQuotaInfo();

            } catch (err) {
                console.error(err);
                const msg = "An unexpected error occurred while talking to the server. Please try again.";
                setStatus("error", msg);
                chartInner.innerHTML = `<p class="placeholder" style="color:#b91c1c;">${msg}</p>`;
                currentFunc.textContent = "";
            }
        }

        function setupSplitDrag() {
            const main = document.querySelector(".main");
            const leftPane = document.getElementById("leftPane");
            const rightPane = document.getElementById("rightPane");
            const divider = document.getElementById("divider");

            let isDragging = false;

            divider.addEventListener("mousedown", function(e) {
                e.preventDefault();
                isDragging = true;
                document.body.style.cursor = "col-resize";
            });

            document.addEventListener("mousemove", function(e) {
                if (!isDragging) return;
                const rect = main.getBoundingClientRect();
                const totalWidth = rect.width;
                let offsetX = e.clientX - rect.left;
                // ìµœì†Œ/ìµœëŒ€ ë¹„ìœ¨ ì œí•œ (20% ~ 70%)
                let leftPercent = Math.max(0.2, Math.min(0.7, offsetX / totalWidth));
                let rightPercent = 1 - leftPercent;

                leftPane.style.flex = "0 0 " + (leftPercent * 100).toFixed(1) + "%";
                rightPane.style.flex = "0 0 " + (rightPercent * 100).toFixed(1) + "%";
            });

            document.addEventListener("mouseup", function() {
                if (isDragging) {
                    isDragging = false;
                    document.body.style.cursor = "default";
                }
            });
        }


        function initSettingsRadios(root) {
            const scope = root || document;

            // ----- Theme -----
            let savedTheme = "classic";
            try {
                const t = localStorage.getItem("autoflow-theme");
                if (t) savedTheme = t;
            } catch (e) {}
            applyTheme(savedTheme);

            const themeRadios = scope.querySelectorAll('input[name="theme"]');
            themeRadios.forEach(r => {
                if (r.value === savedTheme) {
                    r.checked = true;
                }
                r.addEventListener("change", (e) => {
                    if (e.target.checked) {
                        applyTheme(e.target.value);
                        try {
                            localStorage.setItem("autoflow-theme", e.target.value);
                        } catch (e2) {}
                        // í•„ìš”í•˜ë©´ ìë™ ì¬ìƒì„±
                        // generateFlowchart(true);
                    }
                });
            });

            // ----- Branch Shape -----
            let savedBranchShape = "rounded";
            try {
                const bs = localStorage.getItem("autoflow-branch-shape");
                if (bs) savedBranchShape = bs;
            } catch (e) {}
            currentBranchShape = savedBranchShape;

            const branchRadios = scope.querySelectorAll('input[name="branchShape"]');
            branchRadios.forEach(r => {
                if (r.value === savedBranchShape) {
                    r.checked = true;
                }
                r.addEventListener("change", (e) => {
                    if (e.target.checked) {
                        currentBranchShape = e.target.value;
                        try {
                            localStorage.setItem("autoflow-branch-shape", currentBranchShape);
                        } catch (e2) {}

                        // í•„ìš”í•˜ë©´ í…Œë§ˆì²˜ëŸ¼ ìë™ ì¬ìƒì„±ë„ ê°€ëŠ¥:
                        generateFlowchart(true);
                    }
                });
            });

            // ----- Function Name Display -----
            try {
                const savedStyle = localStorage.getItem("autoflow-funcname-style");
                if (savedStyle) funcNameStyle = savedStyle;
            } catch (e){}

            const funcNameRadios = scope.querySelectorAll('input[name="funcNameStyle"]');
            funcNameRadios.forEach(r => {
                if (r.value === funcNameStyle) {
                    r.checked = true;
                }
                r.addEventListener("change", (e) => {
                    if (e.target.checked) {
                        funcNameStyle = e.target.value;
                        localStorage.setItem("autoflow-funcname-style", funcNameStyle);
                        generateFlowchart(true);
                    }
                });
            });

            // ----- Preprocessor Macros (-D) -----
            // macroMode = "all";
            // macroDefines = "";

            const macroModeRadios = scope.querySelectorAll('input[name="macroMode"]');
            const macroField = scope.querySelector("#macroInput");

            function applyMacroUIState() {
              if (!macroField) return;
              if (macroMode === "defined") {
                macroField.disabled = false;
                // âœ… Definedë¡œ ë“¤ì–´ì˜¤ë©´ í˜„ì¬ UIê°’ì„ ì „ì—­ì—ë„ ë°˜ì˜
                macroDefines = (macroField.value || "").trim();
              } else {
                macroField.disabled = true;
                macroField.value = "";
                macroDefines = "";
                try { localStorage.removeItem("autoflow-macros"); } catch(e) {}
              }
            }

            // ë¼ë””ì˜¤ ì´ë²¤íŠ¸
            macroModeRadios.forEach(r => {
              if (r.value === macroMode) r.checked = true;

              r.addEventListener("change", (e) => {
                if (!e.target.checked) return;

                const nextMode = e.target.value; // all | defined

                // âœ… Lite(=free) ê³„ì •ì—ì„œëŠ” Defined ê¸ˆì§€
                const tier = window.__planTier || (window.__isProUser ? "pro" : "free");
                const isTest = !!window.__isTestAccount || (window.currentUser && window.currentUser.email === TEST_EMAIL);
                const isLite = (!isTest && tier === "free");

                if (nextMode === "defined" && isLite) {
                  // 1) ë¼ë””ì˜¤ ì„ íƒ ë˜ëŒë¦¬ê¸° (Defined ì„ íƒ ë¬´íš¨í™”)
                  macroMode = "all";

                  // scope ì•ˆì—ì„œ ë¼ë””ì˜¤ë¥¼ ë‹¤ì‹œ ì²´í¬ (openSettings cloneì—ì„œë„ ë™ì‘)
                  const allRadio = scope.querySelector('input[name="macroMode"][value="all"]');
                  const defRadio = scope.querySelector('input[name="macroMode"][value="defined"]');
                  if (defRadio) defRadio.checked = false;
                  if (allRadio) allRadio.checked = true;

                  // 2) ì…ë ¥ì°½ ì ê·¸ê³  ê°’ ì •ë¦¬
                  if (macroField) {
                    macroField.disabled = true;
                    macroField.value = "";
                  }
                  macroDefines = "";
                  try { localStorage.removeItem("autoflow-macros"); } catch (_) {}

                  // 3) ê²½ê³  + ì—…ê·¸ë ˆì´ë“œ ìœ ë„
                  showMacroUpgradePrompt();
                  return;
                }

                // âœ… í—ˆìš©ë˜ëŠ” ê³„ì •ì´ë©´ ì •ìƒ ë™ì‘
                macroMode = nextMode;
                applyMacroUIState();
                generateFlowchart(true);
              });
            });

            // textarea ì…ë ¥ ì´ë²¤íŠ¸ (Definedì¼ ë•Œë§Œ ì˜ë¯¸)
            if (macroField) {
              // âœ… (1) ì´ˆê¸°í™” ê¸ˆì§€: ê¸°ì¡´ ê°’ ë³µì›
              // ìš°ì„ ìˆœìœ„: í˜„ì¬ ì „ì—­ macroDefines -> localStorage -> ""
              let saved = "";
              try { saved = localStorage.getItem("autoflow-macros") || ""; } catch (e) {}
              const restored = (macroDefines && macroDefines.trim().length > 0)
                ? macroDefines
                : saved;

              macroField.value = restored;

              // âœ… (2) ì¤‘ë³µ ì´ë²¤íŠ¸ ë°©ì§€ (initSettingsRadiosê°€ ì—¬ëŸ¬ ë²ˆ í˜¸ì¶œë¨)
              if (!macroField.__autoflowBound) {
                macroField.__autoflowBound = true;
                macroField.addEventListener("input", (e) => {
                  macroDefines = (e.target.value || "").trim();
                  try { localStorage.setItem("autoflow-macros", macroDefines); } catch (e2) {}
                  generateFlowchart(true);
                });
              }
            }

            applyMacroUIState();

            // ----- Download Options (SVG/PNG) -----
            try {
              const savedFmt = localStorage.getItem("autoflow-download-format");
              downloadFormat = (savedFmt === "png") ? "png" : "svg";
            } catch (e) {
              downloadFormat = "svg";
            }

            const dlRadios = scope.querySelectorAll('input[name="downloadFormat"]');
            dlRadios.forEach(r => {
              r.checked = (r.value === downloadFormat);

              r.addEventListener("change", () => {
                downloadFormat = (r.value === "png") ? "png" : "svg";
                try { localStorage.setItem("autoflow-download-format", downloadFormat); } catch(e2) {}
              });
            });

            // ----- PNG Options (Scale / Background) -----
            const pngScaleEl   = scope.querySelector("#pngScale");
            const pngBgEl      = scope.querySelector("#pngBg");

            // âœ… ì €ì¥ê°’ ë³µì›
            if (pngScaleEl) {
              let savedScale = "2";
              try { savedScale = localStorage.getItem("autoflow-png-scale") || "2"; } catch (e) {}
              pngScaleEl.value = String(parseFloat(savedScale) || 2);

              // âœ… ì¤‘ë³µ ë°”ì¸ë”© ë°©ì§€
              if (!pngScaleEl.__autoflowBound) {
                pngScaleEl.__autoflowBound = true;
                pngScaleEl.addEventListener("change", () => {
                  const v = parseFloat(pngScaleEl.value || "2");
                  const safe = (Number.isFinite(v) && v > 0) ? v : 2;
                  try { localStorage.setItem("autoflow-png-scale", String(safe)); } catch (e) {}
                });
              }
            }

            if (pngBgEl) {
              let savedBg = "white";
              try { savedBg = localStorage.getItem("autoflow-png-bg") || "white"; } catch (e) {}
              savedBg = String(savedBg || "white").toLowerCase().trim();
              pngBgEl.value = (savedBg === "transparent") ? "transparent" : "white";

              // âœ… ì¤‘ë³µ ë°”ì¸ë”© ë°©ì§€
              if (!pngBgEl.__autoflowBound) {
                pngBgEl.__autoflowBound = true;
                pngBgEl.addEventListener("change", () => {
                  const v = String(pngBgEl.value || "white").toLowerCase().trim();
                  const safe = (v === "transparent") ? "transparent" : "white";
                  try { localStorage.setItem("autoflow-png-bg", safe); } catch (e) {}
                });
              }
            }
        }

        document.addEventListener("DOMContentLoaded", async function() {
            const src = document.getElementById("src");
            const lineNumbers = document.getElementById("lineNumbers");

            // ë¼ì¸ ë²ˆí˜¸ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
            function updateLineNumbers() {
                if (!src || !lineNumbers) return;
                const lines = src.value.split("\n").length || 1;
                let html = "";
                for (let i = 1; i <= lines; i++) {
                    html += i + "<br>";
                }
                lineNumbers.innerHTML = html;
            }

            // ì´ë²¤íŠ¸ ì—°ê²° (ì…ë ¥/ìŠ¤í¬ë¡¤)
            if (src && lineNumbers) {
                src.addEventListener("input", updateLineNumbers);
                src.addEventListener("scroll", () => {
                    lineNumbers.scrollTop = src.scrollTop;  // ìŠ¤í¬ë¡¤ ë™ê¸°í™”
                });
                updateLineNumbers(); // ì´ˆê¸° 1,2,3,... í‘œì‹œ
            }

            // âœ… ê³µìœ  ë§í¬ë¡œ ë“¤ì–´ì˜¨ ê²½ìš°: /share/<id> mermaid_code ë¡œë“œí•´ì„œ ë°”ë¡œ ë Œë”
            const shareId = getShareIdFromPath();
            if (shareId) {
                applyShareViewMode();

                // âœ… (ì¶”ê°€) ê³µìœ  í˜ì´ì§€ì—ì„œë„ Ctrl+íœ  ì¤Œ/ë“œë˜ê·¸ íŒ¨ë‹ ì´ë²¤íŠ¸ë¥¼ ë“±ë¡
                initChartInteractions();
                
                await loadSharedDiagram(shareId);
                return; // ê³µìœ  í˜ì´ì§€ì—ì„œëŠ” ì¼ë°˜ ì´ˆê¸° í”Œë¡œìš°ì°¨íŠ¸ ìƒì„± íë¦„ì„ íƒ€ì§€ ì•Šê²Œ ì¢…ë£Œ
            }

            // SETTINGS ë¼ë””ì˜¤ë“¤ ì´ˆê¸°í™” (ê¸°ë³¸ì€ ëª¨ë‹¬ DOM ê¸°ì¤€)
            initSettingsRadios(document);

            // ============================
            // SETTINGS ëª¨ë‹¬ ë“œë˜ê·¸
            // ============================
            const settingsOverlay = document.getElementById("settingsOverlay");
            const settingsPanel = settingsOverlay
                ? settingsOverlay.querySelector(".modal-panel")
                : null;
            const settingsHeader = settingsPanel
                ? settingsPanel.querySelector(".modal-header")
                : null;       

            let isDraggingSettings = false;
            let dragStartX = 0;
            let dragStartY = 0;
            let panelStartLeft = 0;
            let panelStartTop = 0;

            if (settingsHeader && settingsPanel) {
                // í—¤ë”ì— ë§ˆìš°ìŠ¤ ì•„ì´ì½˜ ë³€ê²½
                settingsHeader.style.cursor = "move";

                // ë“œë˜ê·¸ ì‹œì‘
                settingsHeader.addEventListener("mousedown", function (e) {
                    if (e.button !== 0) return; // ì™¼ìª½ ë²„íŠ¼ë§Œ
                    isDraggingSettings = true;

                    const rect = settingsPanel.getBoundingClientRect();
                    dragStartX = e.clientX;
                    dragStartY = e.clientY;
                    panelStartLeft = rect.left;
                    panelStartTop = rect.top;

                    // ë·°í¬íŠ¸ ê¸°ì¤€ ê³ ì • ìœ„ì¹˜
                    settingsPanel.style.position = "fixed";
                    settingsPanel.style.left = `${panelStartLeft}px`;
                    settingsPanel.style.top = `${panelStartTop}px`;

                    e.preventDefault(); // í…ìŠ¤íŠ¸ ì„ íƒ ë°©ì§€
                });
            }

            // ë“œë˜ê·¸ ì¤‘
            document.addEventListener("mousemove", function (e) {
                if (!isDraggingSettings || !settingsPanel) return;

                const dx = e.clientX - dragStartX;
                const dy = e.clientY - dragStartY;

                let newLeft = panelStartLeft + dx;
                let newTop  = panelStartTop + dy;

                // í™”ë©´ ë°–ìœ¼ë¡œ ì•ˆ ë‚˜ê°€ë„ë¡ ì œí•œ
                const maxLeft = window.innerWidth - settingsPanel.offsetWidth;
                const maxTop  = window.innerHeight - settingsPanel.offsetHeight;

                if (newLeft < 0) newLeft = 0;
                if (newTop < 0) newTop = 0;
                if (newLeft > maxLeft) newLeft = maxLeft;
                if (newTop > maxTop) newTop = maxTop;

                settingsPanel.style.left = `${newLeft}px`;
                settingsPanel.style.top  = `${newTop}px`;
            });

            // ë“œë˜ê·¸ ì¢…ë£Œ
            document.addEventListener("mouseup", function () {
                isDraggingSettings = false;
            });

            // ============================
            // SHARE ëª¨ë‹¬ ë“œë˜ê·¸
            // ============================
            const shareOverlayDrag = document.getElementById("shareOverlay");
            const sharePanel = shareOverlayDrag
              ? shareOverlayDrag.querySelector(".modal-panel")
              : null;
            const shareHeader = sharePanel
              ? sharePanel.querySelector(".modal-header")
              : null;

            let isDraggingShare = false;
            let shareStartX = 0;
            let shareStartY = 0;
            let sharePanelStartLeft = 0;
            let sharePanelStartTop = 0;

            if (shareHeader && sharePanel) {
              shareHeader.style.cursor = "move";

              shareHeader.addEventListener("mousedown", function (e) {
                if (e.button !== 0) return; // ì™¼ìª½ ë²„íŠ¼ë§Œ
                isDraggingShare = true;

                const rect = sharePanel.getBoundingClientRect();
                shareStartX = e.clientX;
                shareStartY = e.clientY;
                sharePanelStartLeft = rect.left;
                sharePanelStartTop = rect.top;

                // ë·°í¬íŠ¸ ê¸°ì¤€ ê³ ì • ìœ„ì¹˜
                sharePanel.style.position = "fixed";
                sharePanel.style.left = `${sharePanelStartLeft}px`;
                sharePanel.style.top = `${sharePanelStartTop}px`;

                e.preventDefault(); // í…ìŠ¤íŠ¸ ì„ íƒ ë°©ì§€
              });
            }

            document.addEventListener("mousemove", function (e) {
              if (!isDraggingShare || !sharePanel) return;

              const dx = e.clientX - shareStartX;
              const dy = e.clientY - shareStartY;

              let newLeft = sharePanelStartLeft + dx;
              let newTop  = sharePanelStartTop + dy;

              const maxLeft = window.innerWidth - sharePanel.offsetWidth;
              const maxTop  = window.innerHeight - sharePanel.offsetHeight;

              if (newLeft < 0) newLeft = 0;
              if (newTop < 0) newTop = 0;
              if (newLeft > maxLeft) newLeft = maxLeft;
              if (newTop > maxTop) newTop = maxTop;

              sharePanel.style.left = `${newLeft}px`;
              sharePanel.style.top  = `${newTop}px`;
            });

            document.addEventListener("mouseup", function () {
              isDraggingShare = false;
            });


            updateZoomLabel();
            setupSplitDrag();
            initChartInteractions();

            // ì½”ë“œ â†’ ë…¸ë“œ í•˜ì´ë¼ì´íŠ¸ ì—°ë™
            ["click", "keyup", "mouseup"].forEach(ev => {
                src.addEventListener(ev, updateNodeHighlightFromCaret);
            });                       


            // íƒ€ì´í•‘ ìë™ ì—…ë°ì´íŠ¸ (debounce)
            src.addEventListener("input", function() {
                // âœ… (ì—¬ê¸°!) ì†ŒìŠ¤ê°€ ë°”ë€Œë©´ Macro ì„¤ì • ì´ˆê¸°í™” (All ê¸°ë³¸ìœ¼ë¡œ)
                macroMode = "all";
                macroDefines = "";
                try { localStorage.removeItem("autoflow-macros"); } catch(e) {}

                const allRadio = document.querySelector('input[name="macroMode"][value="all"]');
                const macroField = document.getElementById("macroInput");
                if (allRadio) allRadio.checked = true;
                if (macroField) {
                    macroField.value = "";
                    macroField.disabled = true;
                }

                
                if (typingTimer) clearTimeout(typingTimer);
                typingTimer = setTimeout(function() {
                    generateFlowchart(true);
                }, TYPING_DELAY_MS);
            });

            // âœ… SHARE: ë°”ê¹¥ í´ë¦­í•˜ë©´ ë‹«ê¸°
            const shareOverlay = document.getElementById("shareOverlay");
            if (shareOverlay) {
              shareOverlay.addEventListener("mousedown", (e) => {
                // overlay(íšŒìƒ‰ ë°°ê²½) ìì²´ë¥¼ ì°ì—ˆì„ ë•Œë§Œ ë‹«ê¸°
                if (e.target === shareOverlay) closeShare();
              });
            }
            
            // ì½”ë“œ í´ë¦­/ì´ë™ ì‹œ â†’ í•´ë‹¹ ë¼ì¸ ë…¸ë“œ í•˜ì´ë¼ì´íŠ¸
            src.addEventListener("click", updateNodeHighlightFromCaret);
            src.addEventListener("keyup", updateNodeHighlightFromCaret);
            src.addEventListener("mouseup", updateNodeHighlightFromCaret);
        });
    </script>
</head>
<body>
    <header>
        <div>
            <h1>mAutoFlow</h1>
            <div class="subtitle">
                When you enter C code on the left, a flowchart is automatically generated on the right.
            </div>
        </div>

        <!-- ì˜¤ë¥¸ìª½ ìƒë‹¨ ë©”ë‰´: ë¡œê·¸ì¸ + ë²„íŠ¼ + ë°±ì—”ë“œ ë²„ì „ -->
        <div class="topbar-right">
            <!-- ë¡œê·¸ì¸ ì˜ì—­ -->
            <span id="welcomeText" style="margin-right:8px;"></span>

            <div id="loggedOutButtons" style="display:inline-flex; gap:4px; margin-right:8px;">
                <button class="btn-settings" onclick="loginWithGoogle()">Login with Google</button>
            </div>

            <div id="loggedInButtons" style="display:none; gap:4px; margin-right:8px;">
                <button class="btn-settings" onclick="logout()">Logout</button>
            </div>
            <!-- ë¡œê·¸ì¸ ì˜ì—­ ë -->

            <!-- ê¸°ëŠ¥ ë²„íŠ¼ë“¤ -->
            <button id="upgradeButton"
                    class="btn-settings"
                    onclick="openProCheckout()">
                UPGRADE
            </button>

            <!-- DOWNLOAD ì™¼ìª½ -->
            <button class="btn-settings" onclick="openShare()">SHARE</button>
            
            <button class="btn-settings" onclick="downloadDiagram()">DOWNLOAD</button>         
            <button class="btn-settings" onclick="openSettings()">SETTINGS</button>
            <button id="helpToggleBtn" class="btn-settings" onclick="toggleHelp()">HELP</button>
        </div>
    </header>
    <div class="main">
        <div id="leftPane">
            <div class="pane-header">
                <span class="pane-title">Source Code</span>
            </div>
            <div id="codeContainer">
                <div id="codeHeader">
                    <span>mAutoFlow</span>
                    <span style="opacity:0.7;">Automatic analysis</span>
                </div>
                <div id="codeArea">
                    <div id="lineNumbers"></div>
                    <textarea id="src" spellcheck="false" placeholder="Example:
void main(void)
{
    int x = 0;

    if (x == 0)
    {
        x++;
    }
    else
    {
        x--;
    }
}"></textarea>
                </div>
            </div>
        </div>

        <div id="divider"></div>

        <div id="rightPane">
            <div class="pane-header">
                <span class="pane-title">Flowchart</span>
                <div style="display:flex; align-items:center; gap:6px;">
                    <button class="btn btn-ghost" onclick="zoomChange(-0.1)">âˆ’</button>
                    <button class="btn btn-ghost" onclick="zoomReset()">100%</button>
                    <button class="btn btn-ghost" onclick="zoomChange(0.1)">+</button>
                    <span class="zoom-label" id="zoomLabel"></span>
                </div>
            </div>
            <div id="toolbar">
                <button class="btn btn-primary" onclick="generateFlowchart(false)">Regenerate Now</button>
                <span id="currentFunc"></span>
                <span id="status"></span>
                <span id="quotaInfo" style="margin-left:8px; font-size:12px; opacity:0.8;"></span>
            </div>
            <div id="chartContainer">
                <div id="chartInner">
                    <p class="placeholder">
                        When you enter C code on the left, a flowchart is automatically generated on the right.
                    </p>
                </div>
            </div>
        </div>
    </div>
    
    <!-- SETTINGS ëª¨ë‹¬: ì—¬ê¸° ì¶”ê°€ -->
    <div id="settingsOverlay" class="modal-overlay modal-hidden">
        <div class="modal-panel">
            <div class="modal-group-title">Display Options</div>
            <!-- Theme ì„¹ì…˜ -->
            <div class="modal-section"> <!-- Theme -->
                <div class="modal-section-title">Theme</div>
                <div class="modal-radio-row">
                    <label>
                        <input type="radio" name="theme" value="classic" checked />
                        Classic
                    </label>
                    <label>
                        <input type="radio" name="theme" value="light" />
                        Light
                    </label>
                    <label>
                        <input type="radio" name="theme" value="dark" />
                        Dark
                    </label>
                </div>
            </div>

            <!-- Branch Shape ì„¹ì…˜ ë³µêµ¬ -->
            <div class="modal-section"> <!-- Branch Shape -->
                <div class="modal-section-title">Branch Shape</div>
                <div class="modal-radio-row">
                    <label>
                        <input type="radio" name="branchShape" value="rounded" checked />
                        Rounded
                    </label>
                    <label>
                        <input type="radio" name="branchShape" value="diamond" />
                        Diamond
                    </label>
                </div>
            </div>

            <!-- Function Name Display ì„¹ì…˜ -->
            <div class="modal-section"> <!-- Function Name Display -->
                <div class="modal-section-title">Function Name Display</div>
                <div class="modal-radio-row">
                    <label>
                        <input type="radio" name="funcNameStyle" value="short" checked />
                        Short
                    </label>
                    <label>
                        <input type="radio" name="funcNameStyle" value="full" />
                        Full
                    </label>
                </div>
            </div>

            <div class="modal-group-title">Macro Options</div>

            <!-- Preprocessor Macros ì„¹ì…˜ -->
            <div class="modal-section macro-section">
              <div class="modal-section-title">Preprocessor Macros (-D)</div>

              <div class="modal-radio-row">
                <label>
                  <input type="radio" name="macroMode" value="all" checked />
                  All
                </label>

                <label>
                  <input type="radio" name="macroMode" value="defined" />
                  Defined
                </label>

                <label for="macroInput" style="font-size:12px; opacity:0.9; margin:4px 0 2px;">
                  Example: <code>DEBUG;TEST=2;RELEASE</code>
                </label>

                <textarea
                  id="macroInput"
                  class="macro-input"
                  rows="3"
                  placeholder="Type macros like: DEBUG;TEST=2;RELEASE"
                  disabled></textarea>
              </div>
            </div>
            <div class="modal-group-title">Download Options</div>

            <div class="modal-section">
              <div class="modal-section-title">Format</div>
              <div class="modal-radio-row">
                <label>
                  <input type="radio" name="downloadFormat" value="svg" checked />
                  SVG (recommended)
                </label>

                <!-- PNG ì¶”ê°€ -->
                <label>
                  <input type="radio" name="downloadFormat" value="png" />
                  PNG
                </label>
                
                <div style="font-size:12px; opacity:0.8; margin-top:6px;">
                  Tip: For PDF, use Print â†’ Save as PDF.
                </div>
              </div>
            </div>

            <div class="modal-section">
              <div class="modal-section-title">PNG Options</div>

              <div class="modal-radio-row">
                <label>
                  Scale:
                  <select id="pngScale" style="margin-left:8px;">
                    <option value="1">1x (Fast)</option>
                    <option value="2" selected>2x (Recommended)</option>
                    <option value="3">3x (High)</option>
                  </select>
                </label>

                <label>
                  Background:
                  <select id="pngBg" style="margin-left:8px;">
                    <option value="white" selected>White</option>
                    <option value="transparent">Transparent</option>
                  </select>
                </label>
              </div>
            </div>    
        </div>
    </div>

    <!-- SHARE ëª¨ë‹¬: settingsOverlay ë°”ë¡œ ì•„ë˜ì— ì¶”ê°€ -->
    <div id="shareOverlay" class="modal-overlay modal-hidden">
      <div class="modal-panel share-panel">
        <div class="modal-header">
          <h2>Share flowchart</h2>
          <button class="modal-close" onclick="closeShare()">Ã—</button>
        </div>

        <div style="font-size:12px; opacity:0.85; margin-bottom:10px;">
          Read-only link (login required)
        </div>

        <div style="display:flex; gap:10px; align-items:center;">
          <input id="shareLinkInput"
                 type="text"
                 readonly
                 value=""
                 style="flex:1; padding:8px 10px; border-radius:6px; border:1px solid rgba(148,163,184,0.6);">
          <button class="btn btn-primary" onclick="copyShareLink()">COPY LINK</button>
        </div>

        <div id="shareHint"
             style="margin-top:10px; font-size:12px; opacity:0.75;">
        </div>
      </div>
    </div>
    <!-- SHARE ëª¨ë‹¬ ë -->    

    
    <!--  Supabase Auth ìŠ¤í¬ë¦½íŠ¸: </body> ë°”ë¡œ ìœ„ì— ì¶”ê°€ -->
    <script type="module">
        import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

        //  ì—¬ê¸° ë‘ ê°’ì€ ë³¸ì¸ í”„ë¡œì íŠ¸ ê°’ìœ¼ë¡œ êµì²´í•´ì•¼ í•¨
        const SUPABASE_URL = "https://layaiawwnioetzuxcyev.supabase.co";   // ì˜ˆì‹œ: ëŒ€ì‰¬ë³´ë“œì˜ Project URL
        const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImxheWFpYXd3bmlvZXR6dXhjeWV2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQ3NjIxMjgsImV4cCI6MjA4MDMzODEyOH0.ZWC86hD5JaX2Jh0b0wR6bfmqNrEWBrq-YnLu3yg1JJo";            // API íƒ­ì˜ anon public key

        const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        // ì „ì—­ì—ì„œ ì ‘ê·¼í•  ìˆ˜ ìˆê²Œ windowì— ë¶™ì´ê¸°
        window.supabase = supabase;

        // í˜„ì¬ ë¡œê·¸ì¸ ìœ ì €ë¥¼ ì „ì—­ìœ¼ë¡œ ë³´ê´€
        window.currentUser = null;

        async function updateAuthUI() {
            const { data } = await supabase.auth.getUser();
            const user = data?.user ?? null;
            window.currentUser = user;

            const welcomeText   = document.getElementById("welcomeText");
            const loggedOutDiv  = document.getElementById("loggedOutButtons");
            const loggedInDiv   = document.getElementById("loggedInButtons");
            const upgradeBtn    = document.getElementById("upgradeButton");

            if (!welcomeText || !loggedOutDiv || !loggedInDiv) return;

            if (user) {
                welcomeText.textContent = user.email
                    ? `Welcome, ${user.email}`
                    : "Welcome!";
                loggedOutDiv.style.display = "none";
                loggedInDiv.style.display  = "inline-flex";

                const isTestUser = (user.email === window.TEST_EMAIL);

                // UPGRADE ë²„íŠ¼: ë¡œê·¸ì¸ ì§í›„ì—” í”Œëœ í™•ì • ì „ì´ë¯€ë¡œ ì¼ë‹¨ ìˆ¨ê¹€
                if (upgradeBtn) {
                  upgradeBtn.classList.remove("upgrade-blink");
                  upgradeBtn.style.display = "none";
                }

                // ğŸ”¹ ë¡œê·¸ì¸ ì§í›„: í”Œëœ ìƒíƒœ ë¦¬ì…‹ + ë¡œë”© ì‹œì‘
                window.__planLoading        = true;
                window.__planTier           = null;
                window.__planName           = null;
                window.__isProUser          = false;
                window.__nodeLimitFromServer = null;
                window.__nodeLimit          = FREE_NODE_LIMIT;
                window.__serverUsageCount   = null;
                window.__dailyFreeLimit     = null;

            } else {
                welcomeText.textContent = "";
                loggedOutDiv.style.display = "inline-flex";
                loggedInDiv.style.display  = "none";
                if (upgradeBtn) {
                    upgradeBtn.style.display = "none";
                    // ë¡œê·¸ì•„ì›ƒ ì‹œì—ë„ ê¹œë¹¡ì„ ì œê±°
                    upgradeBtn.classList.remove("upgrade-blink");
                }

                // ë¡œê·¸ì•„ì›ƒ ì‹œ í”Œëœ ê´€ë ¨ ì „ì—­ê°’ ì´ˆê¸°í™”
                window.__planLoading        = false;
                window.__planTier           = null;
                window.__planName           = null;
                window.__isProUser          = false;
                window.__nodeLimitFromServer = null;
                window.__nodeLimit          = FREE_NODE_LIMIT;
                window.__serverUsageCount   = null;
                window.__dailyFreeLimit     = null;
            }

            // ë¡œê·¸ì¸/ë¡œê·¸ì•„ì›ƒ ì‹œ ë¬´ë£Œ ì‚¬ìš©ëŸ‰ í‘œì‹œ ê°±ì‹  (ìœ„ì—ì„œ ìƒíƒœ ì •ë¦¬ í›„ í˜¸ì¶œ)
            window.updateQuotaInfo?.();

            // ë¡œê·¸ì¸ ìƒíƒœë¼ë©´ Supabaseì—ì„œ êµ¬ë…/í”Œëœ ì •ë³´ë„ í•œ ë²ˆ ë” ë¶ˆëŸ¬ì™€ì„œ ë°˜ì˜
            if (user) {
                window.refreshPlanFromSupabase?.();
            }
        }

        async function loginWithGoogle() {
            await supabase.auth.signInWithOAuth({
                provider: "google",
                options: {
                    // redirectTo: "https://mautoflow-lab.netlify.app",  // Netlify ì‹¤ì œ URL
                    redirectTo: "https://mautoflow-frontend-cf.pages.dev",  // Cloudflare URL
                    queryParams: {
                        // ë§¤ë²ˆ ê³„ì • ì„ íƒ í™”ë©´ ê°•ì œ
                        prompt: "select_account"
                    }
                }
            });
        }

        function clearAppUIOnLogout() {
            const src         = document.getElementById("src");
            const lineNumbers = document.getElementById("lineNumbers");
            const status      = document.getElementById("status");
            const currentFunc = document.getElementById("currentFunc");
            const chartInner  = document.getElementById("chartInner");
            const codeHeader  = document.getElementById("codeHeader");
            const quotaInfo = document.getElementById("quotaInfo");
            if (quotaInfo) {
              quotaInfo.textContent = "Free tier: up to 5 diagrams/day (â‰¤ 20 nodes).";
            }

            // ì½”ë“œ ì˜ì—­ ë¹„ìš°ê¸°
            if (src) {
                src.value = "";
                src.scrollTop = 0;
            }

            // ë¼ì¸ ë²ˆí˜¸ ì´ˆê¸°í™” (1 í•œ ì¤„ë§Œ)
            if (lineNumbers) {
                lineNumbers.innerHTML = "1<br>";
            }

            // ìƒíƒœ ë©”ì‹œì§€: ë¡œê·¸ì¸ í•„ìš”
            if (status) {
                status.textContent = "Please log in to use mAutoFlow.";
                status.className = "error";
            }

            // í˜„ì¬ í•¨ìˆ˜ëª… ì œê±°
            if (currentFunc) {
                currentFunc.textContent = "";
            }

            // í”Œë¡œìš°ì°¨íŠ¸ ìë¦¬ ì´ˆê¸°í™” ë¬¸êµ¬
            if (chartInner) {
                chartInner.innerHTML = `
                    <p class="placeholder">
                        When you enter C code on the left, a flowchart is automatically generated on the right.
                    </p>
                `;
            }

            // ì½”ë“œ í—¤ë” í…ìŠ¤íŠ¸ë„ ê¸°ë³¸ê°’ìœ¼ë¡œ
            if (codeHeader) {
                codeHeader.innerHTML = `
                    <span>mAutoFlow</span>
                    <span style="opacity:0.7;">Automatic analysis</span>
                `;
            }

            // ë‚´ë¶€ ìƒíƒœ ë¦¬ì…‹
            window.__nodeLines = {};
            window.__nodeCount = 0;
            lastCountedSource = "";   // ë¡œê·¸ì•„ì›ƒí•˜ë©´ ê¸°ì¤€ ì½”ë“œë„ ì´ˆê¸°í™”
        }

        async function logout() {
            await supabase.auth.signOut();
            await updateAuthUI();
            clearAppUIOnLogout();
        }

        //  ì „ì—­ì—ì„œ í˜¸ì¶œ ê°€ëŠ¥í•˜ë„ë¡ windowì— ë¶™ì´ê¸°
        window.loginWithGoogle = loginWithGoogle;
        window.logout          = logout;

        // ì²« ë¡œë”© ì‹œ ë¡œê·¸ì¸ ìƒíƒœ ë°˜ì˜
        document.addEventListener("DOMContentLoaded", updateAuthUI);
        window.updateQuotaInfo = updateQuotaInfo;
    </script>
    <!--  Supabase Auth ìŠ¤í¬ë¦½íŠ¸ ë -->

</body>
</html>

