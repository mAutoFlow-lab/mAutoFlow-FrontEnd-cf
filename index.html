<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <title>mAutoFlow</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        :root {
            /* 기본 테마 (classic) */
            --bg-main: #f3f4f6;
            --bg-header: #1f2933;
            --header-text: #f9fafb;

            --bg-code: #111827;
            --code-text: #e5e7eb;
            --code-border: #d1d5db;

            --bg-chart: #ffffff;
            --chart-border: #d1d5db;

            --accent-primary: #2563eb;
            --accent-primary-hover: #1d4ed8;

            --toolbar-text: #374151;
        }

        /* 라이트 테마 */
        body[data-theme="light"] {
            --bg-main: #f9fafb;
            --bg-header: #2563eb;
            --header-text: #ffffff;

            --bg-code: #ffffff;
            --code-text: #111827;
            --code-border: #d1d5db;

            --bg-chart: #ffffff;
            --chart-border: #d1d5db;

            --accent-primary: #2563eb;
            --accent-primary-hover: #1d4ed8;

            --toolbar-text: #111827;
        }

        /* 다크 테마 */
        body[data-theme="dark"] {
            --bg-main: #020617;
            --bg-header: #020617;
            --header-text: #e5e7eb;

            --bg-code: #020617;
            --code-text: #e5e7eb;
            --code-border: #1f2937;

            --bg-chart: #020617;
            --chart-border: #1f2937;

            --accent-primary: #22c55e;
            --accent-primary-hover: #16a34a;

            --toolbar-text: #e5e7eb;
        }

        /* Mermaid SVG Override (dark) */
        body[data-theme="dark"] #chartInner svg path {
            stroke: #f8fafc !important;
        }
        body[data-theme="dark"] #chartInner svg line {
            stroke: #f8fafc !important;
        }
        body[data-theme="dark"] #chartInner svg polygon {
            stroke: #f8fafc !important;
            fill: #f8fafc !important;
        }
        body[data-theme="dark"] #chartInner svg marker path {
            stroke: #f8fafc !important;
            fill: #f8fafc !important;
        }
    
        * { box-sizing: border-box; }
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
        }
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            font-size: 14px; /* UI 기본 폰트 */
            background: var(--bg-main);
        }
        header {
            padding: 10px 16px;
            background: var(--bg-header); /* ← 변경 */
            color: var(--header-text);    /* ← 변경 */
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        header h1 {
            margin: 0;
            font-size: 20px;
        }
        header .subtitle {
            font-size: 12px;
            opacity: 0.85;
        }

        .main {
            flex: 1;
            display: flex;
            min-height: 0;
            background: var(--bg-main);
        }

        /* 좌측/우측 패널 + 드래그 분할바 */
        #leftPane {
            flex: 0 0 33%; /* 초기 약 1/3 */
            min-width: 200px;
            display: flex;
            flex-direction: column;
            padding: 8px;
        }
        #divider {
            flex: 0 0 6px;
            cursor: col-resize;
            background: #d1d5db;
        }
        #divider:hover {
            background: #9ca3af;
        }
        #rightPane {
            flex: 0 0 67%; /* 초기 약 2/3 */
            min-width: 260px;
            display: flex;
            flex-direction: column;
            padding: 8px;
        }

        .pane-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 6px;
        }
        .pane-title {
            font-weight: 600;
            font-size: 14px;
            color: var(--toolbar-text);
        }

        /* 좌측 코드 영역 */
        #codeContainer {
            flex: 1;
            border-radius: 4px;
            border: 1px solid var(--code-border);  /* ← 변경 */
            background: var(--bg-code);            /* ← 변경 */
            display: flex;
            flex-direction: column;
        }
        #codeHeader {
            padding: 4px 8px;
            border-bottom: 1px solid #4b5563;
            color: var(--code-text);      /* ← 변경 */
            font-size: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #codeArea {
            flex: 1;
            padding: 6px;
            display: flex;       /* ← 라인번호 + textarea 가 가로로 배치되도록 */
            position: relative;  /* 좌측 코드 위에 오버레이를 얹기 위해 추가 */
        }

        #lineNumbers {
            width: 40px;  /* 라인 번호 영역 너비 */
            padding: 6px 4px;
            text-align: right;
            color: var(--code-text);
            background: var(--bg-code);
            border-right: 1px solid var(--code-border);
            font-family: "Consolas", "Roboto Mono", monospace;
            font-size: 13px;
            line-height: 1.4;
            user-select: none;        /* 라인 번호 드래그 방지 */
            overflow: hidden;
        }
        
        #src {
            width: 100%;
            height: 100%;
            border: none;
            outline: none;
            resize: none;
            background: transparent;
            color: var(--code-text);      /* ← 변경 */
            font-family: "Consolas", "Roboto Mono", monospace;
            font-size: 13px;  /* 코드 글자 크기 (너무 크지 않게) */
            line-height: 1.4;
            flex: 1;                  /* ← 남은 영역 꽉 채우기 */
        }

        /* 우측 플로우차트 영역 */
        #toolbar {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
            font-size: 12px;
        }
        .btn {
            padding: 4px 10px;
            border-radius: 4px;
            border: none;
            cursor: pointer;
            font-size: 12px;
        }
        .btn-primary {
            background: var(--accent-primary);           /* ← 변경 */
            color: white;
        }
        .btn-primary:hover {
            background: var(--accent-primary-hover);     /* ← 변경 */
        }
        .btn-ghost {
            background: #e5e7eb;
            color: #111827;
        }
        .btn-ghost:hover {
            background: #d1d5db;
        }

        #status {
            font-size: 12px;
            color: var(--toolbar-text);                  /* ← 변경 */
        }
        #status.error {
            color: #b91c1c;
        }
        #status.success {
            color: #15803d;
        }
        #currentFunc {
            font-weight: 600;
            font-size: 12px;
            color: var(--toolbar-text);
        }

        #chartContainer {
            flex: 1;
            border-radius: 4px;
            border: 1px solid var(--chart-border); /* ← 변경 */
            background: var(--bg-chart);           /* ← 변경 */
            overflow: auto;

            /* flex 제거하고, 일반 블록 + 텍스트 정렬로 가운데 맞추기 */
            text-align: center;
        }
        #chartInner {
            display: inline-block;   /* 가운데 정렬 대상 */
            margin: 8px;
            transform-origin: top center;  /* 확대 기준은 그대로 중앙 */
        }
        #chartInner .mermaid {
            margin: 0 auto;
        }

        .placeholder {
            color: #9ca3af;
            font-size: 14px;
            text-align: center;
            margin-top: 40px;
        }

        /* Mermaid가 그리는 SVG를 우측 패널 너비에 맞게 조정 */
        #chartInner svg {
            max-width: none;
            height: auto;
            display: block;
            margin: 0 auto;
        }
        

        .zoom-label {
            font-size: 12px;
            min-width: 42px;
            color: var(--toolbar-text);
        }

        /* 코드 ↔ 노드 연동: 선택된 노드 하이라이트 (더 진하게) */
        .node.autoflow-selected rect,
        .node.autoflow-selected polygon,
        .node.autoflow-selected path {
            stroke: #ff0000;              /* 더 강한 빨간색 */
            stroke-width: 4px;            /* 테두리 두께 업 */
            stroke-dasharray: 0;          /* 실선 */
            filter: drop-shadow(0 0 6px rgba(255, 0, 0, 0.9));
        }

        /* 선택된 노드 텍스트도 강조 */
        .node.autoflow-selected text {
            font-weight: 700;
            fill: #000000;
        }

        /* 우측 노드 hover 시, 좌측 코드에 붉은 줄 하이라이트 */
        #hoverHighlight {
            position: absolute;
            background: rgba(248, 113, 113, 0.25); /* 연한 붉은 배경 */
            border-left: 3px solid #ef4444;        /* 왼쪽 붉은 선 */
            pointer-events: none;                  /* 마우스 이벤트 통과 */
            display: none;
            z-index: 3;                            /* textarea 위로 올라오게 */
        }

        /* 마우스만 올려놓았을 때(hover) 노드 하이라이트 – 붉은 계열, 클릭과 구분 */
        .node.autoflow-hover rect,
        .node.autoflow-hover polygon,
        .node.autoflow-hover path {
            stroke: #ef4444; /* 연한 붉은 계열 */
            stroke-width: 3px;
            stroke-dasharray: 4 2; /* 점선 느낌으로 선택과 구분 */
            filter: drop-shadow(0 0 4px rgba(248, 113, 113, 0.7));
        }

        .node.autoflow-hover text {
            font-weight: 600;
        }


        ..topbar-right {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            opacity: 0.9;
            flex-wrap: nowrap;    /* 버튼 줄바꿈 방지 */
            white-space: nowrap;  /* 텍스트 줄바꿈 방지 */
        }

        .btn-settings {
            padding: 4px 10px;
            border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.4);
            background: transparent;
            color: inherit;
            cursor: pointer;
            font-size: 12px;
        }
        .btn-settings:hover {
            background: rgba(255,255,255,0.12);
        }

        /* SETTINGS 모달 */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(15,23,42,0.55);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 50;
        }
        .modal-hidden {
            display: none;
        }
        .modal-panel {
            background: #ffffff;
            border-radius: 8px;
            padding: 16px 20px;
            min-width: 260px;
            max-width: 320px;
            box-shadow: 0 10px 40px rgba(15,23,42,0.45);
            font-size: 13px;
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }
        .modal-header h2 {
            margin: 0;
            font-size: 14px;
        }
        .modal-close {
            border: none;
            background: transparent;
            cursor: pointer;
            font-size: 16px;
        }
        .modal-section {
            margin-bottom: 12px;
        }
        .modal-section-title {
            font-weight: 600;
            margin-bottom: 6px;
        }
        .modal-radio-row {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
      
    </style>
    <script>
        const API_BASE = "https://mautoflow-backend.onrender.com";
	mermaid.initialize({ startOnLoad: false });

	// 서버에서 내려준 사용량 / 한도 (없으면 null)
        window.__serverUsageCount = null;
        window.__dailyFreeLimit = null;

	let lastCountedSource = "";   // 마지막으로 사용량을 올렸던 소스 코드

	// ✅ 테스트 전용 계정 (무제한)
        const TEST_EMAIL = "exitgiveme@gmail.com";

        // ===== 하루 무료 사용량 설정 =====
        const DAILY_FREE_LIMIT = 5;     // 하루 무료 5회
        const FREE_NODE_LIMIT  = 20;    // 노드 10개까지 허용
        const USAGE_KEY        = "autoflow_daily_usage";

        function getTodayKey() {
            // YYYY-MM-DD 형식
            return new Date().toISOString().slice(0, 10);
        }

        function getTodayUsage() {
            const today = getTodayKey();
            let raw = null;
            try {
                raw = localStorage.getItem(USAGE_KEY);
            } catch (e) {
                return { date: today, count: 0 };
            }

            if (!raw) {
                return { date: today, count: 0 };
            }

            try {
                const data = JSON.parse(raw);
                if (!data.date || data.date !== today) {
                    // 날짜가 다르면 새로 시작
                    return { date: today, count: 0 };
                }
                if (typeof data.count !== "number") {
                    return { date: today, count: 0 };
                }
                return { date: today, count: data.count };
            } catch (e) {
                return { date: today, count: 0 };
            }
        }

        function saveTodayUsage(obj) {
            try {
                localStorage.setItem(USAGE_KEY, JSON.stringify(obj));
            } catch (e) {
                // 저장 실패는 그냥 무시
            }
        }
	
        // 백엔드 node_lines 는 1-based 라인 번호라고 가정하고
        // 항상 0-based 인덱스로 변환해서 사용
        function toZeroBasedLine(line) {
            if (typeof line !== "number" || Number.isNaN(line)) return null;
            const idx = line - 1;         // ★ 한 줄 내려줌
            return idx < 0 ? 0 : idx;
        }
	
        const HELP_TEXT_HTML = `
        <h2 style="margin-top:0;">mAutoFlow – Help</h2>

        <p>
            mAutoFlow converts C / pseudo-C functions into a structured flowchart.
            The left side is the source editor and the right side is the diagram viewer.
            Code and nodes are synchronized in both directions.
        </p>

        <h3>1. Basic Concept</h3>
        <ul>
            <li>mAutoFlow focuses on <strong>a single function</strong> at a time.</li>
            <li>When you type or paste C code on the left, mAutoFlow finds a function.</li>
            <li>The body of the selected function is analyzed and rendered as a flowchart on the right.</li>
            <li>
                Use the <strong>HELP</strong> button in the top-right toolbar to switch between
                <strong>Code view</strong> and <strong>Help view</strong>.
                When Help is open, the button label becomes <strong>CODE</strong>; click it again to return to the editor.
            </li>
        </ul>

        <h3>2. Writing / Pasting Code</h3>
        <ul>
            <li>Paste normal C code or pseudo-C code into the editor.</li>
            <li>Function prototypes and global variables are allowed; mAutoFlow focuses on the chosen function body.</li>
            <li>Supported constructs:
                <ul>
                    <li><code>if / else if / else</code></li>
                    <li><code>for</code>, <code>while</code>, <code>do…while</code></li>
                    <li><code>switch / case / default</code></li>
                    <li><code>return</code>, <code>break</code>, <code>continue</code></li>
                    <li>Simple assignments and expressions (e.g. <code>x++;</code>, <code>flag = true;</code>)</li>
                </ul>
            </li>
            <li>Very complex or unusual syntax may not be visualized perfectly, 
                but the main control flow should still appear.</li>
        </ul>

        <h3>3. Automatic Refresh</h3>
        <ul>
            <li>mAutoFlow watches your typing in the left editor.</li>
            <li>After a short idle delay, the flowchart is automatically regenerated.</li>
            <li>If you do not want to wait, press <strong>“Regenerate Now”</strong> to force an immediate update.</li>
        </ul>

        <h3>4. Code ⇄ Flowchart Synchronization</h3>
        <ul>
            <li><strong>From code to flowchart</strong>:
                <ul>
                    <li>Click a line in the editor (or move the caret).</li>
                    <li>The best-matching node in the chart is highlighted in red.</li>
                    <li>The diagram view automatically scrolls to keep the node visible.</li>
                </ul>
            </li>
            <li><strong>From flowchart to code</strong>:
                <ul>
                    <li>Click a node on the diagram.</li>
                    <li>The corresponding line in the editor is selected.</li>
                    <li>The editor scrolls so the line is centered vertically.</li>
                    <li>“start / end / merge” nodes are ignored to avoid meaningless jumps.</li>
                </ul>
            </li>
            <li>A fuzzy matching algorithm is used, so minor formatting differences are tolerated.</li>
        </ul>

        <h3>5. Zooming & Panning the Diagram</h3>
        <ul>
            <li>Use the buttons in the Flowchart header:
                <ul>
                    <li><strong>−</strong>: zoom out</li>
                    <li><strong>100%</strong>: reset zoom</li>
                    <li><strong>+</strong>: zoom in</li>
                </ul>
            </li>
            <li><strong>Ctrl + mouse wheel</strong> over the diagram zooms as well.</li>
            <li><strong>Left-drag</strong> to pan when the chart is larger than the viewport.</li>
            <li>The current zoom level is shown on the right side of the toolbar.</li>
        </ul>

        <h3>6. Downloading the Diagram</h3>
        <ul>
            <li>Click the <strong>DOWNLOAD</strong> button in the top-right toolbar.</li>
            <li>The current flowchart is exported as an <strong>SVG</strong> file.</li>
            <li>File name is based on the current function name (e.g. <code>MyFunction.svg</code>).</li>
            <li>SVG is resolution-independent and ideal for documents and high-quality printing.</li>
        </ul>

        <h3>7. Themes</h3>
        <ul>
            <li>Open <strong>SETTINGS</strong> from the top-right toolbar.</li>
            <li>You can choose:
                <ul>
                    <li><strong>Classic</strong> – default colors & layout</li>
                    <li><strong>Light</strong> – light UI suitable for bright environments</li>
                    <li><strong>Dark</strong> – dark UI optimized for low-light work</li>
                </ul>
            </li>
            <li>Your selection is saved in local storage and restored next time.</li>
        </ul>

        <h3>8. Typical Workflow</h3>
        <ol>
            <li>Paste a function from your C project into the editor.</li>
            <li>Wait for automatic refresh or click “Regenerate Now”.</li>
            <li>Inspect the resulting flowchart.</li>
            <li>Click nodes to jump directly to code.</li>
            <li>Modify code to simplify logic or conditions.</li>
            <li>Download SVG for documentation or design reviews.</li>
        </ol>

        <h3>9. Example Code Snippet</h3>
        <pre style="background:#111827; color:#e5e7eb; padding:8px; border-radius:4px; font-size:12px; overflow:auto;">
        void main(void)
        {
            int x = 0;

            if (x == 0)
            {
                x++;
            }
            else
            {
                x--;
            }
        }
        </pre>
        <p>
            Paste this sample into the editor and observe how mAutoFlow renders the branches.
            Try modifying conditions or adding loops to see dynamic updates.
        </p>

        <h3>10. Notes & Limitations</h3>
        <ul>
            <li>mAutoFlow focuses on <strong>control flow</strong>, not a full C compiler.</li>
            <li>Complicated macros or vendor-specific extensions may not be shown perfectly.</li>
            <li>If a function body cannot be detected, mAutoFlow displays an error message.</li>
            <li>Extremely long single-line statements may reduce matching accuracy.</li>
        </ul>

        <h3>11. Branch Shape Options</h3>
        <p>
            mAutoFlow allows customizing how <strong>conditional branches</strong> (<code>if / else-if / switch</code>)
            are displayed in the flowchart.
        </p>

        <ul>
            <li>Open <strong>SETTINGS → Branch Shape</strong></li>
            <li>Choose between:
                <ul>
                    <li><strong>Rounded Rectangle</strong> – default (traditional flowchart style)</li>
                    <li><strong>Diamond</strong> – classic decision symbol</li>
                </ul>
            </li>
            <li>The next time you regenerate the diagram, the new shape will be applied.</li>
        </ul>

        <p style="margin-top:16px; font-size:12px; opacity:0.8;">
            Tip: choose Rounded for compact readability, or Diamond for classic flowchart notation.
        </p>
        `;
   
        let isHelpMode = false;

        // 현재 로그인 유저 기준 localStorage 키
        function getUsageStorageKey() {
            if (!window.currentUser || !window.currentUser.id) return null;
            return `autoflow-usage-${window.currentUser.id}`;
        }

        function getUsageCount() {
            const key = getUsageStorageKey();
            if (!key) return 0;
            try {
                const raw = localStorage.getItem(key);
                const n = parseInt(raw, 10);
                return Number.isNaN(n) ? 0 : n;
            } catch (e) {
                return 0;
            }
        }

        function setUsageCount(n) {
            const key = getUsageStorageKey();
            if (!key) return;
            try {
                localStorage.setItem(key, String(n));
            } catch (e) {
                // 저장 실패하면 그냥 무시
            }
        }

        function incrementUsageCount() {
            const used = getUsageCount();
            setUsageCount(used + 1);
            updateQuotaInfo();
        }

        function updateQuotaInfo() {
            const span = document.getElementById("quotaInfo");
            if (!span) return;

            if (!window.currentUser) {
                span.textContent = "";
                span.title = "";
                return;
            }

            // 테스트 계정: 숫자 대신 무제한 안내
            if (window.currentUser.email === TEST_EMAIL) {
                span.textContent = "Free tier: unlimited (test account).";
                span.title = "Test account is not subject to daily limits.";
                return;
            }

            // 서버에서 아직 아무 정보도 안 받은 상태
            if (window.__serverUsageCount == null || window.__dailyFreeLimit == null) {
                span.textContent = "Free tier: server-enforced (e.g. 5 diagrams/day, ≤ 20 nodes).";
                span.title = "Daily limit is enforced on the server.";
                return;
            }

            // 서버 기준 사용량 표시
            const count = window.__serverUsageCount;
            const limit = window.__dailyFreeLimit;

            span.textContent = `Today: ${count} / ${limit} (≤ ${FREE_NODE_LIMIT} nodes)`;
            span.title = "This usage count is returned from the server.";
        }
        
        let currentBranchShape = "rounded";   // 분기 모양: 기본은 둥근 사각형
        let savedSourceCode = "";             // HELP 진입 전 코드 저장용

        function toggleHelp() {
            const codeArea   = document.getElementById("codeArea");
            const codeHeader = document.getElementById("codeHeader");
            const btn        = document.getElementById("helpToggleBtn");

            if (!codeArea || !codeHeader || !btn) return;

            if (!isHelpMode) {
                // === HELP 모드 진입 ===
                // 현재 코드 저장
                const srcNow = document.getElementById("src");
                if (srcNow) {
                    savedSourceCode = srcNow.value;
                } else {
                    savedSourceCode = "";
                }

                isHelpMode = true;
                btn.textContent = "CODE";

                codeHeader.innerHTML = "<span>HELP</span>";
                codeArea.innerHTML = `
                    <div id="helpContent" style="padding:10px; color:var(--code-text); font-size:13px; overflow-y:auto;">
                        ${HELP_TEXT_HTML}
                    </div>
                `;
            } else {
                // === CODE 모드 복귀 ===
                isHelpMode = false;
                btn.textContent = "HELP";

                // 이전에 계산된 노드 개수가 있으면 그대로 복원
                let rightText = "Automatic analysis";
                if (typeof window.__nodeCount === "number" && window.__nodeCount > 0) {
                    rightText = `Nodes: ${window.__nodeCount}`;
                }

                codeHeader.innerHTML = `
                    <span>mAutoFlow</span>
                    <span style="opacity:0.7;">${rightText}</span>
                `;

                // 에디터 다시 만들기 (라인 번호 + textarea + hoverHighlight 모두 포함)
                codeArea.innerHTML = `
                    <div id="lineNumbers"></div>
                    <textarea id="src" spellcheck="false" placeholder="Paste your C / pseudo-C code here."></textarea>
                    <div id="hoverHighlight"></div>
                `;

                // 저장해둔 코드 복원
                const src = document.getElementById("src");
                if (src) {
                    src.value = savedSourceCode || "";

                    // 기존 이벤트 다시 연결
                    ["click", "keyup", "mouseup"].forEach(ev => {
                        src.addEventListener(ev, updateNodeHighlightFromCaret);
                    });

                    // HELP → CODE 복귀 후에도 hover 하이라이트 동작
                    src.addEventListener("mousemove", handleCodeHover);
                    
                    src.addEventListener("input", function() {
                        if (typingTimer) clearTimeout(typingTimer);
                        typingTimer = setTimeout(function() {
                            generateFlowchart(true);
                        }, TYPING_DELAY_MS);
                    });
                }
            }
        }

        // ============================
        //  Theme 관리
        // ============================
        let currentTheme = "classic"; // 기본
        
        function applyTheme(theme) {
            currentTheme = theme;

            // classic 은 data-theme 제거 (기본 색 사용)
            if (theme === "classic") {
                document.body.removeAttribute("data-theme");
            } else {
                document.body.setAttribute("data-theme", theme);
            }

            // 로컬 스토리지에 저장
            try {
                localStorage.setItem("autoflow-theme", theme);
            } catch (e) {
                // storage 못쓸 때는 그냥 무시
            }
        }

        function openSettings() {
            const overlay = document.getElementById("settingsOverlay");
            if (!overlay) return;
            overlay.classList.remove("modal-hidden");
        }

        function closeSettings() {
            const overlay = document.getElementById("settingsOverlay");
            if (!overlay) return;
            overlay.classList.add("modal-hidden");
        }

        // ============================
        //  Download 헬퍼들
        // ============================

        // 현재 함수 이름 기준으로 파일명 만들기
        function getCurrentFilename(ext) {
            const labelEl = document.getElementById("currentFunc");
            let base = "autoflow_diagram";

            if (labelEl && labelEl.textContent) {
                const txt = labelEl.textContent;

                // "함수: Foo()" 또는 "Function : Foo()" 둘 다 지원
                const m = txt.match(/(?:함수|Function)\s*:\s*([^(]+)/);
                if (m && m[1]) {
                    base = m[1].trim();
                }
            }
            return base + "." + ext;
        }

        function triggerDownload(url, filename) {
            const a = document.createElement("a");
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }

        // SVG 다운로드
        function downloadAsSVG() {
            const svg = document.querySelector("#chartInner svg");
            if (!svg) {
                alert("There is no flowchart to download yet.");
                return;
            }

            const cloned = svg.cloneNode(true);
            cloned.setAttribute("xmlns", "http://www.w3.org/2000/svg");

            const serializer = new XMLSerializer();
            const source = serializer.serializeToString(cloned);
            const blob = new Blob([source], { type: "image/svg+xml;charset=utf-8" });
            const url = URL.createObjectURL(blob);

            triggerDownload(url, getCurrentFilename("svg"));
            setTimeout(() => URL.revokeObjectURL(url), 1000);
        }

        // 다운로드 타입에 따라 분기
        function downloadDiagram() {
            downloadAsSVG();
        }

        let typingTimer = null;
        const TYPING_DELAY_MS = 600;

        // 다이어그램 줌 상태 (내용만 확대, 레이아웃은 그대로)
        let diagramZoom = 1.0;

        function clampZoom(z) {
            if (z < 0.5) return 0.5;   // 50%
            if (z > 7.0) return 7.0;   // 700%
            return z;
        }
        function updateZoomLabel() {
            const label = document.getElementById("zoomLabel");
            label.textContent = Math.round(diagramZoom * 100) + "%";
        }

        // 공통 적용 함수
        function applyDiagramZoom() {
            const svg = document.querySelector("#chartInner svg");
            if (!svg) return;

            // 다이어그램의 기준 크기(100%)를 기준으로 확대/축소
            const percent = diagramZoom * 100;
            svg.style.width = percent + "%";
            svg.style.height = "auto";
        }

        // 플로우차트 컨테이너 안에서 노드를 화면 가운데로 스크롤
        function scrollNodeIntoCenter(node) {
            const container = document.getElementById("chartContainer");
            if (!node || !container) return;

            try {
                // 실제 화면 좌표(줌, 스크롤 모두 반영된 상태)
                const nodeRect = node.getBoundingClientRect();
                const contRect = container.getBoundingClientRect();

                const nodeCenterX = nodeRect.left + nodeRect.width  / 2;
                const nodeCenterY = nodeRect.top  + nodeRect.height / 2;
                const contCenterX = contRect.left + contRect.width  / 2;
                const contCenterY = contRect.top  + contRect.height / 2;

                // 컨테이너의 현재 스크롤 기준으로, 중심 차이만큼 더해줌
                container.scrollLeft += (nodeCenterX - contCenterX);
                container.scrollTop  += (nodeCenterY - contCenterY);
            } catch (e) {
                // getBoundingClientRect 실패하면 그냥 무시
                console.warn("scrollNodeIntoCenter error:", e);
            }
        }
        
        function zoomChange(delta) {
            diagramZoom = clampZoom(diagramZoom + delta);
            applyDiagramZoom();       // ← zoom 적용
            updateZoomLabel();
        }
        function zoomReset() {
            diagramZoom = 1.0;
            applyDiagramZoom();       // ← 100%로
            updateZoomLabel();
        }

        // ============================
        //  Status / Error helpers
        // ============================
        function setStatus(type, message) {
            const status = document.getElementById("status");
            if (!status) return;

            // type: "success" | "error" | "info" | "idle"
            let icon = "";
            if (type === "success") icon = "✅";
            else if (type === "error") icon = "❌";
            else if (type === "info") icon = "ℹ️";

            status.className = "";  // 기존 클래스 제거
            if (type === "success") status.classList.add("success");
            if (type === "error")   status.classList.add("error");

            status.textContent = icon ? `${icon} ${message}` : message;
        }

        async function fetchBackendVersion() {
            const el = document.getElementById("backendVersion");
            if (!el) return;

            try {
                const res = await fetch(API_BASE + "/version");
                if (!res.ok) {
                    throw new Error("HTTP " + res.status);
                }
                const data = await res.json();

                const ver = data.version || "unknown";
                const daily = data.daily_free_limit ?? DAILY_FREE_LIMIT;
                const nodeLimit = data.free_node_limit ?? FREE_NODE_LIMIT;

                el.textContent = `Backend: ${ver}`;
                el.title = `Daily limit: ${daily} diagrams/day, ≤ ${nodeLimit} nodes`;
            } catch (e) {
                console.warn("Failed to fetch backend version:", e);
                // 실패해도 UI 깨지진 않게 그냥 무시
            }
        }         

        // 백엔드에서 내려오는 에러 코드를 보기 좋게 매핑
        function mapBackendError(errorCode, rawError) {
            const msg  = (rawError || "").toString();
            const code = (errorCode || "").toString().toUpperCase();

            // 1) 명시적 코드 우선
            if (code === "NO_FUNCTION") {
                return "No function body was found in the code.";
            }
            if (code === "TOO_MANY_NODES") {
                return "The function is too large to analyze (too many flowchart nodes).";
            }
            if (code === "UNSUPPORTED_SYNTAX") {
                return "The code uses syntax that is not supported yet (for example, 'goto' inside 'switch').";
            }

            // 2) 코드가 없으면 메시지 패턴으로 추론
            if (/no function/i.test(msg)) {
                return "No function body was found in the code.";
            }
            if (/too many nodes/i.test(msg)) {
                return "The function is too large to analyze (too many flowchart nodes).";
            }
            if (/unsupported/i.test(msg)) {
                return "The code uses syntax that is not supported yet.";
            }

            // 3) 일단 알 수 없는 에러는 원문을 괄호로 남겨줌
            if (msg) {
                return `Failed to generate the flowchart. (${msg})`;
            }
            return "Failed to generate the flowchart due to an unknown error.";
        }


        // ============================
        //  코드 라인 하이라이트 관련 함수들
        // ============================

        // 매칭용 문자열 정규화 (공백/괄호/세미콜론 등 정리)
        function normalizeForMatch(s) {
            if (!s) return "";
            return String(s)
                .toLowerCase()
                .replace(/["']/g, "")       // 따옴표 제거
                .replace(/[{};]/g, "")      // 중괄호/세미콜론 제거
                .replace(/\s+/g, " ")       // 여러 공백 -> 한 칸
                .trim();
        }

        // ============================
        //  코드 라인 → 노드 하이라이트
        // ============================

        let lastHoverLineIdx = -1;  // 코드 영역 hover 시, 마지막으로 처리한 라인 인덱스

        function handleCodeHover(e) {
            const textarea = document.getElementById("src");
            if (!textarea) return;

            const rect  = textarea.getBoundingClientRect();
            const style = window.getComputedStyle(textarea);

            // line-height
            let lineHeight = parseFloat(style.lineHeight);
            if (Number.isNaN(lineHeight)) {
                const fontSize = parseFloat(style.fontSize) || 13;
                lineHeight = fontSize * 1.4;
            }

            const paddingTop = parseFloat(style.paddingTop) || 0;

            // textarea 안에서의 Y + 스크롤 - 패딩
            let offsetY = e.clientY - rect.top + textarea.scrollTop - paddingTop;
            if (offsetY < 0) offsetY = 0;

            const lineIdx = Math.floor(offsetY / lineHeight);
            if (lineIdx === lastHoverLineIdx) return;  // 같은 줄이면 다시 계산 X
            lastHoverLineIdx = lineIdx;

            highlightNodesForLine(lineIdx);
        }
              

        // 우측 노드 hover 시, 좌측 코드에 붉은 줄 표시
        function showHoverLine(lineIdx) {
            const textarea  = document.getElementById("src");
            const highlight = document.getElementById("hoverHighlight");
            if (!textarea || !highlight) return;

            const code  = textarea.value || "";
            const lines = code.split("\n");
            if (!lines.length) return;

            if (lineIdx < 0) lineIdx = 0;
            if (lineIdx >= lines.length) lineIdx = lines.length - 1;

            const style = window.getComputedStyle(textarea);
            let lineHeight = parseFloat(style.lineHeight);
            if (Number.isNaN(lineHeight)) {
                const fontSize = parseFloat(style.fontSize) || 13;
                lineHeight = fontSize * 1.4;
            }
            const paddingTop = parseFloat(style.paddingTop) || 0;

            const lineTopInTextarea = lineIdx * lineHeight;

            const top =
                textarea.offsetTop +
                paddingTop +
                (lineTopInTextarea - textarea.scrollTop);

            const left   = textarea.offsetLeft;
            const width  = textarea.clientWidth;
            const height = lineHeight;

            // 화면 밖이면 숨김
            if (
                top + height < textarea.offsetTop + paddingTop ||
                top > textarea.offsetTop + paddingTop + textarea.clientHeight
            ) {
                highlight.style.display = "none";
                return;
            }

            highlight.style.top    = `${top}px`;
            highlight.style.left   = `${left}px`;
            highlight.style.width  = `${width}px`;
            highlight.style.height = `${height}px`;
            highlight.style.display = "block";
        }

        function clearHoverLine() {
            const highlight = document.getElementById("hoverHighlight");
            if (!highlight) return;
            highlight.style.display = "none";
        }

        // 붉은 하이라이트 제거
        function clearHoverLine() {
            const highlight = document.getElementById("hoverHighlight");
            if (!highlight) return;
            highlight.style.display = "none";
        }


        // 선택된 노드 하이라이트 해제
        function clearNodeHighlight() {
            const svg = document.querySelector("#chartInner svg");
            if (!svg) return;
            svg.querySelectorAll(".node.autoflow-selected").forEach(n => {
                n.classList.remove("autoflow-selected");
            });
        }

        // 노드 라벨에서 "대표 한 줄"만 뽑기
        function getNodeLabelCore(node) {
            const rawText = (node.textContent || "").trim();
            if (!rawText) return "";

            if (rawText.indexOf("\n") !== -1) {
                const parts = rawText.split(/\n/).map(p => p.trim()).filter(Boolean);
                if (parts.length > 0) {
                    // ★ 가장 짧은 줄이 아니라, "첫 번째 줄"을 대표 라벨로 사용
                    //   ex) "case 2:" 가 맨 위에 있으면 무조건 그걸로 매칭
                    return parts[0];
                }
            }
            return rawText;
        }


        // 현재 줄과 노드 라벨의 매칭 점수 계산
        function calcMatchScore(normLine, normLabel) {
            if (!normLine || !normLabel) return 0;

            if (normLine === normLabel) return 3.0;  // 완전 일치 최우선

            if (normLine.indexOf(normLabel) !== -1) {
                // 라벨이 줄 안에 포함
                return normLabel.length / Math.max(1, normLine.length);
            }
            if (normLabel.indexOf(normLine) !== -1) {
                // 줄이 라벨 안에 포함
                return normLine.length / Math.max(1, normLabel.length);
            }
            return 0;
        }

        // 특정 라인 번호에 "가장 잘 맞는" 노드를 찾아 하이라이트 + 스크롤
        function highlightNodesForLine(lineIdx) {
            const svg = document.querySelector("#chartInner svg");
            if (!svg) return;

            const textarea = document.getElementById("src");
            if (!textarea) return;

            const code = textarea.value || "";
            const lines = code.split("\n");
            if (!lines.length) return;

            // 라인 인덱스 보정
            let idx = lineIdx;
            if (idx < 0) idx = 0;
            if (idx >= lines.length) idx = lines.length - 1;

            const normLine = normalizeForMatch(lines[idx]);
            if (!normLine) {
                clearNodeHighlight();
                return;
            }

            clearNodeHighlight();

            const nodes = svg.querySelectorAll(".node");
            let bestNode = null;
            let bestScore = 0;

            nodes.forEach(node => {
                const coreLabel = getNodeLabelCore(node);
                const normLabel = normalizeForMatch(coreLabel);
                if (!normLabel) return;

                const score = calcMatchScore(normLine, normLabel);
                if (score > bestScore) {
                    bestScore = score;
                    bestNode = node;
                }
            });

            if (!bestNode) return;

            bestNode.classList.add("autoflow-selected");
            scrollNodeIntoCenter(bestNode);
        }


        // 텍스트 커서 위치 기준으로 현재 라인 계산 → 노드 하이라이트
        function updateNodeHighlightFromCaret() {
            const textarea = document.getElementById("src");
            if (!textarea) return;

            const pos = textarea.selectionStart || 0;
            const textBefore = textarea.value.slice(0, pos);
            const lineIdx = textBefore.split("\n").length - 1;

            highlightNodesForLine(lineIdx);
        }

        // lineIdx 에 해당하는 줄을 그대로 하이라이트 (fallback 용)
        function highlightCodeAtLine(lineIdx) {
            const textarea = document.getElementById("src");
            if (!textarea) return -1;

            const code  = textarea.value;
            const lines = code.split("\n");
            if (!lines.length) return -1;

            // 인덱스 보정
            let idx = lineIdx;
            if (idx < 0) idx = 0;
            if (idx >= lines.length) idx = lines.length - 1;

            // 선택 범위 계산
            let start = 0;
            for (let i = 0; i < idx; i++) {
                start += lines[i].length + 1; // '\n'
            }
            const end = start + lines[idx].length;

            textarea.focus();
            textarea.setSelectionRange(start, end);

            // 가운데 쯤으로 스크롤
            const ratio        = idx / Math.max(1, lines.length - 1);
            const targetScroll = textarea.scrollHeight * ratio - textarea.clientHeight / 2;
            textarea.scrollTop = Math.max(0, targetScroll);

            return idx;
        }

        // 노드 라벨 텍스트를 기반으로 "가장 잘 맞는 코드 라인 인덱스" 찾기
        function findBestLineIndexForLabel(rawLabel) {
            const textarea = document.getElementById("src");
            if (!textarea) return -1;

            const code = textarea.value || "";
            if (!code) return -1;

            const lines = code.split("\n");

            let core = rawLabel || "";
            if (core.indexOf("\n") !== -1) {
                const parts = core.split(/\n/).map(p => p.trim()).filter(Boolean);
                if (parts.length > 0) {
                    // 라벨도 "첫 줄" 기준
                    core = parts[0];
                }
            }

            let label = normalizeForMatch(core);
            if (!label) return -1;
            if (label.length > 120) {
                label = label.slice(0, 120);
            }

            let bestLine = -1;
            let bestScore = 0;

            for (let i = 0; i < lines.length; i++) {
                const normLine = normalizeForMatch(lines[i]);
                if (!normLine) continue;

                let score = 0;
                if (normLine === label) {
                    score = 3.0; // 완전 일치
                } else if (normLine.indexOf(label) !== -1) {
                    score = label.length / Math.max(1, normLine.length);
                } else if (label.indexOf(normLine) !== -1) {
                    score = normLine.length / Math.max(1, label.length);
                }

                if (score > bestScore) {
                    bestScore = score;
                    bestLine = i;
                }
            }

            return bestLine;
        }

        // 노드 라벨 → 코드 라인 실제 선택
        function highlightCodeForLabel(rawLabel) {
            const bestLine = findBestLineIndexForLabel(rawLabel);
            if (bestLine < 0) return -1;
            return highlightCodeAtLine(bestLine);
        }


        // Mermaid 노드에 클릭/hover 핸들러 연결
        function attachNodeClickHandlers() {
            const svg = document.querySelector("#chartInner svg");
            if (!svg) return;

            const textarea = document.getElementById("src");
            const nodes = svg.querySelectorAll(".node");

            nodes.forEach(node => {
                node.style.cursor = "pointer";

                // 노드 클릭 → 좌측 코드 파란 선택
                node.addEventListener("click", () => {
                    if (!textarea) return;

                    clearNodeHighlight();
                    node.classList.add("autoflow-selected");
                    scrollNodeIntoCenter(node);

                    const rawText = node.textContent || "";
                    let label = rawText.replace(/\s+/g, " ").trim();
                    if (!label) return;

                    const lower = label.toLowerCase();
                    // 의미 없는 노드는 건너뜀
                    if (lower === "merge" || lower.startsWith("start") || lower.startsWith("end")) {
                        return;
                    }

                    // 라벨 텍스트만으로 가장 잘 맞는 코드 라인 선택
                    highlightCodeForLabel(label);

                    // 클릭하면 hover 붉은 줄은 지워준다
                    clearHoverLine();
                });

                // 노드 hover → 붉은 테두리 + 좌측 붉은 줄
                node.addEventListener("mouseenter", () => {
                    node.classList.add("autoflow-hover");

                    const rawText = node.textContent || "";
                    let label = rawText.replace(/\s+/g, " ").trim();
                    if (!label) {
                        clearHoverLine();
                        return;
                    }

                    const lower = label.toLowerCase();
                    if (lower === "merge" || lower.startsWith("start") || lower.startsWith("end")) {
                        clearHoverLine();
                        return;
                    }

                    const bestLine = findBestLineIndexForLabel(label);
                    if (bestLine >= 0) {
                        showHoverLine(bestLine);
                    } else {
                        clearHoverLine();
                    }
                });

                node.addEventListener("mouseleave", () => {
                    node.classList.remove("autoflow-hover");
                    clearHoverLine();
                });
            });
        }

        async function generateFlowchart(auto = false) {
            const status      = document.getElementById("status");
            const chartInner  = document.getElementById("chartInner");
            const currentFunc = document.getElementById("currentFunc");

            // 로그인 상태 확인
            if (!window.currentUser) {
                setStatus("error", "Please log in to use mAutoFlow.");
                return;
            }

            // 테스트 계정 여부
            const isTestUser = (window.currentUser.email === TEST_EMAIL);

            const srcEl = document.getElementById("src");
            const src = srcEl ? srcEl.value.trim() : "";
            if (!src) {
                if (!auto) {
                    setStatus("info", "Enter your C code on the left to generate a flowchart.");
                } else {
                    setStatus("idle", "");
                }
                currentFunc.textContent = "";
                chartInner.innerHTML = `
                    <p class="placeholder">
                        When you enter C code on the left, a flowchart is automatically generated on the right.
                    </p>`;
                return;
            }

            diagramZoom = 1.0;
            updateZoomLabel();

            setStatus("info", auto ? "Automatically updating the flowchart..." : "Creating the flowchart...");
            chartInner.innerHTML = "";

            const formData = new FormData();
            formData.append("source_code", src);
            formData.append("branch_shape", currentBranchShape);

            try {
                // ① Supabase에서 access_token 가져오기
                let accessToken = null;
                try {
                    const { data, error } = await supabase.auth.getUser();
                    // data.user 가 있고 session 이 있으면 토큰 읽기
                    const session = supabase.auth.getSession
                        ? (await supabase.auth.getSession()).data.session
                        : null;

                    if (session?.access_token) {
                        accessToken = session.access_token;
                    }
                } catch (e) {
                    console.warn("Failed to get Supabase user/session", e);
                }


                // 여기서 FormData 에 access_token 필드를 넣어준다
                if (accessToken) {
                    console.log(
                        "accessToken from Supabase:",
                        accessToken.slice(0, 20) + "..."   // 앞 20글자만 찍어서 길이 확인
                    );
                    formData.append("access_token", accessToken);
                    // 추가: user_id / user_email
                    if (window.currentUser) {
                        formData.append("user_id", window.currentUser.id);
                        formData.append("user_email", window.currentUser.email || "");
                    }
                } else {
                    setStatus("error", "Login session not found. Please log in again.");
                    return;
                }

                const res = await fetch(API_BASE + "/api/convert_text", {
                    method: "POST",
                    body: formData
                });

                if (!res.ok) {
                    let data = {};
                    try {
                        data = await res.json();
                    } catch (_) {}

                    // 429: 하루 무료 사용량 초과
                    if (res.status === 429) {
                        let detail = data.detail;

                        // detail 이 문자열이든 객체든 모두 처리
                        let code = null;
                        let usageFromServer = null;
                        let limitFromServer = null;

                        if (typeof detail === "string") {
                            code = detail;
                        } else if (detail && typeof detail === "object") {
                            code = detail.code || detail.detail || "";
                            if (typeof detail.usage_count === "number") {
                                usageFromServer = detail.usage_count;
                            }
                            if (typeof detail.daily_free_limit === "number") {
                                limitFromServer = detail.daily_free_limit;
                            }
                        }

                        code = (code || "").toString().toUpperCase();

                        if (code === "DAILY_LIMIT_EXCEEDED") {
                            if (!isTestUser) {
                                if (usageFromServer != null) {
                                    window.__serverUsageCount = usageFromServer;
                                }
                                if (limitFromServer != null) {
                                    window.__dailyFreeLimit = limitFromServer;
                                }
                                updateQuotaInfo();
                            }

                            setStatus(
                                "error",
                                `Daily free limit reached (${window.__dailyFreeLimit ?? DAILY_FREE_LIMIT} diagrams per day, up to ${FREE_NODE_LIMIT} nodes). Please try again tomorrow.`
                            );
                            chartInner.innerHTML = `
                                <p class="placeholder" style="color:#b91c1c;">
                                    Daily free limit reached. Please try again tomorrow.
                                </p>`;
                            currentFunc.textContent = "";
                            return;
                        }
                    }

                    // 📌 노드 초과 에러 (400) 포함한 나머지 에러 처리
                    const errorCode = (data.error_code || data.error || "").toString().toUpperCase();
                    if (errorCode === "TOO_MANY_NODES") {
                        const uiMsg = mapBackendError(errorCode, data.error);
                        setStatus("error", uiMsg);
                        chartInner.innerHTML = `
                            <p class="placeholder" style="color:#b91c1c;">
                                ${uiMsg}
                            </p>`;
                        currentFunc.textContent = "";
                        return;
                    }

                    // 그 외 일반 서버 에러
                    setStatus("error", `Server error (${res.status}). Please try again later.`);
                    chartInner.innerHTML = '<p class="placeholder">A server error occurred.</p>';
                    currentFunc.textContent = "";
                    return;
                }
                
                const data = await res.json();
                const mermaidCode = data.mermaid || "";
                const errorMsg    = data.error || "";
                const errorCode   = data.error_code || "";   // 없으면 빈 문자열
                const funcName    = data.func_name || "";
                const nodeLines   = data.node_lines || {};

                // 서버에서 내려준 사용량 정보 (일반 계정인 경우)
                if (!isTestUser && typeof data.usage_count === "number") {
                    window.__serverUsageCount = data.usage_count;
                }
                if (!isTestUser && typeof data.daily_free_limit === "number") {
                    window.__dailyFreeLimit = data.daily_free_limit;
                }

                if (errorMsg) {
                    const uiMsg = mapBackendError(errorCode, errorMsg);
                    setStatus("error", uiMsg);
                    chartInner.innerHTML = `<p class="placeholder" style="color:#b91c1c;">${uiMsg}</p>`;
                    currentFunc.textContent = "";
                    return;
                }

                const nodeCount = Object.keys(nodeLines).length;
                window.__nodeCount = nodeCount;
                window.__nodeLines = nodeLines;

                const codeHeader = document.getElementById("codeHeader");
                if (codeHeader) {
                    codeHeader.innerHTML = `
                        <span>mAutoFlow</span>
                        <span style="opacity:0.7;">Nodes: ${nodeCount}</span>`;
                }

                // 노드 제한 (테스트 계정은 무제한)
                if (!isTestUser && nodeCount > FREE_NODE_LIMIT) {
                    const msg = `This function has ${nodeCount} nodes. The free tier supports up to ${FREE_NODE_LIMIT} nodes per diagram.`;
                    setStatus("error", msg);

                    chartInner.innerHTML = `
                        <p class="placeholder" style="color:#b91c1c;">
                            Free tier supports up to ${FREE_NODE_LIMIT} nodes per diagram.
                        </p>`;
                    currentFunc.textContent = "";
                    return;
                }

                // 정상 플로우차트 생성
                chartInner.innerHTML = `<div class="mermaid">${mermaidCode}</div>`;
                mermaid.init(undefined, chartInner.querySelector(".mermaid"));
                applyDiagramZoom();
                setTimeout(attachNodeClickHandlers, 50);

                // 사용량 증가 (클라이언트 기준, 테스트 계정 제외)
                if (!isTestUser) {
                    // 같은 코드인지 비교 용도만 필요하면 이 정도만
                    lastCountedSource = src;
                }

                // 사용량 증가 없이, 메시지만 표시
                if (!isTestUser) {
                    setStatus(
                        "success",
                        "Refresh Complete. Free tier: 5 diagrams/day, ≤ 20 nodes."
                    );
                } else {
                    setStatus(
                        "success",
                        `${auto ? "Refresh Complete." : "Flowchart creation complete."} (Test account: unlimited)`
                    );
                }

                currentFunc.textContent = funcName ? `Function: ${funcName}()` : "";

                // 상단 무료 정책 안내 갱신
                updateQuotaInfo();

            } catch (err) {
                console.error(err);
                const msg = "An unexpected error occurred while talking to the server. Please try again.";
                setStatus("error", msg);
                chartInner.innerHTML = `<p class="placeholder" style="color:#b91c1c;">${msg}</p>`;
                currentFunc.textContent = "";
            }
        }

        function setupSplitDrag() {
            const main = document.querySelector(".main");
            const leftPane = document.getElementById("leftPane");
            const rightPane = document.getElementById("rightPane");
            const divider = document.getElementById("divider");

            let isDragging = false;

            divider.addEventListener("mousedown", function(e) {
                e.preventDefault();
                isDragging = true;
                document.body.style.cursor = "col-resize";
            });

            document.addEventListener("mousemove", function(e) {
                if (!isDragging) return;
                const rect = main.getBoundingClientRect();
                const totalWidth = rect.width;
                let offsetX = e.clientX - rect.left;
                // 최소/최대 비율 제한 (20% ~ 70%)
                let leftPercent = Math.max(0.2, Math.min(0.7, offsetX / totalWidth));
                let rightPercent = 1 - leftPercent;

                leftPane.style.flex = "0 0 " + (leftPercent * 100).toFixed(1) + "%";
                rightPane.style.flex = "0 0 " + (rightPercent * 100).toFixed(1) + "%";
            });

            document.addEventListener("mouseup", function() {
                if (isDragging) {
                    isDragging = false;
                    document.body.style.cursor = "default";
                }
            });
        }

        document.addEventListener("DOMContentLoaded", function() {
            const src = document.getElementById("src");
            const lineNumbers = document.getElementById("lineNumbers");

            // 라인 번호 업데이트 함수
            function updateLineNumbers() {
                if (!src || !lineNumbers) return;
                const lines = src.value.split("\n").length || 1;
                let html = "";
                for (let i = 1; i <= lines; i++) {
                    html += i + "<br>";
                }
                lineNumbers.innerHTML = html;
            }

            // 이벤트 연결 (입력/스크롤)
            if (src && lineNumbers) {
                src.addEventListener("input", updateLineNumbers);
                src.addEventListener("scroll", () => {
                    lineNumbers.scrollTop = src.scrollTop;  // 스크롤 동기화
                });
                updateLineNumbers(); // 초기 1,2,3,... 표시
            }

            // ----- 초기 테마 로딩 -----
            let savedTheme = "classic";
            try {
                const t = localStorage.getItem("autoflow-theme");
                if (t) savedTheme = t;
            } catch (e) {}
            applyTheme(savedTheme);

            // 라디오 버튼 상태 동기화
            const themeRadios = document.querySelectorAll('input[name="theme"]');
            themeRadios.forEach(r => {
                if (r.value === savedTheme) {
                    r.checked = true;
                }
                r.addEventListener("change", (e) => {
                    if (e.target.checked) {
                        applyTheme(e.target.value);
                        // 테마 바뀌면 플로우차트도 다시 그려주고 싶으면:
                        // generateFlowchart(true);
                    }
                });
            });

            // Branch Shape 초기화
            let savedBranchShape = "rounded";
            try {
                const bs = localStorage.getItem("autoflow-branch-shape");
                if (bs) savedBranchShape = bs;
            } catch (e) {}
            currentBranchShape = savedBranchShape;

            const branchRadios = document.querySelectorAll('input[name="branchShape"]');
            branchRadios.forEach(r => {
                if (r.value === savedBranchShape) {
                    r.checked = true;
                }
                r.addEventListener("change", (e) => {
                    if (e.target.checked) {
                        currentBranchShape = e.target.value;
                        try {
                            localStorage.setItem("autoflow-branch-shape", currentBranchShape);
                        } catch (e2) {}
                        // 필요하면 테마처럼 자동 재생성도 가능:
                        generateFlowchart(true);
                    }
                });
            });

            updateZoomLabel();
            setupSplitDrag();

            // 코드 → 노드 하이라이트 연동
            ["click", "keyup", "mouseup"].forEach(ev => {
                src.addEventListener(ev, updateNodeHighlightFromCaret);
            });

            // 코드 영역 위에 마우스만 올려도 → 해당 라인의 노드 하이라이트
            src.addEventListener("mousemove", handleCodeHover);

            // 우측 플로우차트 영역에서 Ctrl+휠로 그림만 줌
            const chartContainer = document.getElementById("chartContainer");
            chartContainer.addEventListener("wheel", function(e) {
                // Ctrl 키가 눌려 있지 않으면 그냥 스크롤
                if (!e.ctrlKey) return;

                // 브라우저의 기본 페이지 줌 막기
                e.preventDefault();

                // deltaY < 0 이면 휠 위로(확대), > 0 이면 아래로(축소)
                if (e.deltaY < 0) {
                    zoomChange(+0.1);
                } else if (e.deltaY > 0) {
                    zoomChange(-0.1);
                }
            }, { passive: false });

            // 🔹 좌클릭 드래그로 패닝
            let isPanning = false;
            let startX = 0;
            let startY = 0;
            let startScrollLeft = 0;
            let startScrollTop = 0;

            chartContainer.addEventListener("mousedown", function(e) {
                if (e.button !== 0) return; // 왼쪽 버튼만
                isPanning = true;
                startX = e.clientX;
                startY = e.clientY;
                startScrollLeft = chartContainer.scrollLeft;
                startScrollTop = chartContainer.scrollTop;
                e.preventDefault(); // 텍스트 선택 방지
            });

            document.addEventListener("mousemove", function(e) {
                if (!isPanning) return;
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                chartContainer.scrollLeft = startScrollLeft - dx;
                chartContainer.scrollTop = startScrollTop - dy;
            });

            document.addEventListener("mouseup", function() {
                isPanning = false;
            });            


            // 타이핑 자동 업데이트 (debounce)
            src.addEventListener("input", function() {
                if (typingTimer) clearTimeout(typingTimer);
                typingTimer = setTimeout(function() {
                    generateFlowchart(true);
                }, TYPING_DELAY_MS);
            });
            
            // 코드 클릭/이동 시 → 해당 라인 노드 하이라이트
            src.addEventListener("click", updateNodeHighlightFromCaret);
            src.addEventListener("keyup", updateNodeHighlightFromCaret);
            src.addEventListener("mouseup", updateNodeHighlightFromCaret);

            // 백엔드 버전 정보 표시
            fetchBackendVersion();
        });
    </script>
</head>
<body>
    <header>
        <div>
            <h1>mAutoFlow</h1>
            <div class="subtitle">
                When you enter C code on the left, a flowchart is automatically generated on the right.
            </div>
        </div>

        <!-- 오른쪽 상단 메뉴: 로그인 + 버튼 + 백엔드 버전 -->
        <div class="topbar-right">
            <!-- 로그인 영역 -->
            <span id="welcomeText" style="margin-right:8px;"></span>

            <div id="loggedOutButtons" style="display:inline-flex; gap:4px; margin-right:8px;">
                <button class="btn-settings" onclick="loginWithGoogle()">Login with Google</button>
            </div>

            <div id="loggedInButtons" style="display:none; gap:4px; margin-right:8px;">
                <button class="btn-settings" onclick="logout()">Logout</button>
            </div>
            <!-- 로그인 영역 끝 -->

            <!-- 기능 버튼들 -->
            <button class="btn-settings" onclick="downloadDiagram()">DOWNLOAD</button>
            <button class="btn-settings" onclick="openSettings()">SETTINGS</button>
            <button id="helpToggleBtn" class="btn-settings" onclick="toggleHelp()">HELP</button>

            <!-- 백엔드 버전 표시 -->
            <span id="backendVersion" style="margin-left:8px; font-size:11px; opacity:0.75;"></span>
        </div>
    </header>
    <div class="main">
        <div id="leftPane">
            <div class="pane-header">
                <span class="pane-title">Source Code</span>
            </div>
            <div id="codeContainer">
                <div id="codeHeader">
                    <span>mAutoFlow</span>
                    <span style="opacity:0.7;">Automatic analysis</span>
                </div>
                <div id="codeArea">
                    <div id="lineNumbers"></div>
                    <textarea id="src" spellcheck="false" placeholder="Example:
void main(void)
{
    int x = 0;

    if (x == 0)
    {
        x++;
    }
    else
    {
        x--;
    }
}"></textarea>
    <!-- 노드 hover 시 코드 라인 붉게 표시 -->
    <div id="hoverHighlight"></div>
                </div>
            </div>
        </div>

        <div id="divider"></div>

        <div id="rightPane">
            <div class="pane-header">
                <span class="pane-title">Flowchart</span>
                <div style="display:flex; align-items:center; gap:6px;">
                    <button class="btn btn-ghost" onclick="zoomChange(-0.1)">−</button>
                    <button class="btn btn-ghost" onclick="zoomReset()">100%</button>
                    <button class="btn btn-ghost" onclick="zoomChange(0.1)">+</button>
                    <span class="zoom-label" id="zoomLabel"></span>
                </div>
            </div>
            <div id="toolbar">
                <button class="btn btn-primary" onclick="generateFlowchart(false)">Regenerate Now</button>
                <span id="currentFunc"></span>
                <span id="status"></span>
                <span id="quotaInfo" style="margin-left:8px; font-size:12px; opacity:0.8;"></span>
            </div>
            <div id="chartContainer">
                <div id="chartInner">
                    <p class="placeholder">
                        When you enter C code on the left, a flowchart is automatically generated on the right.
                    </p>
                </div>
            </div>
        </div>
    </div>
    <!-- SETTINGS 모달: 여기 추가 -->
    <div id="settingsOverlay" class="modal-overlay modal-hidden">
        <div class="modal-panel">
            <div class="modal-header">
                <h2>SETTINGS</h2>
                <button class="modal-close" onclick="closeSettings()">×</button>
            </div>

            <!-- Theme 섹션 -->
            <div class="modal-section">
                <div class="modal-section-title">Theme</div>
                <div class="modal-radio-row">
                    <label>
                        <input type="radio" name="theme" value="classic" checked />
                        Classic (Current style)
                    </label>
                    <label>
                        <input type="radio" name="theme" value="light" />
                        Light
                    </label>
                    <label>
                        <input type="radio" name="theme" value="dark" />
                        Dark
                    </label>
                </div>
            </div>

            <!-- Branch Shape 섹션 추가 -->
            <div class="modal-section">
                <div class="modal-section-title">Branch Shape</div>
                <div class="modal-radio-row">
                    <label>
                        <input type="radio" name="branchShape" value="rounded" checked />
                        Rounded (Stadium / Rounded rectangle)
                    </label>
                    <label>
                        <input type="radio" name="branchShape" value="diamond" />
                        Diamond
                    </label>
                </div>
            </div>

            <div style="text-align:right; margin-top:10px; font-size:12px;">
                <button class="btn btn-ghost" onclick="closeSettings()">Close</button>
            </div>
        </div>
    </div>
    <!--  Supabase Auth 스크립트: </body> 바로 위에 추가 -->
    <script type="module">
        import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

        //  여기 두 값은 본인 프로젝트 값으로 교체해야 함
        const SUPABASE_URL = "https://layaiawwnioetzuxcyev.supabase.co";   // 예시: 대쉬보드의 Project URL
        const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImxheWFpYXd3bmlvZXR6dXhjeWV2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQ3NjIxMjgsImV4cCI6MjA4MDMzODEyOH0.ZWC86hD5JaX2Jh0b0wR6bfmqNrEWBrq-YnLu3yg1JJo";            // API 탭의 anon public key

        const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        // 전역에서 접근할 수 있게 window에 붙이기
        window.supabase = supabase;

        // 현재 로그인 유저를 전역으로 보관
        window.currentUser = null;

        async function updateAuthUI() {
            const { data } = await supabase.auth.getUser();
            const user = data?.user ?? null;
            window.currentUser = user;

            const welcomeText   = document.getElementById("welcomeText");
            const loggedOutDiv  = document.getElementById("loggedOutButtons");
            const loggedInDiv   = document.getElementById("loggedInButtons");

            if (!welcomeText || !loggedOutDiv || !loggedInDiv) return;

            if (user) {
                welcomeText.textContent = user.email
                    ? `Welcome, ${user.email}`
                    : "Welcome!";
                loggedOutDiv.style.display = "none";
                loggedInDiv.style.display  = "inline-flex";
            } else {
                welcomeText.textContent = "";
                loggedOutDiv.style.display = "inline-flex";
                loggedInDiv.style.display  = "none";
            }

            // 로그인/로그아웃 시 무료 사용량 표시 갱신
            updateQuotaInfo();
        }

        async function loginWithGoogle() {
            await supabase.auth.signInWithOAuth({
                provider: "google",
                options: {
                    // redirectTo: "https://mautoflow-lab.netlify.app",  // Netlify 실제 URL
                    redirectTo: "https://mautoflow-frontend.pages.dev",  // Cloudflare URL
                    queryParams: {
                        // 매번 계정 선택 화면 강제
                        prompt: "select_account"
                    }
                }
            });
        }

        function clearAppUIOnLogout() {
            const src         = document.getElementById("src");
            const lineNumbers = document.getElementById("lineNumbers");
            const status      = document.getElementById("status");
            const currentFunc = document.getElementById("currentFunc");
            const chartInner  = document.getElementById("chartInner");
            const codeHeader  = document.getElementById("codeHeader");
            const quotaInfo = document.getElementById("quotaInfo");
            if (quotaInfo) {
              quotaInfo.textContent = "Free tier: up to 5 diagrams/day (≤ 20 nodes).";
            }

            // 코드 영역 비우기
            if (src) {
                src.value = "";
                src.scrollTop = 0;
            }

            // 라인 번호 초기화 (1 한 줄만)
            if (lineNumbers) {
                lineNumbers.innerHTML = "1<br>";
            }

            // 상태 메시지: 로그인 필요
            if (status) {
                status.textContent = "Please log in to use mAutoFlow.";
                status.className = "error";
            }

            // 현재 함수명 제거
            if (currentFunc) {
                currentFunc.textContent = "";
            }

            // 플로우차트 자리 초기화 문구
            if (chartInner) {
                chartInner.innerHTML = `
                    <p class="placeholder">
                        When you enter C code on the left, a flowchart is automatically generated on the right.
                    </p>
                `;
            }

            // 코드 헤더 텍스트도 기본값으로
            if (codeHeader) {
                codeHeader.innerHTML = `
                    <span>mAutoFlow</span>
                    <span style="opacity:0.7;">Automatic analysis</span>
                `;
            }

            // 내부 상태 리셋
            window.__nodeLines = {};
            window.__nodeCount = 0;
            lastCountedSource = "";   // 로그아웃하면 기준 코드도 초기화
        }

        async function logout() {
            await supabase.auth.signOut();
            await updateAuthUI();
            clearAppUIOnLogout();
        }

        //  전역에서 호출 가능하도록 window에 붙이기
        window.loginWithGoogle = loginWithGoogle;
        window.logout          = logout;

        // 첫 로딩 시 로그인 상태 반영
        document.addEventListener("DOMContentLoaded", updateAuthUI);
        window.updateQuotaInfo = updateQuotaInfo;
    </script>
    <!--  Supabase Auth 스크립트 끝 -->

</body>
</html>

