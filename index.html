<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <title>mAutoFlow</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        :root {
            /* ê¸°ë³¸ í…Œë§ˆ (classic) */
            --bg-main: #f3f4f6;
            --bg-header: #1f2933;
            --header-text: #f9fafb;

            --bg-code: #111827;
            --code-text: #e5e7eb;
            --code-border: #d1d5db;

            --bg-chart: #ffffff;
            --chart-border: #d1d5db;

            --accent-primary: #2563eb;
            --accent-primary-hover: #1d4ed8;

            --toolbar-text: #374151;
        }

        /* ë¼ì´íŠ¸ í…Œë§ˆ */
        body[data-theme="light"] {
            --bg-main: #f9fafb;
            --bg-header: #2563eb;
            --header-text: #ffffff;

            --bg-code: #ffffff;
            --code-text: #111827;
            --code-border: #d1d5db;

            --bg-chart: #ffffff;
            --chart-border: #d1d5db;

            --accent-primary: #2563eb;
            --accent-primary-hover: #1d4ed8;

            --toolbar-text: #111827;
        }

        /* ë‹¤í¬ í…Œë§ˆ */
        body[data-theme="dark"] {
            --bg-main: #020617;
            --bg-header: #020617;
            --header-text: #e5e7eb;

            --bg-code: #020617;
            --code-text: #e5e7eb;
            --code-border: #1f2937;

            --bg-chart: #020617;
            --chart-border: #1f2937;

            --accent-primary: #22c55e;
            --accent-primary-hover: #16a34a;

            --toolbar-text: #e5e7eb;
        }

        /* Mermaid SVG Override (dark) */
        body[data-theme="dark"] #chartInner svg path {
            stroke: #f8fafc !important;
        }
        body[data-theme="dark"] #chartInner svg line {
            stroke: #f8fafc !important;
        }
        body[data-theme="dark"] #chartInner svg polygon {
            stroke: #f8fafc !important;
            fill: #f8fafc !important;
        }
        body[data-theme="dark"] #chartInner svg marker path {
            stroke: #f8fafc !important;
            fill: #f8fafc !important;
        }
    
        * { box-sizing: border-box; }
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
        }
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            font-size: 14px; /* UI ê¸°ë³¸ í°íŠ¸ */
            background: var(--bg-main);
        }
        header {
            padding: 10px 16px;
            background: var(--bg-header); /* â† ë³€ê²½ */
            color: var(--header-text);    /* â† ë³€ê²½ */
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        header h1 {
            margin: 0;
            font-size: 20px;
        }
        header .subtitle {
            font-size: 12px;
            opacity: 0.85;
        }

        .main {
            flex: 1;
            display: flex;
            min-height: 0;
            background: var(--bg-main);
        }

        #helpContent .help-link {
            color: var(--accent-primary);
            text-decoration: underline;
            font-weight: 600;
        }

        /* ì¢Œì¸¡/ìš°ì¸¡ íŒ¨ë„ + ë“œë˜ê·¸ ë¶„í• ë°” */
        #leftPane {
            flex: 0 0 33%; /* ì´ˆê¸° ì•½ 1/3 */
            min-width: 200px;
            display: flex;
            flex-direction: column;
            padding: 8px;
        }
        #divider {
            flex: 0 0 6px;
            cursor: col-resize;
            background: #d1d5db;
        }
        #divider:hover {
            background: #9ca3af;
        }
        #rightPane {
            flex: 0 0 67%; /* ì´ˆê¸° ì•½ 2/3 */
            min-width: 260px;
            display: flex;
            flex-direction: column;
            padding: 8px;
        }

        .pane-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 6px;
        }
        .pane-title {
            font-weight: 600;
            font-size: 14px;
            color: var(--toolbar-text);
        }

        /* ì¢Œì¸¡ ì½”ë“œ ì˜ì—­ */
        #codeContainer {
            flex: 1;
            border-radius: 4px;
            border: 1px solid var(--code-border);  /* â† ë³€ê²½ */
            background: var(--bg-code);            /* â† ë³€ê²½ */
            display: flex;
            flex-direction: column;
        }
        #codeHeader {
            padding: 4px 8px;
            border-bottom: 1px solid #4b5563;
            color: var(--code-text);      /* â† ë³€ê²½ */
            font-size: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #codeArea {
            flex: 1;
            padding: 6px;
            display: flex;    /* â† ë¼ì¸ë²ˆí˜¸ + textarea ê°€ ê°€ë¡œë¡œ ë°°ì¹˜ë˜ë„ë¡ */
        }

        #lineNumbers {
            width: 40px;  /* ë¼ì¸ ë²ˆí˜¸ ì˜ì—­ ë„ˆë¹„ */
            padding: 6px 4px;
            text-align: right;
            color: var(--code-text);
            background: var(--bg-code);
            border-right: 1px solid var(--code-border);
            font-family: "Consolas", "Roboto Mono", monospace;
            font-size: 13px;
            line-height: 1.4;
            user-select: none;        /* ë¼ì¸ ë²ˆí˜¸ ë“œë˜ê·¸ ë°©ì§€ */
            overflow: hidden;
        }
        
        #src {
            width: 100%;
            height: 100%;
            border: none;
            outline: none;
            resize: none;
            background: transparent;
            color: var(--code-text);      /* â† ë³€ê²½ */
            font-family: "Consolas", "Roboto Mono", monospace;
            font-size: 13px;  /* ì½”ë“œ ê¸€ì í¬ê¸° (ë„ˆë¬´ í¬ì§€ ì•Šê²Œ) */
            line-height: 1.4;
            flex: 1;                  /* â† ë‚¨ì€ ì˜ì—­ ê½‰ ì±„ìš°ê¸° */
        }

        /* ìš°ì¸¡ í”Œë¡œìš°ì°¨íŠ¸ ì˜ì—­ */
        #toolbar {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
            font-size: 12px;
        }
        .btn {
            padding: 4px 10px;
            border-radius: 4px;
            border: none;
            cursor: pointer;
            font-size: 12px;
        }
        .btn-primary {
            background: var(--accent-primary);           /* â† ë³€ê²½ */
            color: white;
        }
        .btn-primary:hover {
            background: var(--accent-primary-hover);     /* â† ë³€ê²½ */
        }
        .btn-ghost {
            background: #e5e7eb;
            color: #111827;
        }
        .btn-ghost:hover {
            background: #d1d5db;
        }

        #status {
            font-size: 12px;
            color: var(--toolbar-text);                  /* â† ë³€ê²½ */
        }
        #status.error {
            color: #b91c1c;
        }
        #status.success {
            color: #15803d;
        }
        #currentFunc {
            font-weight: 600;
            font-size: 12px;
            color: var(--toolbar-text);
        }

        #chartContainer {
            flex: 1;
            border-radius: 4px;
            border: 1px solid var(--chart-border); /* â† ë³€ê²½ */
            background: var(--bg-chart);           /* â† ë³€ê²½ */
            overflow: auto;

            /* flex ì œê±°í•˜ê³ , ì¼ë°˜ ë¸”ë¡ + í…ìŠ¤íŠ¸ ì •ë ¬ë¡œ ê°€ìš´ë° ë§ì¶”ê¸° */
            text-align: center;
        }
        #chartInner {
            display: inline-block;   /* ê°€ìš´ë° ì •ë ¬ ëŒ€ìƒ */
            margin: 8px;
            transform-origin: top center;  /* í™•ëŒ€ ê¸°ì¤€ì€ ê·¸ëŒ€ë¡œ ì¤‘ì•™ */
        }
        #chartInner .mermaid {
            margin: 0 auto;
        }

        .placeholder {
            color: #9ca3af;
            font-size: 14px;
            text-align: center;
            margin-top: 40px;
        }

        /* Mermaidê°€ ê·¸ë¦¬ëŠ” SVGë¥¼ ìš°ì¸¡ íŒ¨ë„ ë„ˆë¹„ì— ë§ê²Œ ì¡°ì • */
        #chartInner svg {
            max-width: none;
            height: auto;
            display: block;
            margin: 0 auto;
        }
        

        .zoom-label {
            font-size: 12px;
            min-width: 42px;
            color: var(--toolbar-text);
        }

        /* ì½”ë“œ â†” ë…¸ë“œ ì—°ë™: ì„ íƒëœ ë…¸ë“œ í•˜ì´ë¼ì´íŠ¸ (ë” ì§„í•˜ê²Œ) */
        .node.autoflow-selected rect,
        .node.autoflow-selected polygon,
        .node.autoflow-selected path {
            stroke: #ff0000;              /* ë” ê°•í•œ ë¹¨ê°„ìƒ‰ */
            stroke-width: 4px;            /* í…Œë‘ë¦¬ ë‘ê»˜ ì—… */
            stroke-dasharray: 0;          /* ì‹¤ì„  */
            filter: drop-shadow(0 0 6px rgba(255, 0, 0, 0.9));
        }

        /* ì„ íƒëœ ë…¸ë“œ í…ìŠ¤íŠ¸ë„ ê°•ì¡° */
        .node.autoflow-selected text {
            font-weight: 700;
            fill: #000000;
        }

        ..topbar-right {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            opacity: 0.9;
            flex-wrap: nowrap;    /* ë²„íŠ¼ ì¤„ë°”ê¿ˆ ë°©ì§€ */
            white-space: nowrap;  /* í…ìŠ¤íŠ¸ ì¤„ë°”ê¿ˆ ë°©ì§€ */
        }

        .btn-settings {
            padding: 4px 10px;
            border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.4);
            background: transparent;
            color: inherit;
            cursor: pointer;
            font-size: 12px;
        }
        .btn-settings:hover {
            background: rgba(255,255,255,0.12);
        }

        /* HELP ëª¨ë“œì—ì„œ CODE ë²„íŠ¼ ë§¤ìš° ë¶€ë“œëŸ¬ìš´ ê°•ì¡°ìš© */
        .btn-code-blink {
            background: #f59e0b;             /* ê¸°ì¡´ë³´ë‹¤ ë” ì—°í•œ ì£¼í™©ìƒ‰ */
            color: #ffffff;
            border-color: #fcd34d;           /* ì—°í•œ í…Œë‘ë¦¬ */
            animation: codeSoftBlink 2.4s ease-in-out infinite; /* ë” ëŠë¦¬ê³  ë¶€ë“œëŸ½ê²Œ */
        }

        /* Upgrade ë²„íŠ¼ ë¸”ë§í¬ ì• ë‹ˆë©”ì´ì…˜ */
        @keyframes upgradeBlink {
            0%   { background-color: #a7f3d0; }  /* pastel green */
            50%  { background-color: #6ee7b7; }
            100% { background-color: #a7f3d0; }
        }

        .upgrade-blink {
            animation: upgradeBlink 1s infinite;
        }

        @keyframes codeSoftBlink {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.6;                /* ê¸°ì¡´ 0.35 â†’ í›¨ì”¬ ëœ íë ¤ì§ */
            }
        }
                

        /* SETTINGS ëª¨ë‹¬ */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(15,23,42,0.55);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 50;
        }
        .modal-hidden {
            display: none;
        }
        .modal-panel {
            background: #ffffff;
            border-radius: 8px;
            padding: 16px 20px;
            min-width: 260px;
            max-width: 320px;
            box-shadow: 0 10px 40px rgba(15,23,42,0.45);
            font-size: 13px;
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }
        .modal-header h2 {
            margin: 0;
            font-size: 14px;
        }
        .modal-close {
            border: none;
            background: transparent;
            cursor: pointer;
            font-size: 16px;
        }
        .modal-section {
            margin-bottom: 12px;
        }
        .modal-section-title {
            font-weight: 600;
            margin-bottom: 6px;
        }
        .modal-radio-row {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
      
    </style>


    <script>
        const API_BASE = "https://mautoflow-backend.onrender.com";
        const PRO_CHECKOUT_URL =
          "https://mautoflow-lab.lemonsqueezy.com/buy/0d07c522-4264-4c87-a865-85ef42852174";

        function openProCheckout() {
          // í•„ìš”í•˜ë©´ ë‚˜ì¤‘ì— currentUser ì²´í¬í•´ì„œ ë¡œê·¸ì¸ ì•ˆ ëœ ê²½ìš° ë§‰ì„ ìˆ˜ë„ ìˆìŒ
          window.location.href = PRO_CHECKOUT_URL;
        }

	mermaid.initialize({ startOnLoad: false });
        
	mermaid.initialize({ startOnLoad: false });

	// ì „ì—­ ì„ ì–¸ (ì–´ë””ì„œë“  ì ‘ê·¼ ê°€ëŠ¥)
        let funcNameStyle = "short";

	// ì„œë²„ì—ì„œ ë‚´ë ¤ì¤€ ì‚¬ìš©ëŸ‰ / í•œë„ (ì—†ìœ¼ë©´ null)
        window.__serverUsageCount = null;
        window.__dailyFreeLimit  = null;

        // êµ¬ë…/ê³„ì • ìƒíƒœ
        window.__isProUser      = false;
        window.__planName       = null;
        window.__isTestAccount  = false;
        // free | pro | expert
        window.__planTier       = "free";

	let lastCountedSource = "";   // ë§ˆì§€ë§‰ìœ¼ë¡œ ì‚¬ìš©ëŸ‰ì„ ì˜¬ë ¸ë˜ ì†ŒìŠ¤ ì½”ë“œ

	// âœ… í…ŒìŠ¤íŠ¸ ì „ìš© ê³„ì • (ë¬´ì œí•œ)
        const TEST_EMAIL = "exitgiveme@gmail.com";

        // ===== í•˜ë£¨ ë¬´ë£Œ ì‚¬ìš©ëŸ‰ ì„¤ì • =====
        const DAILY_FREE_LIMIT = 5;       // í•˜ë£¨ ë¬´ë£Œ 5íšŒ
        const FREE_NODE_LIMIT  = 20;      // Free: ë…¸ë“œ 20ê°œê¹Œì§€
        const PRO_NODE_LIMIT   = 200;     // Pro: ë…¸ë“œ 200ê°œê¹Œì§€
        const EXPERT_NODE_LIMIT  = 1000;  // Expert: ë…¸ë“œ 1000ê°œê¹Œì§€
        const USAGE_KEY        = "autoflow_daily_usage";

        function getTodayKey() {
            // YYYY-MM-DD í˜•ì‹
            return new Date().toISOString().slice(0, 10);
        }

        function getTodayUsage() {
            const today = getTodayKey();
            let raw = null;
            try {
                raw = localStorage.getItem(USAGE_KEY);
            } catch (e) {
                return { date: today, count: 0 };
            }

            if (!raw) {
                return { date: today, count: 0 };
            }

            try {
                const data = JSON.parse(raw);
                if (!data.date || data.date !== today) {
                    // ë‚ ì§œê°€ ë‹¤ë¥´ë©´ ìƒˆë¡œ ì‹œì‘
                    return { date: today, count: 0 };
                }
                if (typeof data.count !== "number") {
                    return { date: today, count: 0 };
                }
                return { date: today, count: data.count };
            } catch (e) {
                return { date: today, count: 0 };
            }
        }

        function saveTodayUsage(obj) {
            try {
                localStorage.setItem(USAGE_KEY, JSON.stringify(obj));
            } catch (e) {
                // ì €ì¥ ì‹¤íŒ¨ëŠ” ê·¸ëƒ¥ ë¬´ì‹œ
            }
        }
	
	
const HELP_TEXT_HTML = `
        <h2 style="margin-top:0;">mAutoFlow â€“ Help</h2>

        <p>
            mAutoFlow converts C / pseudo-C functions into a structured flowchart.
            The left side is the source editor and the right side is the diagram viewer.
            Code and nodes are synchronized in both directions.
        </p>

        <h3>1. Basic Concept</h3>
        <ul>
            <li>mAutoFlow focuses on <strong>a single function</strong> at a time.</li>
            <li>When you type or paste C code on the left, mAutoFlow finds a function.</li>
            <li>The body of the selected function is analyzed and rendered as a flowchart on the right.</li>
            <li>
                Use the <strong>HELP</strong> button in the top-right toolbar to switch between
                <strong>Code view</strong> and <strong>Help view</strong>.
                When Help is open, the button label becomes <strong>CODE</strong>; click it again to return to the editor.
            </li>
        </ul>

        <h3>2. Writing / Pasting Code</h3>
        <ul>
            <li>Paste normal C code or pseudo-C code into the editor.</li>
            <li>Function prototypes and global variables are allowed; mAutoFlow focuses on the chosen function body.</li>
            <li>Supported constructs:
                <ul>
                    <li><code>if / else if / else</code></li>
                    <li><code>for</code>, <code>while</code>, <code>doâ€¦while</code></li>
                    <li><code>switch / case / default</code></li>
                    <li><code>return</code>, <code>break</code>, <code>continue</code></li>
                    <li>Simple assignments and expressions (e.g. <code>x++;</code>, <code>flag = true;</code>)</li>
                </ul>
            </li>
            <li>Very complex or unusual syntax may not be visualized perfectly, 
                but the main control flow should still appear.</li>
        </ul>

        <h3>3. Automatic Refresh</h3>
        <ul>
            <li>mAutoFlow watches your typing in the left editor.</li>
            <li>After a short idle delay, the flowchart is automatically regenerated.</li>
            <li>If you do not want to wait, press <strong>â€œRegenerate Nowâ€</strong> to force an immediate update.</li>
        </ul>

        <h3>4. Code â‡„ Flowchart Synchronization</h3>
        <ul>
            <li><strong>From code to flowchart</strong>:
                <ul>
                    <li>Click a line in the editor (or move the caret).</li>
                    <li>The best-matching node in the chart is highlighted in red.</li>
                    <li>The diagram view automatically scrolls to keep the node visible.</li>
                </ul>
            </li>
            <li><strong>From flowchart to code</strong>:
                <ul>
                    <li>Click a node on the diagram.</li>
                    <li>The corresponding line in the editor is selected.</li>
                    <li>The editor scrolls so the line is centered vertically.</li>
                    <li>â€œstart / end / mergeâ€ nodes are ignored to avoid meaningless jumps.</li>
                </ul>
            </li>
            <li>A fuzzy matching algorithm is used, so minor formatting differences are tolerated.</li>
        </ul>

        <h3>5. Zooming & Panning the Diagram</h3>
        <ul>
            <li>Use the buttons in the Flowchart header:
                <ul>
                    <li><strong>âˆ’</strong>: zoom out</li>
                    <li><strong>100%</strong>: reset zoom</li>
                    <li><strong>+</strong>: zoom in</li>
                </ul>
            </li>
            <li><strong>Ctrl + mouse wheel</strong> over the diagram zooms as well.</li>
            <li><strong>Left-drag</strong> to pan when the chart is larger than the viewport.</li>
            <li>The current zoom level is shown on the right side of the toolbar.</li>
        </ul>

        <h3>6. Downloading the Diagram</h3>
        <ul>
            <li>Click the <strong>DOWNLOAD</strong> button in the top-right toolbar.</li>
            <li>The current flowchart is exported as an <strong>SVG</strong> file.</li>
            <li>File name is based on the current function name (e.g. <code>MyFunction.svg</code>).</li>
            <li>SVG is resolution-independent and ideal for documents and high-quality printing.</li>
        </ul>

        <h3>7. Themes</h3>
        <ul>
            <li>Open <strong>SETTINGS</strong> from the top-right toolbar.</li>
            <li>You can choose:
                <ul>
                    <li><strong>Classic</strong> â€“ default colors & layout</li>
                    <li><strong>Light</strong> â€“ light UI suitable for bright environments</li>
                    <li><strong>Dark</strong> â€“ dark UI optimized for low-light work</li>
                </ul>
            </li>
            <li>Your selection is saved in local storage and restored next time.</li>
        </ul>

        <h3>8. Typical Workflow</h3>
        <ol>
            <li>Paste a function from your C project into the editor.</li>
            <li>Wait for automatic refresh or click â€œRegenerate Nowâ€.</li>
            <li>Inspect the resulting flowchart.</li>
            <li>Click nodes to jump directly to code.</li>
            <li>Modify code to simplify logic or conditions.</li>
            <li>Download SVG for documentation or design reviews.</li>
        </ol>

        <h3>9. Example Code Snippet</h3>
        <pre style="background:#111827; color:#e5e7eb; padding:8px; border-radius:4px; font-size:12px; overflow:auto;">
        void main(void)
        {
            int x = 0;

            if (x == 0)
            {
                x++;
            }
            else
            {
                x--;
            }
        }
        </pre>
        <p>
            Paste this sample into the editor and observe how mAutoFlow renders the branches.
            Try modifying conditions or adding loops to see dynamic updates.
        </p>

        <h3>10. Notes & Limitations</h3>
        <ul>
            <li>mAutoFlow focuses on <strong>control flow</strong>, not a full C compiler.</li>
            <li>Complicated macros or vendor-specific extensions may not be shown perfectly.</li>
            <li>If a function body cannot be detected, mAutoFlow displays an error message.</li>
            <li>Extremely long single-line statements may reduce matching accuracy.</li>
        </ul>

        <h3>11. Branch Shape Options</h3>
        <p>
            mAutoFlow allows customizing how <strong>conditional branches</strong> (<code>if / else-if / switch</code>)
            are displayed in the flowchart.
        </p>

        <ul>
            <li>Open <strong>SETTINGS â†’ Branch Shape</strong></li>
            <li>Choose between:
                <ul>
                    <li><strong>Rounded Rectangle</strong> â€“ default (traditional flowchart style)</li>
                    <li><strong>Diamond</strong> â€“ classic decision symbol</li>
                </ul>
            </li>
            <li>The next time you regenerate the diagram, the new shape will be applied.</li>
        </ul>

        <p style="margin-top:16px; font-size:12px; opacity:0.8;">
            Tip: choose Rounded for compact readability, or Diamond for classic flowchart notation.
        </p>

        <h3>Contact &amp; Feedback</h3>
        <p>
            If you find a bug, have a feature request, or need help using mAutoFlow,
            feel free to contact us:
            <br />
            <strong>Email:</strong>
            <a href="mailto:mautoflow.lab@gmail.com"
               class="help-link">
               mautoflow.lab@gmail.com
            </a>
        </p>
        `;
   
        let isHelpMode = false;

        // í˜„ì¬ ë¡œê·¸ì¸ ìœ ì € ê¸°ì¤€ localStorage í‚¤
        function getUsageStorageKey() {
            if (!window.currentUser || !window.currentUser.id) return null;
            return `autoflow-usage-${window.currentUser.id}`;
        }

        function getUsageCount() {
            const key = getUsageStorageKey();
            if (!key) return 0;
            try {
                const raw = localStorage.getItem(key);
                const n = parseInt(raw, 10);
                return Number.isNaN(n) ? 0 : n;
            } catch (e) {
                return 0;
            }
        }

        function setUsageCount(n) {
            const key = getUsageStorageKey();
            if (!key) return;
            try {
                localStorage.setItem(key, String(n));
            } catch (e) {
                // ì €ì¥ ì‹¤íŒ¨í•˜ë©´ ê·¸ëƒ¥ ë¬´ì‹œ
            }
        }

        function incrementUsageCount() {
            const used = getUsageCount();
            setUsageCount(used + 1);
            updateQuotaInfo();
        }

        function updateQuotaInfo() {
            const span = document.getElementById("quotaInfo");
            if (!span) return;

            if (!window.currentUser) {
                span.textContent = "";
                span.title = "";
                return;
            }

            // í…ŒìŠ¤íŠ¸ ê³„ì •: ìˆ«ì ëŒ€ì‹  ë¬´ì œí•œ ì•ˆë‚´
            if (window.currentUser.email === TEST_EMAIL) {
                span.textContent = "Free tier: unlimited (test account).";
                span.title = "Test account is not subject to daily limits.";
                return;
            }

            // Expert ìœ ì € (plan_name ì— "Expert" ê°€ í¬í•¨ëœ ê²½ìš°)
            if (window.__planTier === "expert") {
                const label = window.__planName
                    ? `Expert (${window.__planName}): unlimited diagrams (â‰¤ ${EXPERT_NODE_LIMIT} nodes).`
                    : `Expert: unlimited diagrams (â‰¤ ${EXPERT_NODE_LIMIT} nodes).`;
                span.textContent = label;
                span.title = `Your subscription is active (Expert plan, up to ${EXPERT_NODE_LIMIT} nodes per diagram).`;
                return;
            }

            // Pro ìœ ì € (ì¼ë°˜ Pro)
            if (window.__isProUser) {
                const label = window.__planName
                    ? `Pro (${window.__planName}): unlimited diagrams (â‰¤ ${PRO_NODE_LIMIT} nodes).`
                    : `Pro: unlimited diagrams (â‰¤ ${PRO_NODE_LIMIT} nodes).`;
                span.textContent = label;
                span.title = `Your subscription is active (Pro plan, up to ${PRO_NODE_LIMIT} nodes per diagram).`;
                return;
            }

            // ì„œë²„ì—ì„œ ì•„ì§ ì•„ë¬´ ì •ë³´ë„ ì•ˆ ë°›ì€ ìƒíƒœ
            if (window.__serverUsageCount == null || window.__dailyFreeLimit == null) {
                span.textContent = `Free tier: 5 diagrams/day, â‰¤ ${FREE_NODE_LIMIT} nodes.`;
                span.title = "Daily limit is enforced on the server.";
                return;
            }

            // ì„œë²„ ê¸°ì¤€ ì‚¬ìš©ëŸ‰ í‘œì‹œ
            const count = window.__serverUsageCount;
            const limit = window.__dailyFreeLimit;

            span.textContent = `Today: ${count} / ${limit} (â‰¤ ${FREE_NODE_LIMIT} nodes)`;
            span.title = "This usage count is returned from the server.";
        }
        
        let currentBranchShape = "rounded";   // ë¶„ê¸° ëª¨ì–‘: ê¸°ë³¸ì€ ë‘¥ê·¼ ì‚¬ê°í˜•
        let savedSourceCode = "";             // HELP ì§„ì… ì „ ì½”ë“œ ì €ì¥ìš©

        function toggleHelp() {
            const codeArea   = document.getElementById("codeArea");
            const codeHeader = document.getElementById("codeHeader");
            const btn        = document.getElementById("helpToggleBtn");

            if (!codeArea || !codeHeader || !btn) return;

            if (!isHelpMode) {
                // === HELP ëª¨ë“œ ì§„ì… ===
                // í˜„ì¬ ì½”ë“œ ì €ì¥
                const srcNow = document.getElementById("src");
                if (srcNow) {
                    savedSourceCode = srcNow.value;
                } else {
                    savedSourceCode = "";
                }

                isHelpMode = true;
                btn.textContent = "CODE";
                btn.classList.add("btn-code-blink");   // ğŸ”¹ CODE ë²„íŠ¼ ê¹œë¹¡ì´ê¸° ON


                codeHeader.innerHTML = "<span>HELP</span>";
                codeArea.innerHTML = `
                    <div id="helpContent" style="padding:10px; color:var(--code-text); font-size:13px; overflow-y:auto;">
                        ${HELP_TEXT_HTML}
                    </div>
                `;
            } else {
                // === CODE ëª¨ë“œ ë³µê·€ ===
                isHelpMode = false;
                btn.textContent = "HELP";
                btn.classList.remove("btn-code-blink");  // ğŸ”¹ ê¹œë¹¡ì„ OFF


                // ì´ì „ì— ê³„ì‚°ëœ ë…¸ë“œ ê°œìˆ˜ê°€ ìˆìœ¼ë©´ ê·¸ëŒ€ë¡œ ë³µì›
                let rightText = "Automatic analysis";
                if (typeof window.__nodeCount === "number" && window.__nodeCount > 0) {
                    rightText = `Nodes: ${window.__nodeCount}`;
                }

                codeHeader.innerHTML = `
                    <span>mAutoFlow</span>
                    <span style="opacity:0.7;">${rightText}</span>
                `;

                // ì—ë””í„° ë‹¤ì‹œ ë§Œë“¤ê¸°
                codeArea.innerHTML = `
                    <textarea id="src" spellcheck="false" placeholder="Paste your C / pseudo-C code here."></textarea>
                `;

                // ì €ì¥í•´ë‘” ì½”ë“œ ë³µì›
                const src = document.getElementById("src");
                if (src) {
                    src.value = savedSourceCode || "";

                    // ê¸°ì¡´ ì´ë²¤íŠ¸ ë‹¤ì‹œ ì—°ê²°
                    ["click", "keyup", "mouseup"].forEach(ev => {
                        src.addEventListener(ev, updateNodeHighlightFromCaret);
                    });
                    src.addEventListener("input", function() {
                        if (typingTimer) clearTimeout(typingTimer);
                        typingTimer = setTimeout(function() {
                            generateFlowchart(true);
                        }, TYPING_DELAY_MS);
                    });
                }
            }
        }

        // ============================
        //  Theme ê´€ë¦¬
        // ============================
        let currentTheme = "classic"; // ê¸°ë³¸
        
        function applyTheme(theme) {
            currentTheme = theme;

            // classic ì€ data-theme ì œê±° (ê¸°ë³¸ ìƒ‰ ì‚¬ìš©)
            if (theme === "classic") {
                document.body.removeAttribute("data-theme");
            } else {
                document.body.setAttribute("data-theme", theme);
            }

            // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì— ì €ì¥
            try {
                localStorage.setItem("autoflow-theme", theme);
            } catch (e) {
                // storage ëª»ì“¸ ë•ŒëŠ” ê·¸ëƒ¥ ë¬´ì‹œ
            }
        }

        function openSettings() {
            const overlay = document.getElementById("settingsOverlay");
            if (!overlay) return;
            overlay.classList.remove("modal-hidden");

            // íŒ¨ë„ì„ í™”ë©´ ì¤‘ì•™ì— ìœ„ì¹˜ì‹œí‚¤ê¸°
            const panel = overlay.querySelector(".modal-panel");
            if (panel) {
                panel.style.position = "fixed";  // ë·°í¬íŠ¸ ê¸°ì¤€
                const rect = panel.getBoundingClientRect();
                const left = (window.innerWidth - rect.width) / 2;
                const top  = (window.innerHeight - rect.height) / 2;
                panel.style.left = `${Math.max(left, 0)}px`;
                panel.style.top  = `${Math.max(top, 0)}px`;
            }
        }

        function closeSettings() {
            const overlay = document.getElementById("settingsOverlay");
            if (!overlay) return;
            overlay.classList.add("modal-hidden");
        }

        // ============================
        //  Download í—¬í¼ë“¤
        // ============================

        // í˜„ì¬ í•¨ìˆ˜ ì´ë¦„ ê¸°ì¤€ìœ¼ë¡œ íŒŒì¼ëª… ë§Œë“¤ê¸°
        function getCurrentFilename(ext) {
            const labelEl = document.getElementById("currentFunc");
            let base = "autoflow_diagram";

            if (labelEl && labelEl.textContent) {
                const txt = labelEl.textContent;

                // "í•¨ìˆ˜: Foo()" ë˜ëŠ” "Function : Foo()" ë‘˜ ë‹¤ ì§€ì›
                const m = txt.match(/(?:í•¨ìˆ˜|Function)\s*:\s*([^(]+)/);
                if (m && m[1]) {
                    base = m[1].trim();
                }
            }
            return base + "." + ext;
        }

        function triggerDownload(url, filename) {
            const a = document.createElement("a");
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }

        // SVG ë‹¤ìš´ë¡œë“œ
        function downloadAsSVG() {
            const svg = document.querySelector("#chartInner svg");
            if (!svg) {
                alert("There is no flowchart to download yet.");
                return;
            }

            const cloned = svg.cloneNode(true);
            cloned.setAttribute("xmlns", "http://www.w3.org/2000/svg");

            const serializer = new XMLSerializer();
            const source = serializer.serializeToString(cloned);
            const blob = new Blob([source], { type: "image/svg+xml;charset=utf-8" });
            const url = URL.createObjectURL(blob);

            triggerDownload(url, getCurrentFilename("svg"));
            setTimeout(() => URL.revokeObjectURL(url), 1000);
        }

        // ë‹¤ìš´ë¡œë“œ íƒ€ì…ì— ë”°ë¼ ë¶„ê¸°
        function downloadDiagram() {
            downloadAsSVG();
        }

        let typingTimer = null;
        const TYPING_DELAY_MS = 600;

        // ë‹¤ì´ì–´ê·¸ë¨ ì¤Œ ìƒíƒœ (ë‚´ìš©ë§Œ í™•ëŒ€, ë ˆì´ì•„ì›ƒì€ ê·¸ëŒ€ë¡œ)
        let diagramZoom = 1.0;

        function clampZoom(z) {
            if (z < 0.5) return 0.5;   // 50%
            if (z > 7.0) return 7.0;   // 700%
            return z;
        }
        function updateZoomLabel() {
            const label = document.getElementById("zoomLabel");
            label.textContent = Math.round(diagramZoom * 100) + "%";
        }

        // ê³µí†µ ì ìš© í•¨ìˆ˜
        function applyDiagramZoom() {
            const svg = document.querySelector("#chartInner svg");
            if (!svg) return;

            // ë‹¤ì´ì–´ê·¸ë¨ì˜ ê¸°ì¤€ í¬ê¸°(100%)ë¥¼ ê¸°ì¤€ìœ¼ë¡œ í™•ëŒ€/ì¶•ì†Œ
            const percent = diagramZoom * 100;
            svg.style.width = percent + "%";
            svg.style.height = "auto";
        }

        // í”Œë¡œìš°ì°¨íŠ¸ ì»¨í…Œì´ë„ˆ ì•ˆì—ì„œ ë…¸ë“œë¥¼ í™”ë©´ ê°€ìš´ë°ë¡œ ìŠ¤í¬ë¡¤
        function scrollNodeIntoCenter(node) {
            const container = document.getElementById("chartContainer");
            if (!node || !container) return;

            try {
                // ì‹¤ì œ í™”ë©´ ì¢Œí‘œ(ì¤Œ, ìŠ¤í¬ë¡¤ ëª¨ë‘ ë°˜ì˜ëœ ìƒíƒœ)
                const nodeRect = node.getBoundingClientRect();
                const contRect = container.getBoundingClientRect();

                const nodeCenterX = nodeRect.left + nodeRect.width  / 2;
                const nodeCenterY = nodeRect.top  + nodeRect.height / 2;
                const contCenterX = contRect.left + contRect.width  / 2;
                const contCenterY = contRect.top  + contRect.height / 2;

                // ì»¨í…Œì´ë„ˆì˜ í˜„ì¬ ìŠ¤í¬ë¡¤ ê¸°ì¤€ìœ¼ë¡œ, ì¤‘ì‹¬ ì°¨ì´ë§Œí¼ ë”í•´ì¤Œ
                container.scrollLeft += (nodeCenterX - contCenterX);
                container.scrollTop  += (nodeCenterY - contCenterY);
            } catch (e) {
                // getBoundingClientRect ì‹¤íŒ¨í•˜ë©´ ê·¸ëƒ¥ ë¬´ì‹œ
                console.warn("scrollNodeIntoCenter error:", e);
            }
        }
        
        function zoomChange(delta) {
            diagramZoom = clampZoom(diagramZoom + delta);
            applyDiagramZoom();       // â† zoom ì ìš©
            updateZoomLabel();
        }
        function zoomReset() {
            diagramZoom = 1.0;
            applyDiagramZoom();       // â† 100%ë¡œ
            updateZoomLabel();
        }

        // ============================
        //  Status / Error helpers
        // ============================
        function setStatus(type, message) {
            const status = document.getElementById("status");
            if (!status) return;

            // type: "success" | "error" | "info" | "idle"
            let icon = "";
            if (type === "success") icon = "âœ…";
            else if (type === "error") icon = "âŒ";
            else if (type === "info") icon = "â„¹ï¸";

            status.className = "";  // ê¸°ì¡´ í´ë˜ìŠ¤ ì œê±°
            if (type === "success") status.classList.add("success");
            if (type === "error")   status.classList.add("error");

            status.textContent = icon ? `${icon} ${message}` : message;
        }

        async function fetchBackendVersion() {
            const el = document.getElementById("backendVersion");
            if (!el) return;

            try {
                const res = await fetch(API_BASE + "/version");
                if (!res.ok) {
                    throw new Error("HTTP " + res.status);
                }
                const data = await res.json();

                const ver = data.version || "unknown";
                const daily = data.daily_free_limit ?? DAILY_FREE_LIMIT;
                const nodeLimit = data.free_node_limit ?? FREE_NODE_LIMIT;

                el.textContent = `Backend: ${ver}`;
                el.title = `Daily limit: ${daily} diagrams/day, â‰¤ ${nodeLimit} nodes`;
            } catch (e) {
                console.warn("Failed to fetch backend version:", e);
                // ì‹¤íŒ¨í•´ë„ UI ê¹¨ì§€ì§„ ì•Šê²Œ ê·¸ëƒ¥ ë¬´ì‹œ
            }
        }         

        // ë°±ì—”ë“œì—ì„œ ë‚´ë ¤ì˜¤ëŠ” ì—ëŸ¬ ì½”ë“œë¥¼ ë³´ê¸° ì¢‹ê²Œ ë§¤í•‘
        function mapBackendError(errorCode, rawError) {
            const msg  = (rawError || "").toString();
            const code = (errorCode || "").toString().toUpperCase();

            // 1) ëª…ì‹œì  ì½”ë“œ ìš°ì„ 
            if (code === "NO_FUNCTION") {
                return "No function body was found in the code.";
            }
            if (code === "TOO_MANY_NODES") {
                return "The function is too large to analyze (too many flowchart nodes).";
            }
            if (code === "UNSUPPORTED_SYNTAX") {
                return "The code uses syntax that is not supported yet (for example, 'goto' inside 'switch').";
            }

            // 2) ì½”ë“œê°€ ì—†ìœ¼ë©´ ë©”ì‹œì§€ íŒ¨í„´ìœ¼ë¡œ ì¶”ë¡ 
            if (/no function/i.test(msg)) {
                return "No function body was found in the code.";
            }
            if (/too many nodes/i.test(msg)) {
                return "The function is too large to analyze (too many flowchart nodes).";
            }
            if (/unsupported/i.test(msg)) {
                return "The code uses syntax that is not supported yet.";
            }

            // 3) ì¼ë‹¨ ì•Œ ìˆ˜ ì—†ëŠ” ì—ëŸ¬ëŠ” ì›ë¬¸ì„ ê´„í˜¸ë¡œ ë‚¨ê²¨ì¤Œ
            if (msg) {
                return `Failed to generate the flowchart. (${msg})`;
            }
            return "Failed to generate the flowchart due to an unknown error.";
        }


        // ============================
        //  ì½”ë“œ ë¼ì¸ í•˜ì´ë¼ì´íŠ¸ ê´€ë ¨ í•¨ìˆ˜ë“¤
        // ============================

        // ë§¤ì¹­ìš© ë¬¸ìì—´ ì •ê·œí™” (ê³µë°±/ê´„í˜¸/ì„¸ë¯¸ì½œë¡  ë“± ì •ë¦¬)
        function normalizeForMatch(s) {
            if (!s) return "";
            return String(s)
                .toLowerCase()
                .replace(/["']/g, "")       // ë”°ì˜´í‘œ ì œê±°
                .replace(/[{};]/g, "")      // ì¤‘ê´„í˜¸/ì„¸ë¯¸ì½œë¡  ì œê±°
                .replace(/\s+/g, " ")       // ì—¬ëŸ¬ ê³µë°± -> í•œ ì¹¸
                .trim();
        }

        // ============================
        //  ì½”ë“œ ë¼ì¸ â†’ ë…¸ë“œ í•˜ì´ë¼ì´íŠ¸
        // ============================

        // ì„ íƒëœ ë…¸ë“œ í•˜ì´ë¼ì´íŠ¸ í•´ì œ
        function clearNodeHighlight() {
            const svg = document.querySelector("#chartInner svg");
            if (!svg) return;
            svg.querySelectorAll(".node.autoflow-selected").forEach(n => {
                n.classList.remove("autoflow-selected");
            });
        }

        // ë…¸ë“œ ë¼ë²¨ì—ì„œ "í•µì‹¬ í•œ ì¤„"ë§Œ ë½‘ê¸° (if ì¤„ + ëŒ€ì…ë¬¸ ê°™ì´ ìˆì„ ë•Œ ëŒ€ë¹„)
        function getNodeLabelCore(node) {
            const rawText = (node.textContent || "").trim();
            if (!rawText) return "";

            if (rawText.indexOf("\n") !== -1) {
                const parts = rawText.split(/\n/).map(p => p.trim()).filter(Boolean);
                if (parts.length > 0) {
                    // ê°€ì¥ ì§§ì€ í•œ ì¤„ì„ ëŒ€í‘œ ë¼ë²¨ë¡œ ì‚¬ìš©
                    return parts.reduce((a, b) => (a.length <= b.length ? a : b));
                }
            }
            return rawText;
        }

        // í˜„ì¬ ì¤„ê³¼ ë…¸ë“œ ë¼ë²¨ì˜ ë§¤ì¹­ ì ìˆ˜ ê³„ì‚°
        function calcMatchScore(normLine, normLabel) {
            if (!normLine || !normLabel) return 0;

            if (normLine === normLabel) return 3.0;  // ì™„ì „ ì¼ì¹˜ ìµœìš°ì„ 

            if (normLine.indexOf(normLabel) !== -1) {
                // ë¼ë²¨ì´ ì¤„ ì•ˆì— í¬í•¨
                return normLabel.length / Math.max(1, normLine.length);
            }
            if (normLabel.indexOf(normLine) !== -1) {
                // ì¤„ì´ ë¼ë²¨ ì•ˆì— í¬í•¨
                return normLine.length / Math.max(1, normLabel.length);
            }
            return 0;
        }

        // íŠ¹ì • ë¼ì¸ ë²ˆí˜¸ì— ë§¤í•‘ëœ "ê°€ì¥ ì˜ ë§ëŠ”" ë…¸ë“œë¥¼ ì°¾ì•„ í•˜ì´ë¼ì´íŠ¸ + ìŠ¤í¬ë¡¤
        function highlightNodesForLine(lineIdx) {
            const svg = document.querySelector("#chartInner svg");
            if (!svg) return;

            const textarea = document.getElementById("src");
            if (!textarea) return;

            const code = textarea.value || "";
            const lines = code.split("\n");
            if (!lines.length) return;

            // ë¼ì¸ ì¸ë±ìŠ¤ ë³´ì •
            let idx = lineIdx;
            if (idx < 0) idx = 0;
            if (idx >= lines.length) idx = lines.length - 1;

            const normLine = normalizeForMatch(lines[idx]);
            if (!normLine) {
                clearNodeHighlight();
                return;
            }

            const nodeLines = window.__nodeLines || {};

            clearNodeHighlight();

            const nodes = svg.querySelectorAll(".node");
            const container = document.getElementById("chartContainer");

            let bestNode = null;
            let bestScore = 0;
            let bestDist = Infinity;

            nodes.forEach(node => {
                const rawId = node.getAttribute("id") || "";
                const m = rawId.match(/(?:flowchart-)?(N\d+)/);
                if (!m) return;
                const nodeKey = m[1];   // N1, N2 ...

                const mappedLine = nodeLines[nodeKey];

                const coreLabel = getNodeLabelCore(node);
                const normLabel = normalizeForMatch(coreLabel);
                if (!normLabel) return;

                const score = calcMatchScore(normLine, normLabel);
                if (score <= 0) return;   // ì „í˜€ ì•ˆ ë§ìœ¼ë©´ í›„ë³´ ì œì™¸

                // body_start_line í•œ ì¹¸ ì˜¤ì°¨ ê°™ì€ ê²½ìš°ë¥¼ ìœ„í•´ "ë¼ì¸ ê±°ë¦¬"ë„ ê°™ì´ ê³ ë ¤
                const dist = (typeof mappedLine === "number")
                    ? Math.abs(mappedLine - idx)
                    : Infinity;

                if (
                    score > bestScore ||
                    (score === bestScore && dist < bestDist)
                ) {
                    bestScore = score;
                    bestDist = dist;
                    bestNode = node;
                }
            });

            if (!bestNode) return;

            bestNode.classList.add("autoflow-selected");

            // ì¤Œ ìƒíƒœì™€ ìƒê´€ì—†ì´, í•­ìƒ í™”ë©´ ì¤‘ì•™ìœ¼ë¡œ ê°€ì ¸ì˜¤ê¸°
            scrollNodeIntoCenter(bestNode);
        }

        // í…ìŠ¤íŠ¸ ì»¤ì„œ ìœ„ì¹˜ ê¸°ì¤€ìœ¼ë¡œ í˜„ì¬ ë¼ì¸ ê³„ì‚° â†’ ë…¸ë“œ í•˜ì´ë¼ì´íŠ¸
        function updateNodeHighlightFromCaret() {
            const textarea = document.getElementById("src");
            if (!textarea) return;

            const pos = textarea.selectionStart || 0;
            const textBefore = textarea.value.slice(0, pos);
            const lineIdx = textBefore.split("\n").length - 1;

            highlightNodesForLine(lineIdx);
        }

        // lineIdx ì— í•´ë‹¹í•˜ëŠ” ì¤„ì„ ê·¸ëŒ€ë¡œ í•˜ì´ë¼ì´íŠ¸ (fallback ìš©)
        function highlightCodeAtLine(lineIdx) {
            const textarea = document.getElementById("src");
            if (!textarea) return -1;

            const code  = textarea.value;
            const lines = code.split("\n");
            if (!lines.length) return -1;

            // ì¸ë±ìŠ¤ ë³´ì •
            let idx = lineIdx;
            if (idx < 0) idx = 0;
            if (idx >= lines.length) idx = lines.length - 1;

            // ì„ íƒ ë²”ìœ„ ê³„ì‚°
            let start = 0;
            for (let i = 0; i < idx; i++) {
                start += lines[i].length + 1; // '\n'
            }
            const end = start + lines[idx].length;

            textarea.focus();
            textarea.setSelectionRange(start, end);

            // ê°€ìš´ë° ì¯¤ìœ¼ë¡œ ìŠ¤í¬ë¡¤
            const ratio        = idx / Math.max(1, lines.length - 1);
            const targetScroll = textarea.scrollHeight * ratio - textarea.clientHeight / 2;
            textarea.scrollTop = Math.max(0, targetScroll);

            return idx;
        }


        // ë…¸ë“œ ë¼ë²¨ + (ì„ íƒ) ëŒ€ëµ ë¼ì¸ ìœ„ì¹˜ íŒíŠ¸ë¡œ ì½”ë“œ ë¼ì¸ í•˜ì´ë¼ì´íŠ¸
        // -> ì°¾ì€ ë¼ì¸ ì¸ë±ìŠ¤ë¥¼ ë°˜í™˜ (ì—†ìœ¼ë©´ -1)
        function highlightCodeForLabel(rawLabel, approxLineHint) {
            const textarea = document.getElementById("src");
            if (!textarea) return -1;

            const code = textarea.value;
            if (!code) return -1;

            const lines = code.split("\n");

            // Mermaidê°€ í•œ ë…¸ë“œì— ì—¬ëŸ¬ ì¤„ í…ìŠ¤íŠ¸ë¥¼ ë„£ëŠ” ê²½ìš° ëŒ€ë¹„:
            //    - if ì¤„ + ëŒ€ì…ë¬¸ì´ ê°™ì´ ë“¤ì–´ì˜¤ë©´, ë³´í†µ "ëŒ€ì…ë¬¸"ì´ ë” ì§§ìŒ
            //    - ê·¸ë˜ì„œ ì¤„ë°”ê¿ˆ ê¸°ì¤€ìœ¼ë¡œ ë‚˜ëˆ ì„œ "ê°€ì¥ ì§§ì€ í•œ ì¤„"ë§Œ ì„ íƒ
            let core = rawLabel || "";
            if (core.indexOf("\n") !== -1) {
                const parts = core.split(/\n/).map(p => p.trim()).filter(Boolean);
                if (parts.length > 0) {
                    core = parts.reduce((a, b) => (a.length <= b.length ? a : b));
                }
            }

            let label = normalizeForMatch(core);
            if (!label) return -1;

            // ë„ˆë¬´ ê¸¸ë©´ ì• ë¶€ë¶„ë§Œ ì‚¬ìš© (ë§¤ì¹­ìš©)
            if (label.length > 120) {
                label = label.slice(0, 120);
            }

            // 1) ì •í™•íˆ ê°™ì€ ì¤„(eqCandidates)ê³¼
            // 2) ë¶€ë¶„ ì¼ì¹˜(subCandidates)ë¥¼ ë”°ë¡œ ëª¨ì€ë‹¤.
            const eqCandidates = [];
            const subCandidates = [];

            for (let i = 0; i < lines.length; i++) {
                const normLine = normalizeForMatch(lines[i]);
                if (!normLine) continue;

                if (normLine === label) {
                    // ğŸ”¹ ì™„ì „ ì¼ì¹˜ ë¼ì¸
                    eqCandidates.push(i);
                } else {
                    // ğŸ”¹ ë¶€ë¶„ ì¼ì¹˜ (ì´ê±´ ì •í™• ì¼ì¹˜ê°€ í•˜ë‚˜ë„ ì—†ì„ ë•Œë§Œ ì‚¬ìš©í•  ì˜ˆì •)
                    if (
                        normLine.indexOf(label) !== -1 ||      // ë¼ì¸ ì•ˆì— ë¼ë²¨ ë¬¸ìì—´ í¬í•¨
                        (label.indexOf(normLine) !== -1 && normLine.length > 5)
                    ) {
                        subCandidates.push(i);
                    }
                }
            }

            let bestLine = -1;
            let candidates = [];

            // 1ìˆœìœ„: "ì •í™• ì¼ì¹˜" í›„ë³´ê°€ ìˆìœ¼ë©´ ê·¸ê²ƒë§Œ ì‚¬ìš©
            if (eqCandidates.length > 0) {
                candidates = eqCandidates;
            }
            // 2ìˆœìœ„: ì •í™• ì¼ì¹˜ê°€ í•˜ë‚˜ë„ ì—†ì„ ë•Œë§Œ ë¶€ë¶„ ì¼ì¹˜ ì‚¬ìš©
            else if (subCandidates.length > 0) {
                candidates = subCandidates;
            }

            if (candidates.length > 0) {
                // 2) ë…¸ë“œ Yì¢Œí‘œë¡œë¶€í„° ì¶”ì •í•œ ë¼ì¸ ê°€ê¹Œìš´ ê²ƒ ìš°ì„  ì„ íƒ
                if (typeof approxLineHint === "number" && !Number.isNaN(approxLineHint)) {
                    let minDist = Infinity;
                    candidates.forEach(idx => {
                        const d = Math.abs(idx - approxLineHint);
                        if (d < minDist) {
                            minDist = d;
                            bestLine = idx;
                        }
                    });
                } else {
                    // íŒíŠ¸ ì—†ìœ¼ë©´ ì²« ë²ˆì§¸ í›„ë³´ ì‚¬ìš©
                    bestLine = candidates[0];
                }
            } else {
                // 3) ê·¸ë˜ë„ ëª» ì°¾ìœ¼ë©´, ë¼ì¸ë³„ ìœ ì‚¬ë„ ê¸°ë°˜ìœ¼ë¡œ "ê°€ì¥ ë¹„ìŠ·í•œ" í•œ ì¤„ì„ ì°¾ëŠ”ë‹¤.
                let bestScore = 0;
                let bestIdx = -1;

                for (let i = 0; i < lines.length; i++) {
                    const normLine = normalizeForMatch(lines[i]);
                    if (!normLine) continue;

                    const lenLine = normLine.length;
                    const lenLabel = label.length;
                    let score = 0;

                    if (normLine === label) {
                        score = 1.0;
                    } else if (normLine.indexOf(label) !== -1) {
                        // label ì´ ë¼ì¸ ì•ˆì— í¬í•¨
                        score = label.length / lenLine;
                    } else if (label.indexOf(normLine) !== -1) {
                        // ë°˜ëŒ€ë¡œ ë¼ì¸ì´ label ì•ˆì— í¬í•¨
                        score = lenLine / lenLabel;
                    } else {
                        continue;
                    }

                    if (score > bestScore) {
                        bestScore = score;
                        bestIdx = i;
                    }
                }

                if (bestScore > 0) {
                    bestLine = bestIdx;
                }
            }

            if (bestLine < 0 || bestLine >= lines.length) return -1;

            // ì„ íƒí•  ë¬¸ìì—´ì˜ ì‹œì‘/ë ì¸ë±ìŠ¤ ê³„ì‚°
            let start = 0;
            for (let i = 0; i < bestLine; i++) {
                start += lines[i].length + 1; // '\n' í¬í•¨
            }
            const end = start + lines[bestLine].length;

            // í…ìŠ¤íŠ¸ ì˜ì—­ì— ì„ íƒ/í¬ì»¤ìŠ¤
            textarea.focus();
            textarea.setSelectionRange(start, end);

            // ëŒ€ëµì ì¸ ìŠ¤í¬ë¡¤ ìœ„ì¹˜ ì¡°ì •
            const totalLines = lines.length;
            const ratio = bestLine / Math.max(1, totalLines - 1);
            const targetScroll = textarea.scrollHeight * ratio - textarea.clientHeight / 2;
            textarea.scrollTop = Math.max(0, targetScroll);

            return bestLine;
        }

        // Mermaid ë…¸ë“œì— í´ë¦­ í•¸ë“¤ëŸ¬ ì—°ê²°
        function attachNodeClickHandlers() {
            const svg = document.querySelector("#chartInner svg");
            if (!svg) return;

            const nodeLines = window.__nodeLines || {};
            const textarea = document.getElementById("src");

            const nodes = svg.querySelectorAll(".node");
            nodes.forEach(node => {
                node.style.cursor = "pointer";
                node.addEventListener("click", () => {
                    if (!textarea) return;

                    // ì„ íƒëœ ë…¸ë“œ í•˜ì´ë¼ì´íŠ¸
                    clearNodeHighlight();
                    node.classList.add("autoflow-selected");
                    scrollNodeIntoCenter(node);

                    // node id -> N1, N2 ...
                    const rawId = node.getAttribute("id") || "";
                    let nodeKey = rawId;
                    const m = rawId.match(/(?:flowchart-)?(N\d+)/);
                    if (m) {
                        nodeKey = m[1];
                    }

                    // ë…¸ë“œ ë¼ë²¨ í…ìŠ¤íŠ¸
                    const rawText = node.textContent || "";
                    let label = rawText.replace(/\s+/g, " ").trim();
                    if (!label) return;

                    const lower = label.toLowerCase();
                    if (lower === "merge") return;
                    if (lower.startsWith("start")) return;
                    if (lower.startsWith("end")) return;

                    // node_linesì—ì„œ ì˜¨ ë¼ì¸ ë²ˆí˜¸ëŠ” "íŒíŠ¸"ë¡œë§Œ ì‚¬ìš©
                    const mapped = nodeLines[nodeKey];
                    const approxHint =
                        (typeof mapped === "number") ? mapped : null;

                    // 1ì°¨: í•­ìƒ ë¬¸ìì—´ ê¸°ë°˜ ë§¤ì¹­ ì‚¬ìš©
                    let bestLine = highlightCodeForLabel(label, approxHint);

                    // 2ì°¨: í…ìŠ¤íŠ¸ ë§¤ì¹­ì´ ì™„ì „íˆ ì‹¤íŒ¨í•œ ê²½ìš°ì—ë§Œ
                    //      node_lines ë¼ì¸ ë²ˆí˜¸ ê·¸ëŒ€ë¡œ ì‚¬ìš© (fallback)
                    if (bestLine < 0 && typeof mapped === "number") {
                        bestLine = highlightCodeAtLine(mapped);
                    }

                    // bestLine ì€ highlightCodeForLabel / highlightCodeAtLine ì•ˆì—ì„œ
                    // ì´ë¯¸ selection + scroll ì„ ì²˜ë¦¬í•˜ë¯€ë¡œ ì—¬ê¸°ì„œ ë”°ë¡œ í•  ì¼ì€ ì—†ìŒ
                });
            });
        }

        async function generateFlowchart(auto = false) {
            const status      = document.getElementById("status");
            const chartInner  = document.getElementById("chartInner");
            const currentFunc = document.getElementById("currentFunc");

            // ë¡œê·¸ì¸ ìƒíƒœ í™•ì¸
            if (!window.currentUser) {
                setStatus("error", "Please log in to use mAutoFlow.");
                return;
            }

            // í…ŒìŠ¤íŠ¸ ê³„ì • ì—¬ë¶€
            const isTestUser = (window.currentUser.email === TEST_EMAIL);

            const srcEl = document.getElementById("src");
            const src = srcEl ? srcEl.value.trim() : "";
            if (!src) {
                if (!auto) {
                    setStatus("info", "Enter your C code on the left to generate a flowchart.");
                } else {
                    setStatus("idle", "");
                }
                currentFunc.textContent = "";
                chartInner.innerHTML = `
                    <p class="placeholder">
                        When you enter C code on the left, a flowchart is automatically generated on the right.
                    </p>`;
                return;
            }

            diagramZoom = 1.0;
            updateZoomLabel();

            setStatus("info", auto ? "Automatically updating the flowchart..." : "Creating the flowchart...");
            chartInner.innerHTML = "";

            const formData = new FormData();
            formData.append("source_code", src);
            formData.append("branch_shape", currentBranchShape);
            formData.append("func_name_style", funcNameStyle);

            try {
                // â‘  Supabaseì—ì„œ access_token ê°€ì ¸ì˜¤ê¸°
                let accessToken = null;
                try {
                    const { data, error } = await supabase.auth.getUser();
                    // data.user ê°€ ìˆê³  session ì´ ìˆìœ¼ë©´ í† í° ì½ê¸°
                    const session = supabase.auth.getSession
                        ? (await supabase.auth.getSession()).data.session
                        : null;

                    if (session?.access_token) {
                        accessToken = session.access_token;
                    }
                } catch (e) {
                    console.warn("Failed to get Supabase user/session", e);
                }


                // ì—¬ê¸°ì„œ FormData ì— access_token í•„ë“œë¥¼ ë„£ì–´ì¤€ë‹¤
                if (accessToken) {
                    console.log(
                        "accessToken from Supabase:",
                        accessToken.slice(0, 20) + "..."   // ì• 20ê¸€ìë§Œ ì°ì–´ì„œ ê¸¸ì´ í™•ì¸
                    );
                    formData.append("access_token", accessToken);
                    // ì¶”ê°€: user_id / user_email
                    if (window.currentUser) {
                        formData.append("user_id", window.currentUser.id);
                        formData.append("user_email", window.currentUser.email || "");
                    }
                } else {
                    setStatus("error", "Login session not found. Please log in again.");
                    return;
                }

                const res = await fetch(API_BASE + "/api/convert_text", {
                    method: "POST",
                    body: formData
                });

                if (!res.ok) {
                    let data = {};
                    try {
                        data = await res.json();
                    } catch (_) {}

                    // 429: í•˜ë£¨ ë¬´ë£Œ ì‚¬ìš©ëŸ‰ ì´ˆê³¼
                    if (res.status === 429) {
                        let detail = data.detail;

                        // detail ì´ ë¬¸ìì—´ì´ë“  ê°ì²´ë“  ëª¨ë‘ ì²˜ë¦¬
                        let code = null;
                        let usageFromServer = null;
                        let limitFromServer = null;

                        if (typeof detail === "string") {
                            code = detail;
                        } else if (detail && typeof detail === "object") {
                            code = detail.code || detail.detail || "";
                            if (typeof detail.usage_count === "number") {
                                usageFromServer = detail.usage_count;
                            }
                            if (typeof detail.daily_free_limit === "number") {
                                limitFromServer = detail.daily_free_limit;
                            }
                        }

                        code = (code || "").toString().toUpperCase();

                        if (code === "DAILY_LIMIT_EXCEEDED") {
                            if (!isTestUser) {
                                if (usageFromServer != null) {
                                    window.__serverUsageCount = usageFromServer;
                                }
                                if (limitFromServer != null) {
                                    window.__dailyFreeLimit = limitFromServer;
                                }
                                updateQuotaInfo();
                            }

                            setStatus(
                                "error",
                                `Daily free limit reached (${window.__dailyFreeLimit ?? DAILY_FREE_LIMIT} diagrams per day, up to ${FREE_NODE_LIMIT} nodes). Please try again tomorrow.`
                            );
                            chartInner.innerHTML = `
                                <p class="placeholder" style="color:#b91c1c;">
                                    Daily free limit reached. Please try again tomorrow.
                                </p>`;
                            currentFunc.textContent = "";
                            return;
                        }
                    }

                    // ğŸ“Œ ë…¸ë“œ ì´ˆê³¼ ì—ëŸ¬ (400) í¬í•¨í•œ ë‚˜ë¨¸ì§€ ì—ëŸ¬ ì²˜ë¦¬
                    const errorCode = (data.error_code || data.error || "").toString().toUpperCase();
                    if (errorCode === "TOO_MANY_NODES") {
                        const uiMsg = mapBackendError(errorCode, data.error);
                        setStatus("error", uiMsg);
                        chartInner.innerHTML = `
                            <p class="placeholder" style="color:#b91c1c;">
                                ${uiMsg}
                            </p>`;
                        currentFunc.textContent = "";

                        // ğŸ”¹ ë¬´ë£Œ ìœ ì €ë¼ë©´ ì—¬ê¸°ì„œë„ UPGRADE ë²„íŠ¼ ë¸”ë§í¬
                        const isTestUser = (window.currentUser?.email === TEST_EMAIL);
                        if (!isTestUser && !window.__isProUser) {
                            const ub = document.getElementById("upgradeButton");
                            if (ub) ub.classList.add("upgrade-blink");
                        }

                        return;
                    }

                    // ê·¸ ì™¸ ì¼ë°˜ ì„œë²„ ì—ëŸ¬
                    setStatus("error", `Server error (${res.status}). Please try again later.`);
                    chartInner.innerHTML = '<p class="placeholder">A server error occurred.</p>';
                    currentFunc.textContent = "";
                    return;
                }
                
                const data = await res.json();
                const mermaidCode   = data.mermaid || "";
                const errorMsg      = data.error || "";
                const errorCode     = data.error_code || "";
                const funcName      = data.func_name || "";
                const fullSignature = data.full_signature || "";
                const nodeLines     = data.node_lines || {};

                // ë°±ì—”ë“œì—ì„œ ì˜¨ ê³„ì • ìƒíƒœ ë°˜ì˜
                window.__isProUser      = !!data.is_pro_user;          // Pro + Expert ëª¨ë‘ true
                window.__planName       = data.plan_name || null;
                window.__isTestAccount  = !!data.is_test_account;
                window.__planTier       = data.plan_tier || null;      // "free" | "pro" | "expert"
                window.__nodeLimitFromServer = data.node_limit ?? null;

                // í”Œëœë³„ ë…¸ë“œ ì œí•œ (í´ë¼ì´ì–¸íŠ¸ ê¸°ì¤€)
                // - í…ŒìŠ¤íŠ¸ ê³„ì •: ì‚¬ì‹¤ìƒ ë¬´ì œí•œ
                let effectiveNodeLimit = FREE_NODE_LIMIT;
                if (window.__isTestAccount) {
                    effectiveNodeLimit = Infinity;              // test account: no limit
                } else if (window.__planTier === "expert") {
                    effectiveNodeLimit = EXPERT_NODE_LIMIT;
                } else if (window.__isProUser) {
                    effectiveNodeLimit = PRO_NODE_LIMIT;
                } else {
                    effectiveNodeLimit = FREE_NODE_LIMIT;
                }

                // ì„œë²„ì—ì„œ node_limit ë¥¼ ë³´ë‚´ì£¼ë©´ ê·¸ ê°’ ìš°ì„  ì‚¬ìš©
                if (typeof data.node_limit === "number") {
                    effectiveNodeLimit = data.node_limit;
                }
                window.__nodeLimit = effectiveNodeLimit;

                // UPGRADE ë²„íŠ¼ í‘œì‹œ/ìˆ¨ê¹€
                const upgradeBtn = document.getElementById("upgradeButton");
                if (upgradeBtn) {
                    // ìœ ë£Œ(Pro/Expert) ë˜ëŠ” í…ŒìŠ¤íŠ¸ ê³„ì •ì´ë©´ UPGRADE ìˆ¨ê¹€
                    upgradeBtn.style.display =
                        (window.__isProUser || window.__isTestAccount)
                            ? "none"
                            : "inline-flex";
                }

                // ì„œë²„ì—ì„œ ë‚´ë ¤ì¤€ ì‚¬ìš©ëŸ‰ ì •ë³´ (ì¼ë°˜ ê³„ì •ì¸ ê²½ìš°)
                if (!isTestUser && typeof data.usage_count === "number") {
                    window.__serverUsageCount = data.usage_count;
                }
                if (!isTestUser && typeof data.daily_free_limit === "number") {
                    window.__dailyFreeLimit = data.daily_free_limit;
                }

                if (errorMsg) {
                    const uiMsg = mapBackendError(errorCode, errorMsg);
                    setStatus("error", uiMsg);
                    chartInner.innerHTML = `<p class="placeholder" style="color:#b91c1c;">${uiMsg}</p>`;
                    currentFunc.textContent = "";
                    return;
                }

                const nodeCount = Object.keys(nodeLines).length;
                window.__nodeCount = nodeCount;
                window.__nodeLines = nodeLines;

                const codeHeader = document.getElementById("codeHeader");
                if (codeHeader) {
                    codeHeader.innerHTML = `
                        <span>mAutoFlow</span>
                        <span style="opacity:0.7;">Nodes: ${nodeCount}</span>`;
                }

                // ë…¸ë“œ ì œí•œ (í…ŒìŠ¤íŠ¸ ê³„ì •ì€ ë¬´ì œí•œ)
                // - Free   : ìµœëŒ€ FREE_NODE_LIMIT
                // - Pro    : ìµœëŒ€ PRO_NODE_LIMIT
                // - Expert : ìµœëŒ€ EXPERT_NODE_LIMIT
                if (!isTestUser) {
                    const tier = window.__planTier;

                    // ì„œë²„ê°€ node_limit ë¥¼ ë‚´ë ¤ì£¼ë©´ ê·¸ ê°’ì„ ìš°ì„  ì‚¬ìš©
                    let nodeLimit = window.__nodeLimit;
                    if (!Number.isFinite(nodeLimit)) {
                        if (window.__isTestAccount) {
                            nodeLimit = Infinity;                // í…ŒìŠ¤íŠ¸ ê³„ì • ë¬´ì œí•œ
                        } else if (tier === "expert") {
                            nodeLimit = EXPERT_NODE_LIMIT;
                        } else if (window.__isProUser) {
                            nodeLimit = PRO_NODE_LIMIT;
                        } else {
                            nodeLimit = FREE_NODE_LIMIT;
                        }
                    }

                    // nodeLimit ì´ ìœ í•œí•œ ê°’ì¼ ë•Œë§Œ ì´ˆê³¼ ì²´í¬
                    if (Number.isFinite(nodeLimit) && nodeCount > nodeLimit) {
                        let msgText = "";
                        let bannerText = "";

                        if (tier === "expert") {
                            // Expert ìœ ì €
                            msgText = `This function has ${nodeCount} nodes. The Expert plan supports up to ${nodeLimit} nodes per diagram.`;
                            bannerText = `Expert plan supports up to ${nodeLimit} nodes per diagram.`;
                        } else if (window.__isProUser) {
                            // Pro ìœ ì €
                            msgText = `This function has ${nodeCount} nodes. The Pro plan supports up to ${nodeLimit} nodes per diagram.`;
                            bannerText = `Pro plan supports up to ${nodeLimit} nodes per diagram.`;
                        } else {
                            // Free ìœ ì €
                            msgText = `This function has ${nodeCount} nodes. The free tier supports up to ${nodeLimit} nodes per diagram.`;
                            bannerText = `Free tier supports up to ${nodeLimit} nodes per diagram.`;
                        }

                        setStatus("error", msgText);
                        chartInner.innerHTML = `
                            <p class="placeholder" style="color:#b91c1c;">
                                ${bannerText}
                            </p>`;
                        currentFunc.textContent = "";

                        // ğŸ”¸ UPGRADE ë²„íŠ¼ íŒŒìŠ¤í…” ì—°ë‘ìƒ‰ ë¸”ë§í¬: "ë¬´ë£Œ ê³„ì •"ì—ì„œë§Œ ì¼œê¸°
                        const ub = document.getElementById("upgradeButton");
                        if (ub && !window.__isProUser && tier !== "expert" && !window.__isTestAccount) {
                            ub.classList.add("upgrade-blink");
                        }

                        return;
                    }
                }
                
                // ì •ìƒ í”Œë¡œìš°ì°¨íŠ¸ ìƒì„±
                chartInner.innerHTML = `<div class="mermaid">${mermaidCode}</div>`;
                mermaid.init(undefined, chartInner.querySelector(".mermaid"));
                applyDiagramZoom();
                setTimeout(attachNodeClickHandlers, 50);

                // ì‚¬ìš©ëŸ‰ ì¦ê°€ (í´ë¼ì´ì–¸íŠ¸ ê¸°ì¤€, í…ŒìŠ¤íŠ¸ ê³„ì • ì œì™¸)
                if (!isTestUser) {
                    // ê°™ì€ ì½”ë“œì¸ì§€ ë¹„êµ ìš©ë„ë§Œ í•„ìš”í•˜ë©´ ì´ ì •ë„ë§Œ
                    lastCountedSource = src;
                }

                // ì‚¬ìš©ëŸ‰ ì¦ê°€ ì—†ì´, ë©”ì‹œì§€ë§Œ í‘œì‹œ
                // âœ… ì—¬ê¸°ì„œ í”Œë¡œìš°ì°¨íŠ¸ê°€ "ì„±ê³µì ìœ¼ë¡œ" ìƒì„±ë˜ë©´
                //    UPGRADE ë²„íŠ¼ ê¹œë¹¡ì„ì€ í•­ìƒ ëˆë‹¤.
                if (!isTestUser) {
                    const ub = document.getElementById("upgradeButton");
                    if (ub) ub.classList.remove("upgrade-blink");

                    if (window.__planTier === "expert") {
                        setStatus(
                            "success",
                            `${auto ? "Refresh complete." : "Flowchart creation complete."} Expert plan: up to ${EXPERT_NODE_LIMIT} nodes per diagram.`
                        );
                    } else if (window.__isProUser) {
                        setStatus(
                            "success",
                            `${auto ? "Refresh complete." : "Flowchart creation complete."} Pro plan: up to ${PRO_NODE_LIMIT} nodes per diagram.`
                        );
                    } else {
                        // Free ìœ ì €: ê°€ëŠ¥í•˜ë©´ ì˜¤ëŠ˜ ì‚¬ìš©ëŸ‰ í‘œì‹œ
                        const count = window.__serverUsageCount;
                        const limit = window.__dailyFreeLimit;

                        if (typeof count === "number" && typeof limit === "number") {
                            setStatus(
                                "success",
                                `Refresh complete. Free tier: Today ${count} / ${limit} (â‰¤ ${FREE_NODE_LIMIT} nodes).`
                            );
                        } else {
                            setStatus(
                                "success",
                                `Refresh complete. Free tier: 5 diagrams/day, â‰¤ ${FREE_NODE_LIMIT} nodes.`
                            );
                        }
                    }
                } else {
                    setStatus(
                        "success",
                        `${auto ? "Refresh Complete." : "Flowchart creation complete."} (Test account: unlimited)`
                    );

                    const ub = document.getElementById("upgradeButton");
                    if (ub) ub.classList.remove("upgrade-blink");
                }

                // Function name ì¶œë ¥ ë°©ì‹ ë°˜ì˜ (Short / Full)
                let displayName = funcName;
                if (funcNameStyle === "full" && fullSignature) {
                    displayName = fullSignature;
                }

                currentFunc.textContent = displayName ? `Function: ${displayName}` : "";

                // ìƒë‹¨ ë¬´ë£Œ ì •ì±… ì•ˆë‚´ ê°±ì‹ 
                updateQuotaInfo();

            } catch (err) {
                console.error(err);
                const msg = "An unexpected error occurred while talking to the server. Please try again.";
                setStatus("error", msg);
                chartInner.innerHTML = `<p class="placeholder" style="color:#b91c1c;">${msg}</p>`;
                currentFunc.textContent = "";
            }
        }

        function setupSplitDrag() {
            const main = document.querySelector(".main");
            const leftPane = document.getElementById("leftPane");
            const rightPane = document.getElementById("rightPane");
            const divider = document.getElementById("divider");

            let isDragging = false;

            divider.addEventListener("mousedown", function(e) {
                e.preventDefault();
                isDragging = true;
                document.body.style.cursor = "col-resize";
            });

            document.addEventListener("mousemove", function(e) {
                if (!isDragging) return;
                const rect = main.getBoundingClientRect();
                const totalWidth = rect.width;
                let offsetX = e.clientX - rect.left;
                // ìµœì†Œ/ìµœëŒ€ ë¹„ìœ¨ ì œí•œ (20% ~ 70%)
                let leftPercent = Math.max(0.2, Math.min(0.7, offsetX / totalWidth));
                let rightPercent = 1 - leftPercent;

                leftPane.style.flex = "0 0 " + (leftPercent * 100).toFixed(1) + "%";
                rightPane.style.flex = "0 0 " + (rightPercent * 100).toFixed(1) + "%";
            });

            document.addEventListener("mouseup", function() {
                if (isDragging) {
                    isDragging = false;
                    document.body.style.cursor = "default";
                }
            });
        }

        document.addEventListener("DOMContentLoaded", function() {
            const src = document.getElementById("src");
            const lineNumbers = document.getElementById("lineNumbers");

            // ë¼ì¸ ë²ˆí˜¸ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
            function updateLineNumbers() {
                if (!src || !lineNumbers) return;
                const lines = src.value.split("\n").length || 1;
                let html = "";
                for (let i = 1; i <= lines; i++) {
                    html += i + "<br>";
                }
                lineNumbers.innerHTML = html;
            }

            // ì´ë²¤íŠ¸ ì—°ê²° (ì…ë ¥/ìŠ¤í¬ë¡¤)
            if (src && lineNumbers) {
                src.addEventListener("input", updateLineNumbers);
                src.addEventListener("scroll", () => {
                    lineNumbers.scrollTop = src.scrollTop;  // ìŠ¤í¬ë¡¤ ë™ê¸°í™”
                });
                updateLineNumbers(); // ì´ˆê¸° 1,2,3,... í‘œì‹œ
            }

            // ----- ì´ˆê¸° í…Œë§ˆ ë¡œë”© -----
            let savedTheme = "classic";
            try {
                const t = localStorage.getItem("autoflow-theme");
                if (t) savedTheme = t;
            } catch (e) {}
            applyTheme(savedTheme);

            // ë¼ë””ì˜¤ ë²„íŠ¼ ìƒíƒœ ë™ê¸°í™”
            const themeRadios = document.querySelectorAll('input[name="theme"]');
            themeRadios.forEach(r => {
                if (r.value === savedTheme) {
                    r.checked = true;
                }
                r.addEventListener("change", (e) => {
                    if (e.target.checked) {
                        applyTheme(e.target.value);
                        // í…Œë§ˆ ë°”ë€Œë©´ í”Œë¡œìš°ì°¨íŠ¸ë„ ë‹¤ì‹œ ê·¸ë ¤ì£¼ê³  ì‹¶ìœ¼ë©´:
                        // generateFlowchart(true);
                    }
                });
            });

            // Branch Shape ì´ˆê¸°í™”
            let savedBranchShape = "rounded";
            try {
                const bs = localStorage.getItem("autoflow-branch-shape");
                if (bs) savedBranchShape = bs;
            } catch (e) {}
            currentBranchShape = savedBranchShape;

            const branchRadios = document.querySelectorAll('input[name="branchShape"]');
            branchRadios.forEach(r => {
                if (r.value === savedBranchShape) {
                    r.checked = true;
                }
                r.addEventListener("change", (e) => {
                    if (e.target.checked) {
                        currentBranchShape = e.target.value;
                        try {
                            localStorage.setItem("autoflow-branch-shape", currentBranchShape);
                        } catch (e2) {}
                        // í•„ìš”í•˜ë©´ í…Œë§ˆì²˜ëŸ¼ ìë™ ì¬ìƒì„±ë„ ê°€ëŠ¥:
                        generateFlowchart(true);
                    }
                });
            });

            // ============================
            // Function Name Display ì´ˆê¸°í™”
            // ============================

            try {
                const savedStyle = localStorage.getItem("autoflow-funcname-style");
                if (savedStyle) funcNameStyle = savedStyle;
            } catch (e){}

            const funcNameRadios = document.querySelectorAll('input[name="funcNameStyle"]');
            funcNameRadios.forEach(r => {
                if (r.value === funcNameStyle) {
                    r.checked = true;
                }
                r.addEventListener("change", (e) => {
                    if (e.target.checked) {
                        funcNameStyle = e.target.value;   // âœ” ì „ì—­ ë³€ìˆ˜ì— ì €ì¥ë¨
                        localStorage.setItem("autoflow-funcname-style", funcNameStyle);
                        generateFlowchart(true);
                    }
                });
            });


            // ============================
            // SETTINGS ëª¨ë‹¬ ë“œë˜ê·¸
            // ============================
            const settingsOverlay = document.getElementById("settingsOverlay");
            const settingsPanel = settingsOverlay
                ? settingsOverlay.querySelector(".modal-panel")
                : null;
            const settingsHeader = settingsPanel
                ? settingsPanel.querySelector(".modal-header")
                : null;

            // ë°°ê²½ í´ë¦­í•˜ë©´ ë‹«ê¸°
            if (settingsOverlay) {
                settingsOverlay.addEventListener("click", function (e) {
                    if (e.target === settingsOverlay) {
                        closeSettings();
                    }
                });
            }

            let isDraggingSettings = false;
            let dragStartX = 0;
            let dragStartY = 0;
            let panelStartLeft = 0;
            let panelStartTop = 0;

            if (settingsHeader && settingsPanel) {
                // í—¤ë”ì— ë§ˆìš°ìŠ¤ ì•„ì´ì½˜ ë³€ê²½
                settingsHeader.style.cursor = "move";

                // ë“œë˜ê·¸ ì‹œì‘
                settingsHeader.addEventListener("mousedown", function (e) {
                    if (e.button !== 0) return; // ì™¼ìª½ ë²„íŠ¼ë§Œ
                    isDraggingSettings = true;

                    const rect = settingsPanel.getBoundingClientRect();
                    dragStartX = e.clientX;
                    dragStartY = e.clientY;
                    panelStartLeft = rect.left;
                    panelStartTop = rect.top;

                    // ë·°í¬íŠ¸ ê¸°ì¤€ ê³ ì • ìœ„ì¹˜
                    settingsPanel.style.position = "fixed";
                    settingsPanel.style.left = `${panelStartLeft}px`;
                    settingsPanel.style.top = `${panelStartTop}px`;

                    e.preventDefault(); // í…ìŠ¤íŠ¸ ì„ íƒ ë°©ì§€
                });
            }

            // ë“œë˜ê·¸ ì¤‘
            document.addEventListener("mousemove", function (e) {
                if (!isDraggingSettings || !settingsPanel) return;

                const dx = e.clientX - dragStartX;
                const dy = e.clientY - dragStartY;

                let newLeft = panelStartLeft + dx;
                let newTop  = panelStartTop + dy;

                // í™”ë©´ ë°–ìœ¼ë¡œ ì•ˆ ë‚˜ê°€ë„ë¡ ì œí•œ
                const maxLeft = window.innerWidth - settingsPanel.offsetWidth;
                const maxTop  = window.innerHeight - settingsPanel.offsetHeight;

                if (newLeft < 0) newLeft = 0;
                if (newTop < 0) newTop = 0;
                if (newLeft > maxLeft) newLeft = maxLeft;
                if (newTop > maxTop) newTop = maxTop;

                settingsPanel.style.left = `${newLeft}px`;
                settingsPanel.style.top  = `${newTop}px`;
            });

            // ë“œë˜ê·¸ ì¢…ë£Œ
            document.addEventListener("mouseup", function () {
                isDraggingSettings = false;
            });


            updateZoomLabel();
            setupSplitDrag();

            // ì½”ë“œ â†’ ë…¸ë“œ í•˜ì´ë¼ì´íŠ¸ ì—°ë™
            ["click", "keyup", "mouseup"].forEach(ev => {
                src.addEventListener(ev, updateNodeHighlightFromCaret);
            });            

            // ìš°ì¸¡ í”Œë¡œìš°ì°¨íŠ¸ ì˜ì—­ì—ì„œ Ctrl+íœ ë¡œ ê·¸ë¦¼ë§Œ ì¤Œ
            const chartContainer = document.getElementById("chartContainer");
            chartContainer.addEventListener("wheel", function(e) {
                // Ctrl í‚¤ê°€ ëˆŒë ¤ ìˆì§€ ì•Šìœ¼ë©´ ê·¸ëƒ¥ ìŠ¤í¬ë¡¤
                if (!e.ctrlKey) return;

                // ë¸Œë¼ìš°ì €ì˜ ê¸°ë³¸ í˜ì´ì§€ ì¤Œ ë§‰ê¸°
                e.preventDefault();

                // deltaY < 0 ì´ë©´ íœ  ìœ„ë¡œ(í™•ëŒ€), > 0 ì´ë©´ ì•„ë˜ë¡œ(ì¶•ì†Œ)
                if (e.deltaY < 0) {
                    zoomChange(+0.1);
                } else if (e.deltaY > 0) {
                    zoomChange(-0.1);
                }
            }, { passive: false });

            // ğŸ”¹ ì¢Œí´ë¦­ ë“œë˜ê·¸ë¡œ íŒ¨ë‹
            let isPanning = false;
            let startX = 0;
            let startY = 0;
            let startScrollLeft = 0;
            let startScrollTop = 0;

            chartContainer.addEventListener("mousedown", function(e) {
                if (e.button !== 0) return; // ì™¼ìª½ ë²„íŠ¼ë§Œ
                isPanning = true;
                startX = e.clientX;
                startY = e.clientY;
                startScrollLeft = chartContainer.scrollLeft;
                startScrollTop = chartContainer.scrollTop;
                e.preventDefault(); // í…ìŠ¤íŠ¸ ì„ íƒ ë°©ì§€
            });

            document.addEventListener("mousemove", function(e) {
                if (!isPanning) return;
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                chartContainer.scrollLeft = startScrollLeft - dx;
                chartContainer.scrollTop = startScrollTop - dy;
            });

            document.addEventListener("mouseup", function() {
                isPanning = false;
            });            


            // íƒ€ì´í•‘ ìë™ ì—…ë°ì´íŠ¸ (debounce)
            src.addEventListener("input", function() {
                if (typingTimer) clearTimeout(typingTimer);
                typingTimer = setTimeout(function() {
                    generateFlowchart(true);
                }, TYPING_DELAY_MS);
            });
            
            // ì½”ë“œ í´ë¦­/ì´ë™ ì‹œ â†’ í•´ë‹¹ ë¼ì¸ ë…¸ë“œ í•˜ì´ë¼ì´íŠ¸
            src.addEventListener("click", updateNodeHighlightFromCaret);
            src.addEventListener("keyup", updateNodeHighlightFromCaret);
            src.addEventListener("mouseup", updateNodeHighlightFromCaret);

            // ë°±ì—”ë“œ ë²„ì „ ì •ë³´ í‘œì‹œ
            fetchBackendVersion();
        });
    </script>
</head>
<body>
    <header>
        <div>
            <h1>mAutoFlow</h1>
            <div class="subtitle">
                When you enter C code on the left, a flowchart is automatically generated on the right.
            </div>
        </div>

        <!-- ì˜¤ë¥¸ìª½ ìƒë‹¨ ë©”ë‰´: ë¡œê·¸ì¸ + ë²„íŠ¼ + ë°±ì—”ë“œ ë²„ì „ -->
        <div class="topbar-right">
            <!-- ë¡œê·¸ì¸ ì˜ì—­ -->
            <span id="welcomeText" style="margin-right:8px;"></span>

            <div id="loggedOutButtons" style="display:inline-flex; gap:4px; margin-right:8px;">
                <button class="btn-settings" onclick="loginWithGoogle()">Login with Google</button>
            </div>

            <div id="loggedInButtons" style="display:none; gap:4px; margin-right:8px;">
                <button class="btn-settings" onclick="logout()">Logout</button>
            </div>
            <!-- ë¡œê·¸ì¸ ì˜ì—­ ë -->

            <!-- ê¸°ëŠ¥ ë²„íŠ¼ë“¤ -->
            <button id="upgradeButton"
                    class="btn-settings"
                    onclick="openProCheckout()">
                UPGRADE
            </button>
            <button class="btn-settings" onclick="downloadDiagram()">DOWNLOAD</button>
            <button class="btn-settings" onclick="openSettings()">SETTINGS</button>
            <button id="helpToggleBtn" class="btn-settings" onclick="toggleHelp()">HELP</button>

            <!-- ë°±ì—”ë“œ ë²„ì „ í‘œì‹œ -->
            <span id="backendVersion" style="margin-left:8px; font-size:11px; opacity:0.75;"></span>
        </div>
    </header>
    <div class="main">
        <div id="leftPane">
            <div class="pane-header">
                <span class="pane-title">Source Code</span>
            </div>
            <div id="codeContainer">
                <div id="codeHeader">
                    <span>mAutoFlow</span>
                    <span style="opacity:0.7;">Automatic analysis</span>
                </div>
                <div id="codeArea">
                    <div id="lineNumbers"></div>
                    <textarea id="src" spellcheck="false" placeholder="Example:
void main(void)
{
    int x = 0;

    if (x == 0)
    {
        x++;
    }
    else
    {
        x--;
    }
}"></textarea>
                </div>
            </div>
        </div>

        <div id="divider"></div>

        <div id="rightPane">
            <div class="pane-header">
                <span class="pane-title">Flowchart</span>
                <div style="display:flex; align-items:center; gap:6px;">
                    <button class="btn btn-ghost" onclick="zoomChange(-0.1)">âˆ’</button>
                    <button class="btn btn-ghost" onclick="zoomReset()">100%</button>
                    <button class="btn btn-ghost" onclick="zoomChange(0.1)">+</button>
                    <span class="zoom-label" id="zoomLabel"></span>
                </div>
            </div>
            <div id="toolbar">
                <button class="btn btn-primary" onclick="generateFlowchart(false)">Regenerate Now</button>
                <span id="currentFunc"></span>
                <span id="status"></span>
                <span id="quotaInfo" style="margin-left:8px; font-size:12px; opacity:0.8;"></span>
            </div>
            <div id="chartContainer">
                <div id="chartInner">
                    <p class="placeholder">
                        When you enter C code on the left, a flowchart is automatically generated on the right.
                    </p>
                </div>
            </div>
        </div>
    </div>
    <!-- SETTINGS ëª¨ë‹¬: ì—¬ê¸° ì¶”ê°€ -->
    <div id="settingsOverlay" class="modal-overlay modal-hidden">
        <div class="modal-panel">
            <div class="modal-header">
                <h2>SETTINGS</h2>
                <button class="modal-close" onclick="closeSettings()">Ã—</button>
            </div>

            <!-- Theme ì„¹ì…˜ -->
            <div class="modal-section">
                <div class="modal-section-title">Theme</div>
                <div class="modal-radio-row">
                    <label>
                        <input type="radio" name="theme" value="classic" checked />
                        Classic (Current style)
                    </label>
                    <label>
                        <input type="radio" name="theme" value="light" />
                        Light
                    </label>
                    <label>
                        <input type="radio" name="theme" value="dark" />
                        Dark
                    </label>
                </div>
            </div>

            <!-- Branch Shape ì„¹ì…˜ ë³µêµ¬ -->
            <div class="modal-section">
                <div class="modal-section-title">Branch Shape</div>
                <div class="modal-radio-row">
                    <label>
                        <input type="radio" name="branchShape" value="rounded" checked />
                        Rounded
                    </label>
                    <label>
                        <input type="radio" name="branchShape" value="diamond" />
                        Diamond
                    </label>
                </div>
            </div>

            <!-- Function Name Display ì„¹ì…˜ -->
            <div class="modal-section">
                <div class="modal-section-title">Function Name Display</div>
                <div class="modal-radio-row">
                    <label>
                        <input type="radio" name="funcNameStyle" value="short" checked />
                        Short
                    </label>
                    <label>
                        <input type="radio" name="funcNameStyle" value="full" />
                        Full
                    </label>
                </div>
            </div>
            <div style="margin-top:8px; font-size:11px; opacity:0.8;">
                Contact: 
                <a href="mailto:mautoflow.lab@gmail.com">mautoflow.lab@gmail.com</a>
            </div>

            <div style="text-align:right; margin-top:10px; font-size:12px;">
                <button class="btn btn-ghost" onclick="closeSettings()">Close</button>
            </div>
        </div>
    </div>
    <!--  Supabase Auth ìŠ¤í¬ë¦½íŠ¸: </body> ë°”ë¡œ ìœ„ì— ì¶”ê°€ -->
    <script type="module">
        import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

        //  ì—¬ê¸° ë‘ ê°’ì€ ë³¸ì¸ í”„ë¡œì íŠ¸ ê°’ìœ¼ë¡œ êµì²´í•´ì•¼ í•¨
        const SUPABASE_URL = "https://layaiawwnioetzuxcyev.supabase.co";   // ì˜ˆì‹œ: ëŒ€ì‰¬ë³´ë“œì˜ Project URL
        const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImxheWFpYXd3bmlvZXR6dXhjeWV2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQ3NjIxMjgsImV4cCI6MjA4MDMzODEyOH0.ZWC86hD5JaX2Jh0b0wR6bfmqNrEWBrq-YnLu3yg1JJo";            // API íƒ­ì˜ anon public key

        const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        // ì „ì—­ì—ì„œ ì ‘ê·¼í•  ìˆ˜ ìˆê²Œ windowì— ë¶™ì´ê¸°
        window.supabase = supabase;

        // í˜„ì¬ ë¡œê·¸ì¸ ìœ ì €ë¥¼ ì „ì—­ìœ¼ë¡œ ë³´ê´€
        window.currentUser = null;

        async function updateAuthUI() {
            const { data } = await supabase.auth.getUser();
            const user = data?.user ?? null;
            window.currentUser = user;

            const welcomeText   = document.getElementById("welcomeText");
            const loggedOutDiv  = document.getElementById("loggedOutButtons");
            const loggedInDiv   = document.getElementById("loggedInButtons");
            const upgradeBtn    = document.getElementById("upgradeButton");

            if (!welcomeText || !loggedOutDiv || !loggedInDiv) return;

            if (user) {
                welcomeText.textContent = user.email
                    ? `Welcome, ${user.email}`
                    : "Welcome!";
                loggedOutDiv.style.display = "none";
                loggedInDiv.style.display  = "inline-flex";

                const isTestUser = (user.email === TEST_EMAIL);

                // UPGRADE ë²„íŠ¼: í…ŒìŠ¤íŠ¸ ê³„ì •ì€ ìˆ¨ê¸°ê³ , ë‚˜ë¨¸ì§€ëŠ” ì¼ë‹¨ í‘œì‹œ
                if (upgradeBtn) {
                    // ë¡œê·¸ì¸í•  ë•ŒëŠ” ì¼ë‹¨ ê¹œë¹¡ì„ ì œê±°
                    upgradeBtn.classList.remove("upgrade-blink");
                    upgradeBtn.style.display = isTestUser ? "none" : "inline-flex";
                }
            } else {
                welcomeText.textContent = "";
                loggedOutDiv.style.display = "inline-flex";
                loggedInDiv.style.display  = "none";
                if (upgradeBtn) {
                    upgradeBtn.style.display = "none";
                    // ë¡œê·¸ì•„ì›ƒ ì‹œì—ë„ ê¹œë¹¡ì„ ì œê±°
                    upgradeBtn.classList.remove("upgrade-blink");
                }
            }

            // ë¡œê·¸ì¸/ë¡œê·¸ì•„ì›ƒ ì‹œ ë¬´ë£Œ ì‚¬ìš©ëŸ‰ í‘œì‹œ ê°±ì‹ 
            // updateQuotaInfo();
        }

        async function loginWithGoogle() {
            await supabase.auth.signInWithOAuth({
                provider: "google",
                options: {
                    // redirectTo: "https://mautoflow-lab.netlify.app",  // Netlify ì‹¤ì œ URL
                    redirectTo: "https://mautoflow-frontend.pages.dev",  // Cloudflare URL
                    queryParams: {
                        // ë§¤ë²ˆ ê³„ì • ì„ íƒ í™”ë©´ ê°•ì œ
                        prompt: "select_account"
                    }
                }
            });
        }

        function clearAppUIOnLogout() {
            const src         = document.getElementById("src");
            const lineNumbers = document.getElementById("lineNumbers");
            const status      = document.getElementById("status");
            const currentFunc = document.getElementById("currentFunc");
            const chartInner  = document.getElementById("chartInner");
            const codeHeader  = document.getElementById("codeHeader");
            const quotaInfo = document.getElementById("quotaInfo");
            if (quotaInfo) {
              quotaInfo.textContent = "Free tier: up to 5 diagrams/day (â‰¤ 20 nodes).";
            }

            // ì½”ë“œ ì˜ì—­ ë¹„ìš°ê¸°
            if (src) {
                src.value = "";
                src.scrollTop = 0;
            }

            // ë¼ì¸ ë²ˆí˜¸ ì´ˆê¸°í™” (1 í•œ ì¤„ë§Œ)
            if (lineNumbers) {
                lineNumbers.innerHTML = "1<br>";
            }

            // ìƒíƒœ ë©”ì‹œì§€: ë¡œê·¸ì¸ í•„ìš”
            if (status) {
                status.textContent = "Please log in to use mAutoFlow.";
                status.className = "error";
            }

            // í˜„ì¬ í•¨ìˆ˜ëª… ì œê±°
            if (currentFunc) {
                currentFunc.textContent = "";
            }

            // í”Œë¡œìš°ì°¨íŠ¸ ìë¦¬ ì´ˆê¸°í™” ë¬¸êµ¬
            if (chartInner) {
                chartInner.innerHTML = `
                    <p class="placeholder">
                        When you enter C code on the left, a flowchart is automatically generated on the right.
                    </p>
                `;
            }

            // ì½”ë“œ í—¤ë” í…ìŠ¤íŠ¸ë„ ê¸°ë³¸ê°’ìœ¼ë¡œ
            if (codeHeader) {
                codeHeader.innerHTML = `
                    <span>mAutoFlow</span>
                    <span style="opacity:0.7;">Automatic analysis</span>
                `;
            }

            // ë‚´ë¶€ ìƒíƒœ ë¦¬ì…‹
            window.__nodeLines = {};
            window.__nodeCount = 0;
            lastCountedSource = "";   // ë¡œê·¸ì•„ì›ƒí•˜ë©´ ê¸°ì¤€ ì½”ë“œë„ ì´ˆê¸°í™”
        }

        async function logout() {
            await supabase.auth.signOut();
            await updateAuthUI();
            clearAppUIOnLogout();
        }

        //  ì „ì—­ì—ì„œ í˜¸ì¶œ ê°€ëŠ¥í•˜ë„ë¡ windowì— ë¶™ì´ê¸°
        window.loginWithGoogle = loginWithGoogle;
        window.logout          = logout;

        // ì²« ë¡œë”© ì‹œ ë¡œê·¸ì¸ ìƒíƒœ ë°˜ì˜
        document.addEventListener("DOMContentLoaded", updateAuthUI);
        window.updateQuotaInfo = updateQuotaInfo;
    </script>
    <!--  Supabase Auth ìŠ¤í¬ë¦½íŠ¸ ë -->

</body>
</html>

